*******************************************************************************
 Clone group 1: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.904 | CED: 1 | FED: 5 (2.2%) | SZ: 230 | XF: F | XP: F | D: 227
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\js\src\xpconnect\src\xpccomponents.cpp 973:35 -> 1018:0
   -------------------------------------------------------------------------
   nsXPCComponents_Classes::NewResolve(nsIXPConnectWrappedNative *wrapper,
                                       JSContext * cx, JSObject * obj,
                                       jsval id, PRUint32 flags,
                                       JSObject * *objp, PRBool *_retval)
   
   {
       const char* name = nsnull;
   
       if(JSVAL_IS_STRING(id) &&
          nsnull != (name = JS_GetStringBytes(JSVAL_TO_STRING(id))) &&
          name[0] != '{') // we only allow contractids here
       {
           nsCOMPtr<nsIJSCID> nsid =
               dont_AddRef(static_cast<nsIJSCID*>(nsJSCID::NewID(name)));
           if(nsid)
           {
               nsCOMPtr<nsIXPConnect> xpc;
               wrapper->GetXPConnect(getter_AddRefs(xpc));
               if(xpc)
               {
                   nsCOMPtr<nsIXPConnectJSObjectHolder> holder;
                   if(NS_SUCCEEDED(xpc->WrapNative(cx, obj,
                                                   static_cast<nsIJSCID*>(nsid),
                                                   NS_GET_IID(nsIJSCID),
                                                   getter_AddRefs(holder))))
                   {
                       JSObject* idobj;
                       if(holder && NS_SUCCEEDED(holder->GetJSObject(&idobj)))
                       {
                           jsid idid;
   
                           *objp = obj;
                           *_retval = JS_ValueToId(cx, id, &idid) &&
                                      JS_DefinePropertyById(cx, obj, idid,
                                                            OBJECT_TO_JSVAL(idobj),
                                                            nsnull, nsnull,
                                                            JSPROP_ENUMERATE |
                                                            JSPROP_READONLY |
                                                            JSPROP_PERMANENT);
                       }
                   }
               }
           }
       }
       return NS_OK;
   }
   -------------------------------------------------------------------------
   Potentially buggy differences:
2|        name[0] == '{' &&
>                        ^^
2|        IsRegisteredCLSID(name)) 
>         ^^^^^^^^^^^^^^^^^^^^^^^
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\js\src\xpconnect\src\xpccomponents.cpp 1245:39 -> 1290:0
   -------------------------------------------------------------------------
   nsXPCComponents_ClassesByID::NewResolve(nsIXPConnectWrappedNative *wrapper,
                                           JSContext * cx, JSObject * obj,
                                           jsval id, PRUint32 flags,
                                           JSObject * *objp, PRBool *_retval)
   {
       const char* name = nsnull;
   
       if(JSVAL_IS_STRING(id) &&
          nsnull != (name = JS_GetStringBytes(JSVAL_TO_STRING(id))) &&
          name[0] == '{' &&
          IsRegisteredCLSID(name)) // we only allow canonical CLSIDs here
       {
           nsCOMPtr<nsIJSCID> nsid =
               dont_AddRef(static_cast<nsIJSCID*>(nsJSCID::NewID(name)));
           if(nsid)
           {
               nsCOMPtr<nsIXPConnect> xpc;
               wrapper->GetXPConnect(getter_AddRefs(xpc));
               if(xpc)
               {
                   nsCOMPtr<nsIXPConnectJSObjectHolder> holder;
                   if(NS_SUCCEEDED(xpc->WrapNative(cx, obj,
                                                   static_cast<nsIJSCID*>(nsid),
                                                   NS_GET_IID(nsIJSCID),
                                                   getter_AddRefs(holder))))
                   {
                       JSObject* idobj;
                       if(holder && NS_SUCCEEDED(holder->GetJSObject(&idobj)))
                       {
                           jsid idid;
   
                           *objp = obj;
                           *_retval = JS_ValueToId(cx, id, &idid) &&
                                      JS_DefinePropertyById(cx, obj, idid,
                                                            OBJECT_TO_JSVAL(idobj),
                                                            nsnull, nsnull,
                                                            JSPROP_ENUMERATE |
                                                            JSPROP_READONLY |
                                                            JSPROP_PERMANENT);
                       }
                   }
               }
           }
       }
       return NS_OK;
   }
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 2: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.643 | CED: 1 | FED: 2 (4.0%) | SZ: 50 | XF: F | XP: F | D: 78
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\layout\xul\base\src\tree\src\nstreebodyframe.cpp 4527:31 -> 4537:25
   -------------------------------------------------------------------------
   nsCOMPtr<nsIPrivateDOMEvent> privateEvent(do_QueryInterface(event));
   if (!privateEvent)
     return;
   
   privateEvent->SetTrusted(PR_TRUE);
   
   nsRefPtr<nsPLDOMEvent> plevent = new nsPLDOMEvent(content, event);
   if (!plevent)
     return;
   
   plevent->PostDOMEvent();
   -------------------------------------------------------------------------
   Potentially buggy differences:
1|   return;
>    ^^^^^^
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\layout\xul\base\src\tree\src\nstreebodyframe.cpp 4615:31 -> 4624:0
   -------------------------------------------------------------------------
   nsCOMPtr<nsIPrivateDOMEvent> privateEvent(do_QueryInterface(event));
   if (!privateEvent)
     return;
   
   privateEvent->SetTrusted(PR_TRUE);
   
   nsRefPtr<nsPLDOMEvent> plevent = new nsPLDOMEvent(content, event);
   if (plevent)
     plevent->PostDOMEvent();
   }
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 3: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.683 | CED: 1 | FED: 5 (1.8%) | SZ: 273 | XF: T | XP: T | D: inf
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\modules\plugin\base\src\nspluginhost.cpp 1059:2 -> 1124:11
   -------------------------------------------------------------------------
   if (!aMimeType)
     return bCanHandleInternally ? NewEmbeddedPluginStream(aURL, aOwner, nsnull) : NS_ERROR_FAILURE;
   
   rv = SetUpPluginInstance(aMimeType, aURL, aOwner);
   
   if (NS_FAILED(rv))
     return NS_ERROR_FAILURE;
   
   nsCOMPtr<nsIPluginInstance> instanceCOMPtr;
   rv = aOwner->GetInstance(getter_AddRefs(instanceCOMPtr));
   // if we have a failure error, it means we found a plugin for the mimetype,
   // but we had a problem with the entry point
   if (rv == NS_ERROR_FAILURE)
     return rv;
   
   // if we are here then we have loaded a plugin for this mimetype
   nsNPAPIPluginInstance *instance = static_cast<nsNPAPIPluginInstance*>(instanceCOMPtr.get());
   NPWindow *window = nsnull;
   
   //we got a plugin built, now stream
   aOwner->GetWindow(window);
   
   if (instance) {
     instance->Start();
     aOwner->CreateWidget();
   
     // If we've got a native window, the let the plugin know about it.
     if (window->window) {
       ((nsPluginNativeWindow*)window)->CallSetWindow(instanceCOMPtr);
     }
   
     // create an initial stream with data
     // don't make the stream if it's a java applet or we don't have SRC or DATA attribute
     PRBool havedata = PR_FALSE;
   
     nsCOMPtr<nsIPluginTagInfo> pti(do_QueryInterface(aOwner, &rv));
   
     if (pti) {
       const char *value;
       havedata = NS_SUCCEEDED(pti->GetAttribute("SRC", &value));
       // no need to check for "data" as it would have been converted to "src"
     }
   
     if (havedata && !isJava && bCanHandleInternally)
       rv = NewEmbeddedPluginStream(aURL, aOwner, instance);
   
     // notify Java DOM component
     nsresult res;
     nsCOMPtr<nsIPluginInstanceOwner> javaDOM =
              do_GetService("@mozilla.org/blackwood/java-dom;1", &res);
     if (NS_SUCCEEDED(res) && javaDOM)
       javaDOM->SetInstance(instance);
   }
   
   fdef PLUGIN_LOGGING
   nsCAutoString urlSpec2;
   if (aURL != nsnull) aURL->GetAsciiSpec(urlSpec2);
   
   PR_LOG(nsPluginLogging::gPluginLog, PLUGIN_LOG_NORMAL,
         ("nsPluginHost::InstantiateEmbeddedPlugin Finished mime=%s, rv=%d, owner=%p, url=%s\n",
         aMimeType, rv, aOwner, urlSpec2.get()));
   
   PR_LogFlush();
   ndif
   
   return rv;
   -------------------------------------------------------------------------
   Potentially buggy differences:
2|   NS_RELEASE(instance);
>    ^^^^^^^^^^^^^^^^^^^^
   -------------------------------------------------------------------------
   c:\mozilla-central\modules\plugin\base\src\nspluginhost.cpp 1066:2 -> 1134:11
   -------------------------------------------------------------------------
   if (!aMimeType)
     return bCanHandleInternally ? NewEmbeddedPluginStream(aURL, aOwner, nsnull) : NS_ERROR_FAILURE;
   
   rv = SetUpPluginInstance(aMimeType, aURL, aOwner);
   
   if (NS_FAILED(rv))
     return NS_ERROR_FAILURE;
   
   rv = aOwner->GetInstance(instance);
   
   // if we have a failure error, it means we found a plugin for the mimetype,
   // but we had a problem with the entry point
   if (rv == NS_ERROR_FAILURE)
     return rv;
   
   // if we are here then we have loaded a plugin for this mimetype
   
   NPWindow *window = nsnull;
   
   //we got a plugin built, now stream
   aOwner->GetWindow(window);
   
   if (instance) {
     instance->Start();
     aOwner->CreateWidget();
   
     // If we've got a native window, the let the plugin know about it.
     if (window->window) {
       nsCOMPtr<nsIPluginInstance> inst = instance;
       ((nsPluginNativeWindow*)window)->CallSetWindow(inst);
     }
   
     // create an initial stream with data
     // don't make the stream if it's a java applet or we don't have SRC or DATA attribute
     PRBool havedata = PR_FALSE;
   
     nsCOMPtr<nsIPluginTagInfo> pti(do_QueryInterface(aOwner, &rv));
   
     if (pti) {
       const char *value;
       havedata = NS_SUCCEEDED(pti->GetAttribute("SRC", &value));
       // no need to check for "data" as it would have been converted to "src"
     }
   
     if (havedata && !isJava && bCanHandleInternally)
       rv = NewEmbeddedPluginStream(aURL, aOwner, instance);
   
     // notify Java DOM component
     nsresult res;
     nsCOMPtr<nsIPluginInstanceOwner> javaDOM =
              do_GetService("@mozilla.org/blackwood/java-dom;1", &res);
     if (NS_SUCCEEDED(res) && javaDOM)
       javaDOM->SetInstance(instance);
   
     NS_RELEASE(instance);
   }
   
   fdef PLUGIN_LOGGING
   nsCAutoString urlSpec2;
   if (aURL != nsnull) aURL->GetAsciiSpec(urlSpec2);
   
   PR_LOG(nsPluginLogging::gPluginLog, PLUGIN_LOG_NORMAL,
         ("nsPluginHost::InstantiateEmbeddedPlugin Finished mime=%s, rv=%d, owner=%p, url=%s\n",
         aMimeType, rv, aOwner, urlSpec2.get()));
   
   PR_LogFlush();
   ndif
   
   return rv;
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 4: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.742 | CED: 1 | FED: 1 (0.9%) | SZ: 116 | XF: F | XP: F | D: 278
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\js\src\xpconnect\src\xpccomponents.cpp 3504:4 -> 3532:17
   -------------------------------------------------------------------------
   if(!cc)
       return NS_ERROR_FAILURE;
   
   // Get JSContext of current call
   JSContext* cx;
   rv = cc->GetJSContext(&cx);
   if(NS_FAILED(rv) || !cx)
       return NS_ERROR_FAILURE;
   
   // get place for return value
   jsval *rval = nsnull;
   rv = cc->GetRetValPtr(&rval);
   if(NS_FAILED(rv) || !rval)
       return NS_ERROR_FAILURE;
   
   // get argc and argv and verify arg count
   PRUint32 argc;
   rv = cc->GetArgc(&argc);
   if(NS_FAILED(rv))
       return rv;
   
   // The second argument is the sandbox object. It is required.
   if (argc < 2)
       return NS_ERROR_XPC_NOT_ENOUGH_ARGS;
   
   jsval *argv;
   rv = cc->GetArgvPtr(&argv);
   if (NS_FAILED(rv))
       return rv;
   -------------------------------------------------------------------------
   Potentially buggy differences:
1|     return rv;
>             --
2|   return NS_ERROR_FAILURE;
>           ----------------
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\js\src\xpconnect\src\xpccomponents.cpp 3810:2 -> 3837:27
   -------------------------------------------------------------------------
   if(!cc)
     return NS_ERROR_FAILURE;
   
   // Get JSContext of current call
   JSContext* cx;
   rv = cc->GetJSContext(&cx);
   if(NS_FAILED(rv) || !cx)
     return NS_ERROR_FAILURE;
   
   // get place for return value
   jsval *rval = nsnull;
   rv = cc->GetRetValPtr(&rval);
   if(NS_FAILED(rv) || !rval)
     return NS_ERROR_FAILURE;
   
   // get argc and argv and verify arg count
   PRUint32 argc;
   rv = cc->GetArgc(&argc);
   if(NS_FAILED(rv))
     return NS_ERROR_FAILURE;
   
   if(argc != 1)
     return NS_ERROR_XPC_NOT_ENOUGH_ARGS;
   
   jsval* argv;
   rv = cc->GetArgvPtr(&argv);
   if(NS_FAILED(rv) || !argv)
     return NS_ERROR_FAILURE;
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 5: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.759 | CED: 2 | FED: 6 (4.7%) | SZ: 127 | XF: F | XP: F | D: 7
   -------------------------------------------------------------------------
   c:\comm-central\mailnews\import\src\nsimportmimeencode.cpp 317:4 -> 334:12
   -------------------------------------------------------------------------
   if (result)
     result = m_pOut->WriteStr( pTag);
   numStr = "*";
   numStr.AppendInt( tagNum);
   if (result)
     result = m_pOut->WriteStr( numStr.get());
   if (wasTrans && result)
     result = m_pOut->WriteStr( "*=");
   else if (result)
     result = m_pOut->WriteStr( "=\"");
   if (result)
     result = m_pOut->WriteData( ((const PRUint8 *)fName.get()) + idx, len);
   if (wasTrans && result)
     result = m_pOut->WriteStr( "\x0D\x0A");
   else if (result)
     result = m_pOut->WriteStr( "\"\x0D\x0A");
   idx += len;
   tagNum++;
   -------------------------------------------------------------------------
   Potentially buggy differences:
2|   result = m_pOut->WriteData( ((const PRUint8 *)fName.get()) + idx, fName.Length() - idx);
>                                                                      ^^^^^^      ^^ ^ ^^^
   -------------------------------------------------------------------------
   c:\comm-central\mailnews\import\src\nsimportmimeencode.cpp 341:6 -> 356:48
   -------------------------------------------------------------------------
   if (result)
     result = m_pOut->WriteStr( pTag);
   numStr = "*";
   numStr.AppendInt( tagNum);
   if (result)
     result = m_pOut->WriteStr( numStr.get());
   if (wasTrans && result)
     result = m_pOut->WriteStr( "*=");
   else if (result)
     result = m_pOut->WriteStr( "=\"");
   if (result)
     result = m_pOut->WriteData( ((const PRUint8 *)fName.get()) + idx, fName.Length() - idx);
   if (wasTrans && result)
     result = m_pOut->WriteStr( "\x0D\x0A");
   else if (result)
     result = m_pOut->WriteStr( "\"\x0D\x0A");
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 6: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.645 | CED: 1 | FED: 18 (16.1%) | SZ: 112 | XF: F | XP: F | D: 3
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\caps\src\nsscriptsecuritymanager.cpp 3075:42 -> 3109:0
   -------------------------------------------------------------------------
   nsScriptSecurityManager::CanCreateInstance(JSContext *cx,
                                              const nsCID &aCID)
   {
   #ifdef DEBUG_CAPS_CanCreateInstance
       char* cidStr = aCID.ToString();
       printf("### CanCreateInstance(%s) ", cidStr);
       NS_Free(cidStr);
   #endif
   
       nsresult rv = CheckXPCPermissions(nsnull, nsnull, nsnull, nsnull, nsnull);
       if (NS_FAILED(rv))
   #ifdef XPC_IDISPATCH_SUPPORT
       {
           rv = CheckComponentPermissions(cx, aCID);
       }
       if (NS_FAILED(rv))
   #endif
       {
           //-- Access denied, report an error
           nsCAutoString errorMsg("Permission denied to create instance of class. CID=");
           char cidStr[NSID_LENGTH];
           aCID.ToProvidedString(cidStr);
           errorMsg.Append(cidStr);
           SetPendingException(cx, errorMsg.get());
   
   #ifdef DEBUG_CAPS_CanCreateInstance
           printf("DENIED\n");
       }
       else
       {
           printf("GRANTED\n");
   #endif
       }
       return rv;
   }
   -------------------------------------------------------------------------
   Potentially buggy differences:
1|     if (NS_FAILED(rv))
>      ^^ ^^^^^^^^^^^^^^^
1|     {
>      ^
1|         rv = CheckComponentPermissions(cx, aCID);
>          ^^ ^ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ^^^^^
1|     }
>      ^
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\caps\src\nsscriptsecuritymanager.cpp 3112:38 -> 3141:0
   -------------------------------------------------------------------------
   nsScriptSecurityManager::CanGetService(JSContext *cx,
                                          const nsCID &aCID)
   {
   #ifdef DEBUG_CAPS_CanGetService
       char* cidStr = aCID.ToString();
       printf("### CanGetService(%s) ", cidStr);
       NS_Free(cidStr);
   #endif
   
       nsresult rv = CheckXPCPermissions(nsnull, nsnull, nsnull, nsnull, nsnull);
       if (NS_FAILED(rv))
       {
           //-- Access denied, report an error
           nsCAutoString errorMsg("Permission denied to get service. CID=");
           char cidStr[NSID_LENGTH];
           aCID.ToProvidedString(cidStr);
           errorMsg.Append(cidStr);
           SetPendingException(cx, errorMsg.get());
   
   #ifdef DEBUG_CAPS_CanGetService
           printf("DENIED\n");
       }
       else
       {
           printf("GRANTED\n");
   #endif
       }
   
       return rv;
   }
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 7: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.629 | CED: 1 | FED: 4 (2.0%) | SZ: 196 | XF: F | XP: F | D: 17
   -------------------------------------------------------------------------
   c:\mozilla-central\content\canvas\src\webglcontextgl.cpp 1119:14 -> 1153:16
   -------------------------------------------------------------------------
   WebGLuint progname;
   if (!GetGLName<WebGLProgram>(pobj, &progname))
       return ErrorInvalidOperation("GetActiveAttrib: invalid program");
   
   NativeJSContext js;
   if (NS_FAILED(js.error))
       return js.error;
   
   MakeContextCurrent();
   
   GLint len = 0;
   gl->fGetProgramiv(progname, LOCAL_GL_ACTIVE_ATTRIBUTE_MAX_LENGTH, &len);
   if (len == 0) {
       *retval = nsnull;
       return NS_OK;
   }
   
   nsAutoArrayPtr<char> name(new char[len]);
   PRInt32 attrsize = 0;
   PRUint32 attrtype = 0;
   
   gl->fGetActiveAttrib(progname, index, len, &len, (GLint*) &attrsize, (WebGLuint*) &attrtype, name);
   if (attrsize == 0 || attrtype == 0) {
       *retval = nsnull;
       return NS_OK;
   }
   
   JSObjectHelper retobj(&js);
   retobj.DefineProperty("size", attrsize);
   retobj.DefineProperty("type", attrtype);
   retobj.DefineProperty("name", name, len);
   
   js.SetRetVal(retobj);
   
   return NS_OK;
   -------------------------------------------------------------------------
   Potentially buggy differences:
2| if (len == 0 || attrsize == 0 || attrtype == 0) {
>      ^^^ ^^ ^ ^^
   -------------------------------------------------------------------------
   c:\mozilla-central\content\canvas\src\webglcontextgl.cpp 1170:14 -> 1204:16
   -------------------------------------------------------------------------
   WebGLuint progname;
   if (!GetGLName<WebGLProgram>(pobj, &progname))
       return ErrorInvalidOperation("GetActiveUniform: invalid program");
   
   NativeJSContext js;
   if (NS_FAILED(js.error))
       return js.error;
   
   MakeContextCurrent();
   
   GLint len = 0;
   gl->fGetProgramiv(progname, LOCAL_GL_ACTIVE_UNIFORM_MAX_LENGTH, &len);
   if (len == 0) {
       *retval = nsnull;
       return NS_OK;
   }
   
   nsAutoArrayPtr<char> name(new char[len]);
   PRInt32 attrsize = 0;
   PRUint32 attrtype = 0;
   
   gl->fGetActiveUniform(progname, index, len, &len, (GLint*) &attrsize, (WebGLenum*) &attrtype, name);
   if (len == 0 || attrsize == 0 || attrtype == 0) {
       *retval = nsnull;
       return NS_OK;
   }
   
   JSObjectHelper retobj(&js);
   retobj.DefineProperty("size", attrsize);
   retobj.DefineProperty("type", attrtype);
   retobj.DefineProperty("name", name, len);
   
   js.SetRetVal(retobj.Object());
   
   return NS_OK;
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 8: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.709 | CED: 1 | FED: 2 (2.2%) | SZ: 93 | XF: F | XP: F | D: 13
   -------------------------------------------------------------------------
   c:\mozilla-central\toolkit\components\places\src\nsplacesimportexportservice.cpp 2439:2 -> 2450:43
   -------------------------------------------------------------------------
   NS_ENSURE_SUCCESS(rv, rv);
   rv = mHistoryService->ExecuteQuery(query, options, getter_AddRefs(result));
   NS_ENSURE_SUCCESS(rv, rv);
   rv = result->GetRoot(getter_AddRefs(rootNode));
   NS_ENSURE_SUCCESS(rv, rv);
   // Write it out only if it's not empty.
   rv = rootNode->SetContainerOpen(PR_TRUE);
   NS_ENSURE_SUCCESS(rv, rv);
   PRUint32 childCount = 0;
   rv = rootNode->GetChildCount(&childCount);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = rootNode->SetContainerOpen(PR_FALSE);
   -------------------------------------------------------------------------
   Potentially buggy differences:
1| rv = rootNode->GetChildCount(&childCount);
>  ^^ ^
   -------------------------------------------------------------------------
   c:\mozilla-central\toolkit\components\places\src\nsplacesimportexportservice.cpp 2463:2 -> 2474:43
   -------------------------------------------------------------------------
   NS_ENSURE_SUCCESS(rv, rv);
   rv = mHistoryService->ExecuteQuery(query, options, getter_AddRefs(result));
   NS_ENSURE_SUCCESS(rv, rv);
   rv = result->GetRoot(getter_AddRefs(rootNode));
   NS_ENSURE_SUCCESS(rv, rv);
   // Write it out only if it's not empty.
   rv = rootNode->SetContainerOpen(PR_TRUE);
   NS_ENSURE_SUCCESS(rv, rv);
   childCount = 0;
   rootNode->GetChildCount(&childCount);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = rootNode->SetContainerOpen(PR_FALSE);
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 9: 2 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.611 | CED: 3 | FED: 17 (12.0%) | SZ: 142 | XF: F | XP: F | D: 39
   -------------------------------------------------------------------------
   c:\comm-central\mailnews\import\src\nsimportservice.cpp 251:44 -> 281:0
   -------------------------------------------------------------------------
   NS_IMETHODIMP nsImportService::GetModuleName(const char *filter, PRInt32 index, PRUnichar **_retval)
   {
       NS_PRECONDITION(_retval != nsnull, "null ptr");
       if (!_retval)
           return NS_ERROR_NULL_POINTER;
   
     *_retval = nsnull;
   
       DoDiscover();
       if (!m_pModules)
       return( NS_ERROR_FAILURE);
   
     if ((index < 0) || (index >= m_pModules->GetCount()))
       return( NS_ERROR_FAILURE);
   
     ImportModuleDesc *  pDesc;
     PRInt32  count = 0;
     for (PRInt32 i = 0; i < m_pModules->GetCount(); i++) {
       pDesc = m_pModules->GetModuleDesc( i);
       if (pDesc->SupportsThings( filter)) {
         if (count == index) {
           *_retval = NS_strdup( pDesc->GetName());
           return( NS_OK);
         }
         else
           count++;
       }
     }
   
     return( NS_ERROR_FAILURE);
   }
   -------------------------------------------------------------------------
   Potentially buggy differences:
1|         *_retval = NS_strdup( pDesc->GetName());
>                                ^^^^^^^^^^^^^^^^

1|         return( NS_OK);
>          ------- ------
2|       break;
>        -----

2| if (! (*_retval))
>  ^^ ^^ ^^^^^^^^^^^
   -------------------------------------------------------------------------
   c:\comm-central\mailnews\import\src\nsimportservice.cpp 320:4 -> 348:16
   -------------------------------------------------------------------------
   NS_PRECONDITION(_retval != nsnull, "null ptr");
   if (!_retval)
       return NS_ERROR_NULL_POINTER;
   *_retval = nsnull;
   
     DoDiscover();
     if (!m_pModules)
     return( NS_ERROR_FAILURE);
   
   if ((index < 0) || (index >= m_pModules->GetCount()))
     return( NS_ERROR_FAILURE);
   
   ImportModuleDesc *  pDesc;
   PRInt32  count = 0;
   for (PRInt32 i = 0; i < m_pModules->GetCount(); i++) {
     pDesc = m_pModules->GetModuleDesc( i);
     if (pDesc->SupportsThings( filter)) {
       if (count == index) {
         *_retval = pDesc->GetModule();
         break;
       }
       else
         count++;
     }
   }
   if (! (*_retval))
     return( NS_ERROR_FAILURE);
   
   return( NS_OK);
   -------------------------------------------------------------------------

 Pair b.) TxtSim: 0.611 | CED: 3 | FED: 17 (12.0%) | SZ: 142 | XF: F | XP: F | D: 6
   -------------------------------------------------------------------------
   c:\comm-central\mailnews\import\src\nsimportservice.cpp 284:51 -> 314:0
   -------------------------------------------------------------------------
   NS_IMETHODIMP nsImportService::GetModuleDescription(const char *filter, PRInt32 index, PRUnichar **_retval)
   {
       NS_PRECONDITION(_retval != nsnull, "null ptr");
       if (!_retval)
           return NS_ERROR_NULL_POINTER;
   
     *_retval = nsnull;
   
       DoDiscover();
       if (!m_pModules)
       return( NS_ERROR_FAILURE);
   
     if ((index < 0) || (index >= m_pModules->GetCount()))
       return( NS_ERROR_FAILURE);
   
     ImportModuleDesc *  pDesc;
     PRInt32  count = 0;
     for (PRInt32 i = 0; i < m_pModules->GetCount(); i++) {
       pDesc = m_pModules->GetModuleDesc( i);
       if (pDesc->SupportsThings( filter)) {
         if (count == index) {
           *_retval = NS_strdup( pDesc->GetDescription());
           return( NS_OK);
         }
         else
           count++;
       }
     }
   
     return( NS_ERROR_FAILURE);
   }
   -------------------------------------------------------------------------
   Potentially buggy differences:
1|         *_retval = NS_strdup( pDesc->GetDescription());
>                                ^^^^^^^^^^^^^^^^^^^^^^^

1|         return( NS_OK);
>          ------- ------
2|       break;
>        -----

2| if (! (*_retval))
>  ^^ ^^ ^^^^^^^^^^^
   -------------------------------------------------------------------------
   c:\comm-central\mailnews\import\src\nsimportservice.cpp 320:4 -> 348:16
   -------------------------------------------------------------------------
   NS_PRECONDITION(_retval != nsnull, "null ptr");
   if (!_retval)
       return NS_ERROR_NULL_POINTER;
   *_retval = nsnull;
   
     DoDiscover();
     if (!m_pModules)
     return( NS_ERROR_FAILURE);
   
   if ((index < 0) || (index >= m_pModules->GetCount()))
     return( NS_ERROR_FAILURE);
   
   ImportModuleDesc *  pDesc;
   PRInt32  count = 0;
   for (PRInt32 i = 0; i < m_pModules->GetCount(); i++) {
     pDesc = m_pModules->GetModuleDesc( i);
     if (pDesc->SupportsThings( filter)) {
       if (count == index) {
         *_retval = pDesc->GetModule();
         break;
       }
       else
         count++;
     }
   }
   if (! (*_retval))
     return( NS_ERROR_FAILURE);
   
   return( NS_OK);
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 10: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.590 | CED: 1 | FED: 1 (0.6%) | SZ: 166 | XF: F | XP: F | D: 120
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\rdf\base\src\nsinmemorydatasource.cpp 1359:26 -> 1399:0
   -------------------------------------------------------------------------
   InMemoryDataSource::Assert(nsIRDFResource* aSource,
                              nsIRDFResource* aProperty,
                              nsIRDFNode* aTarget,
                              PRBool aTruthValue)
   {
       NS_PRECONDITION(aSource != nsnull, "null ptr");
       if (! aSource)
           return NS_ERROR_NULL_POINTER;
   
       NS_PRECONDITION(aProperty != nsnull, "null ptr");
       if (! aProperty)
           return NS_ERROR_NULL_POINTER;
   
       NS_PRECONDITION(aTarget != nsnull, "null ptr");
       if (! aTarget)
           return NS_ERROR_NULL_POINTER;
   
       if (mReadCount) {
           NS_WARNING("Writing to InMemoryDataSource during read\n");
           return NS_RDF_ASSERTION_REJECTED;
       }
   
       nsresult rv;
       rv = LockedAssert(aSource, aProperty, aTarget, aTruthValue);
       if (NS_FAILED(rv)) return rv;
   
       // notify observers
       for (PRInt32 i = (PRInt32)mNumObservers - 1; mPropagateChanges && i >= 0; --i) {
           nsIRDFObserver* obs = mObservers[i];
   
           // XXX this should never happen, but it does, and we can't figure out why.
           NS_ASSERTION(obs, "observer array corrupted!");
           if (! obs)
             continue;
   
           obs->OnAssert(this, aSource, aProperty, aTarget);
           // XXX ignore return value?
       }
   
       return NS_RDF_ASSERTION_ACCEPTED;
   }
   -------------------------------------------------------------------------
   Potentially buggy differences:
1|     for (PRInt32 i = (PRInt32)mNumObservers - 1; mPropagateChanges && i >= 0; --i) {
>                        -------
2|     for (PRInt32 i = PRInt32(mNumObservers) - 1; mPropagateChanges && i >= 0; --i) {
>                               -------------
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\rdf\base\src\nsinmemorydatasource.cpp 1519:28 -> 1559:0
   -------------------------------------------------------------------------
   InMemoryDataSource::Unassert(nsIRDFResource* aSource,
                                nsIRDFResource* aProperty,
                                nsIRDFNode* aTarget)
   {
       NS_PRECONDITION(aSource != nsnull, "null ptr");
       if (! aSource)
           return NS_ERROR_NULL_POINTER;
   
       NS_PRECONDITION(aProperty != nsnull, "null ptr");
       if (! aProperty)
           return NS_ERROR_NULL_POINTER;
   
       NS_PRECONDITION(aTarget != nsnull, "null ptr");
       if (! aTarget)
           return NS_ERROR_NULL_POINTER;
   
       if (mReadCount) {
           NS_WARNING("Writing to InMemoryDataSource during read\n");
           return NS_RDF_ASSERTION_REJECTED;
       }
   
       nsresult rv;
   
       rv = LockedUnassert(aSource, aProperty, aTarget);
       if (NS_FAILED(rv)) return rv;
   
       // Notify the world
       for (PRInt32 i = PRInt32(mNumObservers) - 1; mPropagateChanges && i >= 0; --i) {
           nsIRDFObserver* obs = mObservers[i];
   
           // XXX this should never happen, but it does, and we can't figure out why.
           NS_ASSERTION(obs, "observer array corrupted!");
           if (! obs)
             continue;
   
           obs->OnUnassert(this, aSource, aProperty, aTarget);
           // XXX ignore return value?
       }
   
       return NS_RDF_ASSERTION_ACCEPTED;
   }
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 11: 2 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.688 | CED: 2 | FED: 4 (3.8%) | SZ: 104 | XF: T | XP: T | D: inf
   -------------------------------------------------------------------------
   c:\comm-central\mailnews\base\src\nsmsggroupthread.cpp 778:48 -> 807:0
   -------------------------------------------------------------------------
   NS_IMETHODIMP nsMsgGroupThread::GetNewestMsgDate(PRUint32 *aResult)
   {
     // if this hasn't been set, figure it out by enumerating the msgs in the thread.
     if (!m_newestMsgDate)
     {
       PRUint32 numChildren;
       nsresult rv = NS_OK;
   
       GetNumChildren(&numChildren);
   
       if ((PRInt32) numChildren < 0)
         numChildren = 0;
   
       for (PRUint32 childIndex = 0; childIndex < numChildren; childIndex++)
       {
         nsCOMPtr <nsIMsgDBHdr> child;
         rv = GetChildHdrAt(childIndex, getter_AddRefs(child));
         if (NS_SUCCEEDED(rv) && child)
         {
           PRUint32 msgDate;
           child->GetDateInSeconds(&msgDate);
           if (msgDate > m_newestMsgDate)
             m_newestMsgDate = msgDate;
         }
       }
   
     }
     *aResult = m_newestMsgDate;
     return NS_OK;
   }
   -------------------------------------------------------------------------
   Potentially buggy differences:
1|     nsresult rv = NS_OK;
>                  ^ ^^^^^

1|       if (NS_SUCCEEDED(rv) && child)
>                             ^^ ^^^^^
   -------------------------------------------------------------------------
   c:\comm-central\mailnews\db\msgdb\src\nsmsgthread.cpp 1193:2 -> 1218:14
   -------------------------------------------------------------------------
   if (!m_newestMsgDate)
   {
     PRUint32 numChildren;
     nsresult rv;
   
     GetNumChildren(&numChildren);
   
     if ((PRInt32) numChildren < 0)
       numChildren = 0;
   
     for (PRUint32 childIndex = 0; childIndex < numChildren; childIndex++)
     {
       nsCOMPtr <nsIMsgDBHdr> child;
       rv = GetChildHdrAt(childIndex, getter_AddRefs(child));
       if (NS_SUCCEEDED(rv))
       {
         PRUint32 msgDate;
         child->GetDateInSeconds(&msgDate);
         if (msgDate > m_newestMsgDate)
           m_newestMsgDate = msgDate;
       }
     }
   
   }
   *aResult = m_newestMsgDate;
   return NS_OK;
   -------------------------------------------------------------------------

 Pair b.) TxtSim: 0.688 | CED: 2 | FED: 4 (3.8%) | SZ: 104 | XF: T | XP: T | D: inf
   -------------------------------------------------------------------------
   c:\comm-central\mailnews\base\src\nsmsgxfviewthread.cpp 433:49 -> 461:0
   -------------------------------------------------------------------------
   NS_IMETHODIMP nsMsgXFViewThread::GetNewestMsgDate(PRUint32 *aResult)
   {
     // if this hasn't been set, figure it out by enumerating the msgs in the thread.
     if (!m_newestMsgDate)
     {
       PRUint32 numChildren;
       nsresult rv = NS_OK;
   
       GetNumChildren(&numChildren);
   
       if ((PRInt32) numChildren < 0)
         numChildren = 0;
   
       for (PRUint32 childIndex = 0; childIndex < numChildren; childIndex++)
       {
         nsCOMPtr<nsIMsgDBHdr> child;
         rv = GetChildHdrAt(childIndex, getter_AddRefs(child));
         if (NS_SUCCEEDED(rv) && child)
         {
           PRUint32 msgDate;
           child->GetDateInSeconds(&msgDate);
           if (msgDate > m_newestMsgDate)
             m_newestMsgDate = msgDate;
         }
       }
     }
     *aResult = m_newestMsgDate;
     return NS_OK;
   }
   -------------------------------------------------------------------------
   Potentially buggy differences:
1|     nsresult rv = NS_OK;
>                  ^ ^^^^^

1|       if (NS_SUCCEEDED(rv) && child)
>                             ^^ ^^^^^
   -------------------------------------------------------------------------
   c:\comm-central\mailnews\db\msgdb\src\nsmsgthread.cpp 1193:2 -> 1218:14
   -------------------------------------------------------------------------
   if (!m_newestMsgDate)
   {
     PRUint32 numChildren;
     nsresult rv;
   
     GetNumChildren(&numChildren);
   
     if ((PRInt32) numChildren < 0)
       numChildren = 0;
   
     for (PRUint32 childIndex = 0; childIndex < numChildren; childIndex++)
     {
       nsCOMPtr <nsIMsgDBHdr> child;
       rv = GetChildHdrAt(childIndex, getter_AddRefs(child));
       if (NS_SUCCEEDED(rv))
       {
         PRUint32 msgDate;
         child->GetDateInSeconds(&msgDate);
         if (msgDate > m_newestMsgDate)
           m_newestMsgDate = msgDate;
       }
     }
   
   }
   *aResult = m_newestMsgDate;
   return NS_OK;
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 12: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.636 | CED: 3 | FED: 13 (4.3%) | SZ: 299 | XF: T | XP: F | D: inf
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\jpeg\jccoefct.c 343:14 -> 393:23
   -------------------------------------------------------------------------
   my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
   JDIMENSION MCU_col_num;    /* index of current MCU within row */
   int blkn, ci, xindex, yindex, yoffset;
   JDIMENSION start_col;
   JBLOCKARRAY buffer[MAX_COMPS_IN_SCAN];
   JBLOCKROW buffer_ptr;
   jpeg_component_info *compptr;
   
   /* Align the virtual buffers for the components used in this scan.
    * NB: during first pass, this is safe only because the buffers will
    * already be aligned properly, so jmemmgr.c won't need to do any I/O.
    */
   for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
     compptr = cinfo->cur_comp_info[ci];
     buffer[ci] = (*cinfo->mem->access_virt_barray)
       ((j_common_ptr) cinfo, coef->whole_image[compptr->component_index],
        coef->iMCU_row_num * compptr->v_samp_factor,
        (JDIMENSION) compptr->v_samp_factor, FALSE);
   }
   
   /* Loop to process one whole iMCU row */
   for (yoffset = coef->MCU_vert_offset; yoffset < coef->MCU_rows_per_iMCU_row;
        yoffset++) {
     for (MCU_col_num = coef->mcu_ctr; MCU_col_num < cinfo->MCUs_per_row;
      MCU_col_num++) {
       /* Construct list of pointers to DCT blocks belonging to this MCU */
       blkn = 0;            /* index of current DCT block within MCU */
       for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
     compptr = cinfo->cur_comp_info[ci];
     start_col = MCU_col_num * compptr->MCU_width;
     for (yindex = 0; yindex < compptr->MCU_height; yindex++) {
       buffer_ptr = buffer[ci][yindex+yoffset] + start_col;
       for (xindex = 0; xindex < compptr->MCU_width; xindex++) {
         coef->MCU_buffer[blkn++] = buffer_ptr++;
       }
     }
       }
       /* Try to write the MCU. */
       if (! (*cinfo->entropy->encode_mcu) (cinfo, coef->MCU_buffer)) {
     /* Suspension forced; update state counters and exit */
     coef->MCU_vert_offset = yoffset;
     coef->mcu_ctr = MCU_col_num;
     return FALSE;
       }
     }
     /* Completed an MCU row, but perhaps not an iMCU row */
     coef->mcu_ctr = 0;
   }
   /* Completed the iMCU row, advance counters for next one */
   coef->iMCU_row_num++;
   start_iMCU_row(cinfo);
   -------------------------------------------------------------------------
   Potentially buggy differences:
1|      coef->iMCU_row_num * compptr->v_samp_factor,
>       ----
2|      cinfo->input_iMCU_row * compptr->v_samp_factor,
>       -----

1| coef->iMCU_row_num++;
>  ----              --
2| if (++(cinfo->input_iMCU_row) < cinfo->total_iMCU_rows) {
>  -- ---------                - - ----------------------- -
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\jpeg\jdcoefct.c 246:14 -> 298:29
   -------------------------------------------------------------------------
   my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
   JDIMENSION MCU_col_num;    /* index of current MCU within row */
   int blkn, ci, xindex, yindex, yoffset;
   JDIMENSION start_col;
   JBLOCKARRAY buffer[MAX_COMPS_IN_SCAN];
   JBLOCKROW buffer_ptr;
   jpeg_component_info *compptr;
   
   /* Align the virtual buffers for the components used in this scan. */
   for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
     compptr = cinfo->cur_comp_info[ci];
     buffer[ci] = (*cinfo->mem->access_virt_barray)
       ((j_common_ptr) cinfo, coef->whole_image[compptr->component_index],
        cinfo->input_iMCU_row * compptr->v_samp_factor,
        (JDIMENSION) compptr->v_samp_factor, TRUE);
     /* Note: entropy decoder expects buffer to be zeroed,
      * but this is handled automatically by the memory manager
      * because we requested a pre-zeroed array.
      */
   }
   
   /* Loop to process one whole iMCU row */
   for (yoffset = coef->MCU_vert_offset; yoffset < coef->MCU_rows_per_iMCU_row;
        yoffset++) {
     for (MCU_col_num = coef->MCU_ctr; MCU_col_num < cinfo->MCUs_per_row;
      MCU_col_num++) {
       /* Construct list of pointers to DCT blocks belonging to this MCU */
       blkn = 0;            /* index of current DCT block within MCU */
       for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
     compptr = cinfo->cur_comp_info[ci];
     start_col = MCU_col_num * compptr->MCU_width;
     for (yindex = 0; yindex < compptr->MCU_height; yindex++) {
       buffer_ptr = buffer[ci][yindex+yoffset] + start_col;
       for (xindex = 0; xindex < compptr->MCU_width; xindex++) {
         coef->MCU_buffer[blkn++] = buffer_ptr++;
       }
     }
       }
       /* Try to fetch the MCU. */
       if (! (*cinfo->entropy->decode_mcu) (cinfo, coef->MCU_buffer)) {
     /* Suspension forced; update state counters and exit */
     coef->MCU_vert_offset = yoffset;
     coef->MCU_ctr = MCU_col_num;
     return JPEG_SUSPENDED;
       }
     }
     /* Completed an MCU row, but perhaps not an iMCU row */
     coef->MCU_ctr = 0;
   }
   /* Completed the iMCU row, advance counters for next one */
   if (++(cinfo->input_iMCU_row) < cinfo->total_iMCU_rows) {
     start_iMCU_row(cinfo);
     return JPEG_ROW_COMPLETED;
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 13: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.521 | CED: 1 | FED: 1 (0.9%) | SZ: 106 | XF: F | XP: F | D: 9
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\editor\libeditor\html\nshtmleditor.cpp 4894:2 -> 4919:24
   -------------------------------------------------------------------------
   NS_ENSURE_TRUE(aOutFirstLeaf && aNode, NS_ERROR_NULL_POINTER);
   
   // init out parms
   *aOutFirstLeaf = aNode;
   
   // find leftmost leaf
   nsCOMPtr<nsIDOMNode> child;
   nsresult res = NS_OK;
   child = GetLeftmostChild(aNode);
   while (child && (!IsEditable(child) || !nsEditorUtils::IsLeafNode(child)))
   {
     nsCOMPtr<nsIDOMNode> tmp;
     res = GetNextHTMLNode(child, address_of(tmp));
     NS_ENSURE_SUCCESS(res, res);
     NS_ENSURE_TRUE(tmp, NS_ERROR_FAILURE);
   
     // only accept nodes that are descendants of aNode
     if (nsEditorUtils::IsDescendantOf(tmp, aNode))
       child = tmp;
     else
     {
       child = nsnull;  // this will abort the loop
     }
   }
   
   *aOutFirstLeaf = child;
   -------------------------------------------------------------------------
   Potentially buggy differences:
1| *aOutFirstLeaf = aNode;
>                   -----
2| *aOutLastLeaf = nsnull;
>                  ------
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\editor\libeditor\html\nshtmleditor.cpp 4928:2 -> 4954:12
   -------------------------------------------------------------------------
   NS_ENSURE_TRUE(aOutLastLeaf && aNode, NS_ERROR_NULL_POINTER);
   
   // init out parms
   *aOutLastLeaf = nsnull;
   
   // find rightmost leaf
   nsCOMPtr<nsIDOMNode> child;
   nsresult res = NS_OK;
   child = GetRightmostChild(aNode, PR_FALSE);
   while (child && (!IsEditable(child) || !nsEditorUtils::IsLeafNode(child)))
   {
     nsCOMPtr<nsIDOMNode> tmp;
     res = GetPriorHTMLNode(child, address_of(tmp));
     NS_ENSURE_SUCCESS(res, res);
     NS_ENSURE_TRUE(tmp, NS_ERROR_FAILURE);
   
     // only accept nodes that are descendants of aNode
     if (nsEditorUtils::IsDescendantOf(tmp, aNode))
       child = tmp;
     else
     {
       child = nsnull;
     }
   }
   
   *aOutLastLeaf = child;
   return res;
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 14: 2 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.603 | CED: 1 | FED: 4 (4.0%) | SZ: 101 | XF: F | XP: F | D: 207
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\editor\libeditor\html\nshtmleditrules.cpp 3726:6 -> 3743:6
   -------------------------------------------------------------------------
   if (!curList || (sibling && sibling != curList))
   {
     nsAutoString listTag;
     nsEditor::GetTagString(curParent,listTag);
     ToLowerCase(listTag);
     // create a new nested list of correct type
     res = SplitAsNeeded(&listTag, address_of(curParent), &offset);
     NS_ENSURE_SUCCESS(res, res);
     res = mHTMLEditor->CreateNode(listTag, curParent, offset, getter_AddRefs(curList));
     NS_ENSURE_SUCCESS(res, res);
     // curList is now the correct thing to put curNode in
     // remember our new block for postprocessing
     mNewBlock = curList;
   }
   // tuck the node into the end of the active list
   PRUint32 listLen;
   res = mHTMLEditor->GetLengthOfDOMNode(curList, listLen);
   NS_ENSURE_SUCCESS(res, res);
   -------------------------------------------------------------------------
   Potentially buggy differences:
1|   mNewBlock = curList;
>    ^^^^^^^^^ ^ ^^^^^^^
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\editor\libeditor\html\nshtmleditrules.cpp 3950:8 -> 3964:29
   -------------------------------------------------------------------------
   if (!curList || (sibling && sibling != curList) )
   {
     nsAutoString listTag;
     nsEditor::GetTagString(curParent,listTag);
     ToLowerCase(listTag);
     // create a new nested list of correct type
     res = SplitAsNeeded(&listTag, address_of(curParent), &offset);
     NS_ENSURE_SUCCESS(res, res);
     res = mHTMLEditor->CreateNode(listTag, curParent, offset, getter_AddRefs(curList));
     NS_ENSURE_SUCCESS(res, res);
   }
   res = mHTMLEditor->MoveNode(listitem, curList, -1);
   NS_ENSURE_SUCCESS(res, res);
   // remember we indented this li
   indentedLI = listitem;
   -------------------------------------------------------------------------

 Pair b.) TxtSim: 0.706 | CED: 1 | FED: 4 (4.0%) | SZ: 101 | XF: F | XP: F | D: 27
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\editor\libeditor\html\nshtmleditrules.cpp 3907:6 -> 3923:6
   -------------------------------------------------------------------------
   if (!curList || (sibling && sibling != curList) )
   {
     nsAutoString listTag;
     nsEditor::GetTagString(curParent,listTag);
     ToLowerCase(listTag);
     // create a new nested list of correct type
     res = SplitAsNeeded(&listTag, address_of(curParent), &offset);
     NS_ENSURE_SUCCESS(res, res);
     res = mHTMLEditor->CreateNode(listTag, curParent, offset, getter_AddRefs(curList));
     NS_ENSURE_SUCCESS(res, res);
     // curList is now the correct thing to put curNode in
     // remember our new block for postprocessing
     mNewBlock = curList;
   }
   // tuck the node into the end of the active list
   res = mHTMLEditor->MoveNode(curNode, curList, -1);
   NS_ENSURE_SUCCESS(res, res);
   -------------------------------------------------------------------------
   Potentially buggy differences:
1|   mNewBlock = curList;
>    ^^^^^^^^^ ^ ^^^^^^^
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\editor\libeditor\html\nshtmleditrules.cpp 3950:8 -> 3964:29
   -------------------------------------------------------------------------
   if (!curList || (sibling && sibling != curList) )
   {
     nsAutoString listTag;
     nsEditor::GetTagString(curParent,listTag);
     ToLowerCase(listTag);
     // create a new nested list of correct type
     res = SplitAsNeeded(&listTag, address_of(curParent), &offset);
     NS_ENSURE_SUCCESS(res, res);
     res = mHTMLEditor->CreateNode(listTag, curParent, offset, getter_AddRefs(curList));
     NS_ENSURE_SUCCESS(res, res);
   }
   res = mHTMLEditor->MoveNode(listitem, curList, -1);
   NS_ENSURE_SUCCESS(res, res);
   // remember we indented this li
   indentedLI = listitem;
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 15: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.553 | CED: 3 | FED: 18 (7.8%) | SZ: 232 | XF: T | XP: F | D: inf
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\content\base\src\nscopysupport.cpp 379:24 -> 440:34
   -------------------------------------------------------------------------
   nsCOMPtr<nsIDOMRange> range;
   nsCOMPtr<nsIDOMNode> commonParent;
   PRInt32 count = 0;
   
   rv = aSel->GetRangeCount(&count);
   NS_ENSURE_SUCCESS(rv, rv);
   
   // if selection is uninitialized return
   if (!count)
     return NS_ERROR_FAILURE;
   
   // we'll just use the common parent of the first range.  Implicit assumption
   // here that multi-range selections are table cell selections, in which case
   // the common parent is somewhere in the table and we don't really care where.
   rv = aSel->GetRangeAt(0, getter_AddRefs(range));
   NS_ENSURE_SUCCESS(rv, rv);
   if (!range)
     return NS_ERROR_NULL_POINTER;
   range->GetCommonAncestorContainer(getter_AddRefs(commonParent));
   
   for (nsCOMPtr<nsIContent> selContent(do_QueryInterface(commonParent));
        selContent;
        selContent = selContent->GetParent())
   {
     // checking for selection inside a plaintext form widget
   
     if (!selContent->IsHTML()) {
       continue;
     }
   
     nsIAtom *atom = selContent->Tag();
   
     if (atom == nsGkAtoms::input ||
         atom == nsGkAtoms::textarea)
     {
       *aIsPlainTextContext = PR_TRUE;
       break;
     }
   
     if (atom == nsGkAtoms::body)
     {
       // check for moz prewrap style on body.  If it's there we are
       // in a plaintext editor.  This is pretty cheezy but I haven't
       // found a good way to tell if we are in a plaintext editor.
       nsCOMPtr<nsIDOMElement> bodyElem = do_QueryInterface(selContent);
       nsAutoString wsVal;
       rv = bodyElem->GetAttribute(NS_LITERAL_STRING("style"), wsVal);
       if (NS_SUCCEEDED(rv) && (kNotFound != wsVal.Find(NS_LITERAL_STRING("pre-wrap"))))
       {
         *aIsPlainTextContext = PR_TRUE;
         break;
       }
     }
   }
   
   // also consider ourselves in a text widget if we can't find an html
   // document. Note that XHTML is not counted as HTML here, because we can't
   // copy it properly (all the copy code for non-plaintext assumes using HTML
   // serializers and parsers is OK, and those mess up XHTML).
   nsCOMPtr<nsIHTMLDocument> htmlDoc = do_QueryInterface(aDoc);
   if (!(htmlDoc && aDoc->IsHTML()))
     *aIsPlainTextContext = PR_TRUE;
   -------------------------------------------------------------------------
   Potentially buggy differences:
1| rv = aSel->GetRangeCount(&count);
>  ^^ ^
2| nsresult rv = aSelection->GetRangeCount(&count);
>           ^^ ^ ^^^^^^^^^^

1|   if (!selContent->IsHTML()) {
>    ^^ ^^^^^^^^^^^^^^^^^^^^^^^ ^
1|     continue;
>      ^^^^^^^^
1|   }
>    ^
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\content\base\src\nsdocumentencoder.cpp 1240:24 -> 1291:27
   -------------------------------------------------------------------------
   nsCOMPtr<nsIDOMRange> range;
   nsCOMPtr<nsIDOMNode> commonParent;
   PRInt32 count = 0;
   
   nsresult rv = aSelection->GetRangeCount(&count);
   NS_ENSURE_SUCCESS(rv, rv);
   
   // if selection is uninitialized return
   if (!count)
     return NS_ERROR_FAILURE;
   
   // we'll just use the common parent of the first range.  Implicit assumption
   // here that multi-range selections are table cell selections, in which case
   // the common parent is somewhere in the table and we don't really care where.
   rv = aSelection->GetRangeAt(0, getter_AddRefs(range));
   NS_ENSURE_SUCCESS(rv, rv);
   if (!range)
     return NS_ERROR_NULL_POINTER;
   range->GetCommonAncestorContainer(getter_AddRefs(commonParent));
   
   for (nsCOMPtr<nsIContent> selContent(do_QueryInterface(commonParent));
        selContent;
        selContent = selContent->GetParent())
   {
     // checking for selection inside a plaintext form widget
     nsIAtom *atom = selContent->Tag();
     if (atom == nsGkAtoms::input ||
         atom == nsGkAtoms::textarea)
     {
       mIsTextWidget = PR_TRUE;
       break;
     }
     else if (atom == nsGkAtoms::body)
     {
       // check for moz prewrap style on body.  If it's there we are
       // in a plaintext editor.  This is pretty cheezy but I haven't
       // found a good way to tell if we are in a plaintext editor.
       nsCOMPtr<nsIDOMElement> bodyElem = do_QueryInterface(selContent);
       nsAutoString wsVal;
       rv = bodyElem->GetAttribute(NS_LITERAL_STRING("style"), wsVal);
       if (NS_SUCCEEDED(rv) && (kNotFound != wsVal.Find(NS_LITERAL_STRING("pre-wrap"))))
       {
         mIsTextWidget = PR_TRUE;
         break;
       }
     }
   }
   
   // also consider ourselves in a text widget if we can't find an html document
   nsCOMPtr<nsIHTMLDocument> htmlDoc = do_QueryInterface(mDocument);
   if (!(htmlDoc && mDocument->IsHTML()))
     mIsTextWidget = PR_TRUE;
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 16: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.606 | CED: 1 | FED: 2 (3.6%) | SZ: 56 | XF: F | XP: F | D: 3
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\layout\xul\base\src\tree\src\nstreebodyframe.cpp 4061:30 -> 4077:0
   -------------------------------------------------------------------------
   nsTreeBodyFrame::ScrollByLines(PRInt32 aNumLines)
   {
     if (!mView)
       return NS_OK;
   
     PRInt32 newIndex = mTopRowIndex + aNumLines;
     if (newIndex < 0)
       newIndex = 0;
     else {
       PRInt32 lastPageTopRow = mRowCount - mPageLength;
       if (newIndex > lastPageTopRow)
         newIndex = lastPageTopRow;
     }
     ScrollToRow(newIndex);
   
     return NS_OK;
   }
   -------------------------------------------------------------------------
   Potentially buggy differences:
2|   PRInt32 newIndex = mTopRowIndex + aNumPages * mPageLength;
>                                                ^ ^^^^^^^^^^^
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\layout\xul\base\src\tree\src\nstreebodyframe.cpp 4080:30 -> 4096:0
   -------------------------------------------------------------------------
   nsTreeBodyFrame::ScrollByPages(PRInt32 aNumPages)
   {
     if (!mView)
       return NS_OK;
   
     PRInt32 newIndex = mTopRowIndex + aNumPages * mPageLength;
     if (newIndex < 0)
       newIndex = 0;
     else {
       PRInt32 lastPageTopRow = mRowCount - mPageLength;
       if (newIndex > lastPageTopRow)
         newIndex = lastPageTopRow;
     }
     ScrollToRow(newIndex);
   
     return NS_OK;
   }
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 17: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.514 | CED: 1 | FED: 6 (7.7%) | SZ: 78 | XF: T | XP: F | D: inf
   -------------------------------------------------------------------------
   c:\comm-central\mailnews\import\oexpress\nsoesettings.cpp 574:8 -> 596:74
   -------------------------------------------------------------------------
   if (!localFoldersServer)
   {
     // If Local Folders does not exist already, create it
   
     if (NS_FAILED(pMgr->CreateLocalMailAccount())) {
       IMPORT_LOG0("*** Failed to create Local Folders!\n");
       return PR_FALSE;
     }
   
     pMgr->GetLocalFoldersServer(getter_AddRefs(localFoldersServer));
   }
   
   // now get the account for this server
   nsCOMPtr<nsIMsgAccount> localFoldersAccount;
   pMgr->FindAccountForServer(localFoldersServer, getter_AddRefs(localFoldersAccount));
   if (localFoldersAccount)
   {
     nsCString localFoldersAcctKey;
     localFoldersAccount->GetKey(localFoldersAcctKey);
     pop3Server->SetDeferredToAccount(localFoldersAcctKey);
   }
   
   pBytesTemp = nsOERegUtil::GetValueBytes(hKey, "POP3 Skip Account");
   -------------------------------------------------------------------------
   Potentially buggy differences:
2|     if (NS_FAILED(rv)) {
>      ^^ ^^^^^^^^^^^^^
   -------------------------------------------------------------------------
   c:\comm-central\mailnews\import\outlook\src\nsoutlooksettings.cpp 371:12 -> 393:12
   -------------------------------------------------------------------------
   if (!localFoldersServer)
   {
       // XXX: We may need to move this local folder creation code to the generic nsImportSettings code
       // if the other import modules end up needing to do this too.
       // if Local Folders does not exist already, create it
       rv = pMgr->CreateLocalMailAccount();
       if (NS_FAILED(rv)) {
           IMPORT_LOG0( "*** Failed to create Local Folders!\n");
           return PR_FALSE;
       }
       pMgr->GetLocalFoldersServer(getter_AddRefs(localFoldersServer));
   }
   
   // now get the account for this server
   nsCOMPtr<nsIMsgAccount> localFoldersAccount;
   pMgr->FindAccountForServer(localFoldersServer, getter_AddRefs(localFoldersAccount));
   if (localFoldersAccount)
   {
     nsCString localFoldersAcctKey;
     localFoldersAccount->GetKey(localFoldersAcctKey);
     pop3Server->SetDeferredToAccount(localFoldersAcctKey);
     pop3Server->SetDeferGetNewMail(PR_TRUE);
   }
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 18: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.745 | CED: 1 | FED: 5 (1.3%) | SZ: 392 | XF: F | XP: F | D: 448
   -------------------------------------------------------------------------
   c:\comm-central\mailnews\base\src\nsmsgdbview.cpp 4862:28 -> 4946:18
   -------------------------------------------------------------------------
   nsCOMPtr <nsIMsgDatabase> hdrDB;
   EntryInfo1.folder->GetMsgDatabase(getter_AddRefs(hdrDB));
   comparisonContext.db = hdrDB.get();
   switch (fieldType)
   {
     case kCollationKey:
       rv = GetCollationKey(msgHdr, m_sortType, &EntryInfo1.key, &EntryInfo1.dword, colHandler);
       NS_ASSERTION(NS_SUCCEEDED(rv),"failed to create collation key");
       break;
     case kU32:
       if (m_sortType == nsMsgViewSortType::byId)
         EntryInfo1.dword = EntryInfo1.id;
       else
         GetLongField(msgHdr, m_sortType, &EntryInfo1.dword, colHandler);
       break;
     default:
       return highIndex;
   }
   while (highIndex > lowIndex)
   {
     nsMsgViewIndex tryIndex = (lowIndex + highIndex) / 2;
     // need to adjust tryIndex if it's not a thread.
     while (m_levels[tryIndex] && tryIndex)
       tryIndex--;
   
     if (tryIndex < lowIndex)
     {
       NS_ERROR("try index shouldn't be less than low index");
       break;
     }
     EntryInfo2.id = m_keys[tryIndex];
     GetFolderForViewIndex(tryIndex, &EntryInfo2.folder);
     EntryInfo2.folder->Release();
   
     nsCOMPtr <nsIMsgDBHdr> tryHdr;
     nsCOMPtr <nsIMsgDatabase> db;
     // ### this should get the db from the folder...
     GetDBForViewIndex(tryIndex, getter_AddRefs(db));
     if (db)
       rv = db->GetMsgHdrForKey(EntryInfo2.id, getter_AddRefs(tryHdr));
     if (!tryHdr)
       break;
     if (tryHdr == msgHdr)
     {
       NS_WARNING("didn't expect header to already be in view");
       highIndex = tryIndex;
       break;
     }
     if (fieldType == kCollationKey)
     {
       PR_FREEIF(EntryInfo2.key);
       rv = GetCollationKey(tryHdr, m_sortType, &EntryInfo2.key, &EntryInfo2.dword, colHandler);
       NS_ASSERTION(NS_SUCCEEDED(rv),"failed to create collation key");
       retStatus = FnSortIdKeyPtr(&pValue1, &pValue2, &comparisonContext);
     }
     else if (fieldType == kU32)
     {
       if (m_sortType == nsMsgViewSortType::byId)
         EntryInfo2.dword = EntryInfo2.id;
       else
         GetLongField(tryHdr, m_sortType, &EntryInfo2.dword, colHandler);
       retStatus = FnSortIdUint32(&pValue1, &pValue2, &comparisonContext);
     }
     if (retStatus == 0)
     {
       highIndex = tryIndex;
       break;
     }
   
     if (retStatus < 0)
     {
       highIndex = tryIndex;
       // we already made sure tryIndex was at a thread at the top of the loop.
     }
     else
     {
       lowIndex = tryIndex + 1;
       while (lowIndex < GetSize() && m_levels[lowIndex])
         lowIndex++;
     }
   }
   
   PR_Free(EntryInfo1.key);
   PR_Free(EntryInfo2.key);
   return highIndex;
   -------------------------------------------------------------------------
   Potentially buggy differences:
1|     NS_WARNING("didn't expect header to already be in view");
>      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   -------------------------------------------------------------------------
   c:\comm-central\mailnews\base\src\nsmsgdbview.cpp 5394:23 -> 5489:2
   -------------------------------------------------------------------------
   comparisonContext.db = hdrDB.get();
   switch (fieldType)
   {
     case kCollationKey:
       rv = GetCollationKey(msgHdr, m_sortType, &EntryInfo1.key, &EntryInfo1.dword, colHandler);
       NS_ASSERTION(NS_SUCCEEDED(rv),"failed to create collation key");
       break;
     case kU32:
       if (m_sortType == nsMsgViewSortType::byId)
         EntryInfo1.dword = EntryInfo1.id;
       else
         GetLongField(msgHdr, m_sortType, &EntryInfo1.dword, colHandler);
       break;
     default:
       return highIndex;
   }
   while (highIndex > lowIndex)
   {
     nsMsgViewIndex tryIndex = (lowIndex + highIndex) / 2;
     // need to adjust tryIndex if it's not a thread.
     while (m_levels[tryIndex] && tryIndex)
       tryIndex--;
   
     if (tryIndex < lowIndex)
     {
       NS_ERROR("try index shouldn't be less than low index");
       break;
     }
     EntryInfo2.id = m_keys[tryIndex];
     GetFolderForViewIndex(tryIndex, &EntryInfo2.folder);
     EntryInfo2.folder->Release();
   
     nsCOMPtr<nsIMsgDBHdr> tryHdr;
     nsCOMPtr<nsIMsgDatabase> db;
     // ### this should get the db from the folder...
     GetDBForViewIndex(tryIndex, getter_AddRefs(db));
     if (db)
       rv = db->GetMsgHdrForKey(EntryInfo2.id, getter_AddRefs(tryHdr));
     if (!tryHdr)
       break;
     if (tryHdr == msgHdr)
     {
       highIndex = tryIndex;
       break;
     }
     if (fieldType == kCollationKey)
     {
       PR_FREEIF(EntryInfo2.key);
       rv = GetCollationKey(tryHdr, m_sortType, &EntryInfo2.key, &EntryInfo2.dword, colHandler);
       NS_ASSERTION(NS_SUCCEEDED(rv),"failed to create collation key");
       retStatus = FnSortIdKeyPtr(&pValue1, &pValue2, &comparisonContext);
     }
     else if (fieldType == kU32)
     {
       if (m_sortType == nsMsgViewSortType::byId)
         EntryInfo2.dword = EntryInfo2.id;
       else
         GetLongField(tryHdr, m_sortType, &EntryInfo2.dword, colHandler);
       retStatus = FnSortIdUint32(&pValue1, &pValue2, &comparisonContext);
     }
     if (retStatus == 0)
     {
       highIndex = tryIndex;
       break;
     }
   
     if (retStatus < 0)
     {
       highIndex = tryIndex;
       // we already made sure tryIndex was at a thread at the top of the loop.
     }
     else
     {
       lowIndex = tryIndex + 1;
       while (lowIndex < GetSize() && m_levels[lowIndex])
         lowIndex++;
     }
   }
   
   nsCOMPtr<nsIMsgDBHdr> resultHdr;
   GetMsgHdrForViewIndex(highIndex, getter_AddRefs(resultHdr));
   
   if (resultHdr != msgHdr)
   {
     NS_WARNING("didn't find hdr");
     highIndex = FindHdr(msgHdr);
   fdef DEBUG_David_Bienvenu
     if (highIndex != nsMsgViewIndex_None)
     {
       NS_WARNING("but find hdr did");
       printf("level of found hdr = %d\n", m_levels[highIndex]);
       ValidateSort();
     }
   ndif
     return highIndex;
   }
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 19: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.550 | CED: 1 | FED: 6 (3.4%) | SZ: 179 | XF: T | XP: F | D: inf
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\jpeg\jcapimin.c 32:6 -> 76:26
   -------------------------------------------------------------------------
   int i;
   
   /* Guard against version mismatches between library and caller. */
   cinfo->mem = NULL;        /* so jpeg_destroy knows mem mgr not called */
   if (version != JPEG_LIB_VERSION)
     ERREXIT2(cinfo, JERR_BAD_LIB_VERSION, JPEG_LIB_VERSION, version);
   if (structsize != SIZEOF(struct jpeg_compress_struct))
     ERREXIT2(cinfo, JERR_BAD_STRUCT_SIZE,
          (int) SIZEOF(struct jpeg_compress_struct), (int) structsize);
   
   /* For debugging purposes, we zero the whole master structure.
    * But the application has already set the err pointer, and may have set
    * client_data, so we have to save and restore those fields.
    * Note: if application hasn't set client_data, tools like Purify may
    * complain here.
    */
   {
     struct jpeg_error_mgr * err = cinfo->err;
     void * client_data = cinfo->client_data; /* ignore Purify complaint here */
     MEMZERO(cinfo, SIZEOF(struct jpeg_compress_struct));
     cinfo->err = err;
     cinfo->client_data = client_data;
   }
   cinfo->is_decompressor = FALSE;
   
   /* Initialize a memory manager instance for this object */
   jinit_memory_mgr((j_common_ptr) cinfo);
   
   /* Zero out pointers to permanent structures. */
   cinfo->progress = NULL;
   cinfo->dest = NULL;
   
   cinfo->comp_info = NULL;
   
   for (i = 0; i < NUM_QUANT_TBLS; i++)
     cinfo->quant_tbl_ptrs[i] = NULL;
   
   for (i = 0; i < NUM_HUFF_TBLS; i++) {
     cinfo->dc_huff_tbl_ptrs[i] = NULL;
     cinfo->ac_huff_tbl_ptrs[i] = NULL;
   }
   
   cinfo->script_space = NULL;
   
   cinfo->input_gamma = 1.0;    /* in case application forgets */
   -------------------------------------------------------------------------
   Potentially buggy differences:
1| cinfo->comp_info = NULL;
>  ^^^^^^^^^^^^^^^^ ^ ^^^^
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\jpeg\jdapimin.c 123:13 -> 170:36
   -------------------------------------------------------------------------
   cinfo->mem = NULL;        /* so jpeg_destroy knows mem mgr not called */
   if (version != JPEG_LIB_VERSION)
     ERREXIT2(cinfo, JERR_BAD_LIB_VERSION, JPEG_LIB_VERSION, version);
   if (structsize != SIZEOF(struct jpeg_decompress_struct))
     ERREXIT2(cinfo, JERR_BAD_STRUCT_SIZE,
          (int) SIZEOF(struct jpeg_decompress_struct), (int) structsize);
   
   /* For debugging purposes, we zero the whole master structure.
    * But the application has already set the err pointer, and may have set
    * client_data, so we have to save and restore those fields.
    * Note: if application hasn't set client_data, tools like Purify may
    * complain here.
    */
   {
     struct jpeg_error_mgr * err = cinfo->err;
     void * client_data = cinfo->client_data; /* ignore Purify complaint here */
     MEMZERO(cinfo, SIZEOF(struct jpeg_decompress_struct));
     cinfo->err = err;
     cinfo->client_data = client_data;
   }
   cinfo->is_decompressor = TRUE;
   
   /* Initialize a memory manager instance for this object */
   jinit_memory_mgr((j_common_ptr) cinfo);
   
   /* Zero out pointers to permanent structures. */
   cinfo->progress = NULL;
   cinfo->src = NULL;
   
   for (i = 0; i < NUM_QUANT_TBLS; i++)
     cinfo->quant_tbl_ptrs[i] = NULL;
   
   for (i = 0; i < NUM_HUFF_TBLS; i++) {
     cinfo->dc_huff_tbl_ptrs[i] = NULL;
     cinfo->ac_huff_tbl_ptrs[i] = NULL;
   }
   
   /* Initialize marker processor so application can override methods
    * for COM, APPn markers before calling jpeg_read_header.
    */
   cinfo->marker_list = NULL;
   jinit_marker_reader(cinfo);
   
   /* And initialize the overall input controller. */
   jinit_input_controller(cinfo);
   
   /* OK, I'm ready */
   cinfo->global_state = DSTATE_START;
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 20: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.610 | CED: 1 | FED: 1 (1.9%) | SZ: 53 | XF: T | XP: F | D: inf
   -------------------------------------------------------------------------
   c:\comm-central\mailnews\import\src\nsimportaddressbooks.cpp 528:15 -> 539:0
   -------------------------------------------------------------------------
   nsAutoString str;
   if (pSuccess) {
     pSuccess->GetData(str);
         str.Append(success);
         pSuccess->SetData(success);
   }
   if (pError) {
     pError->GetData(str);
         str.Append(error);
         pError->SetData(error);
   }
   }
   -------------------------------------------------------------------------
   Potentially buggy differences:
1|       pSuccess->SetData(success);
>                          -------
2|     pSuccess->SetData(str);
>                        ---
   -------------------------------------------------------------------------
   c:\comm-central\mailnews\import\src\nsimportmail.cpp 648:17 -> 659:0
   -------------------------------------------------------------------------
   nsAutoString str;
   if (pSuccess) {
       pSuccess->GetData(str);
       str.Append(success);
       pSuccess->SetData(str);
   }
   if (pError) {
       pError->GetData(str);
       str.Append(error);
       pError->SetData(str);
   }
   }
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 21: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.590 | CED: 1 | FED: 11 (8.5%) | SZ: 130 | XF: F | XP: F | D: 163
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\security\manager\ssl\src\nsnsscertificatedb.cpp 596:9 -> 628:74
   -------------------------------------------------------------------------
   bool alert_and_skip = false;
   
   if (!node->cert) {
     continue;
   }
   
   if (CERT_VerifyCert(certdb, node->cert,
       PR_TRUE, certusage, now, ctx, NULL) != SECSuccess) {
     alert_and_skip = true;
   }
   
   CERTCertificateList *certChain = nsnull;
   CERTCertificateListCleaner chainCleaner(certChain);
   
   if (!alert_and_skip) {
     certChain = CERT_CertChainFromCert(node->cert, certusage, PR_FALSE);
     if (!certChain) {
       alert_and_skip = true;
     }
   }
   
   if (alert_and_skip) {
     nsCOMPtr<nsIX509Cert> certToShow = new nsNSSCertificate(node->cert);
     DisplayCertificateAlert(ctx, "NotImportingUnverifiedCert", certToShow);
     continue;
   }
   
   /*
    * CertChain returns an array of SECItems, import expects an array of
    * SECItem pointers. Create the SECItem Pointers from the array of
    * SECItems.
    */
   rawArray = (SECItem **) PORT_Alloc(certChain->len * sizeof(SECItem *));
   -------------------------------------------------------------------------
   Potentially buggy differences:
1| if (!node->cert) {
>      ^^^^^^^^^^^^ ^
1|   continue;
>    ^^^^^^^^
1| }
>  ^
1| if (CERT_VerifyCert(certdb, node->cert,
>  ^^ ^
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\security\manager\ssl\src\nsnsscertificatedb.cpp 791:9 -> 822:4
   -------------------------------------------------------------------------
   bool alert_and_skip = false;
   
   if (CERT_VerifyCert(CERT_GetDefaultCertDB(), node->cert,
       PR_TRUE, certUsageVerifyCA, now, ctx, NULL) != SECSuccess) {
     alert_and_skip = true;
   }
   
   CERTCertificateList *certChain = nsnull;
   CERTCertificateListCleaner chainCleaner(certChain);
   
   if (!alert_and_skip) {
     certChain = CERT_CertChainFromCert(node->cert, certUsageAnyCA, PR_FALSE);
     if (!certChain) {
       alert_and_skip = true;
     }
   }
   
   if (alert_and_skip) {
     nsCOMPtr<nsIX509Cert> certToShow = new nsNSSCertificate(node->cert);
     DisplayCertificateAlert(ctx, "NotImportingUnverifiedCert", certToShow);
     continue;
   }
   
   /*
    * CertChain returns an array of SECItems, import expects an array of
    * SECItem pointers. Create the SECItem Pointers from the array of
    * SECItems.
    */
   rawArray = (SECItem **) PORT_Alloc(certChain->len * sizeof(SECItem *));
   if (!rawArray) {
     continue;
   }
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 22: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.613 | CED: 2 | FED: 5 (2.4%) | SZ: 207 | XF: T | XP: F | D: inf
   -------------------------------------------------------------------------
   c:\comm-central\directory\c-sdk\ldap\libraries\libldap\add.c 123:1 -> 161:17
   -------------------------------------------------------------------------
   if ( !NSLDAPI_VALID_NONEMPTY_LDAPMOD_ARRAY( attrs )
       || msgidp == NULL ) {
       lderr = LDAP_PARAM_ERROR;
       LDAP_SET_LDERRNO( ld, lderr, NULL, NULL );
       return( lderr );
   }
   
   if ( dn == NULL ) {
       dn = "";
   }
   
   LDAP_MUTEX_LOCK( ld, LDAP_MSGID_LOCK );
   *msgidp = ++ld->ld_msgid;
   LDAP_MUTEX_UNLOCK( ld, LDAP_MSGID_LOCK );
   
   /* see if we should add to the cache */
   if ( ld->ld_cache_on && ld->ld_cache_add != NULL ) {
       LDAP_MUTEX_LOCK( ld, LDAP_CACHE_LOCK );
       if ( (rc = (ld->ld_cache_add)( ld, *msgidp, LDAP_REQ_ADD, dn,
           attrs )) != 0 ) {
           *msgidp = rc;
           LDAP_MUTEX_UNLOCK( ld, LDAP_CACHE_LOCK );
           return( LDAP_SUCCESS );
       }
       LDAP_MUTEX_UNLOCK( ld, LDAP_CACHE_LOCK );
   }
   
   /* create a message to send */
   if (( lderr = nsldapi_alloc_ber_with_options( ld, &ber ))
       != LDAP_SUCCESS ) {
       return( lderr );
   }
   
   if ( ber_printf( ber, "{it{s{", *msgidp, LDAP_REQ_ADD, dn )
       == -1 ) {
       lderr = LDAP_ENCODING_ERROR;
       LDAP_SET_LDERRNO( ld, lderr, NULL, NULL );
       ber_free( ber, 1 );
       return( lderr );
   -------------------------------------------------------------------------
   Potentially buggy differences:
1|     || msgidp == NULL ) {
>      ^^ ^^^^^^ ^^ ^^^^

1|         LDAP_MUTEX_UNLOCK( ld, LDAP_CACHE_LOCK );
>          -----------------
2|         LDAP_MUTEX_LOCK( ld, LDAP_CACHE_LOCK );
>          ---------------
   -------------------------------------------------------------------------
   c:\comm-central\directory\c-sdk\ldap\libraries\libldap\modify.c 123:1 -> 159:17
   -------------------------------------------------------------------------
   if ( !NSLDAPI_VALID_NONEMPTY_LDAPMOD_ARRAY( mods )) {
       lderr = LDAP_PARAM_ERROR;
       LDAP_SET_LDERRNO( ld, lderr, NULL, NULL );
       return( lderr );
   }
   if ( dn == NULL ) {
       dn = "";
   }
   
   LDAP_MUTEX_LOCK( ld, LDAP_MSGID_LOCK );
   *msgidp = ++ld->ld_msgid;
   LDAP_MUTEX_UNLOCK( ld, LDAP_MSGID_LOCK );
   
   /* see if we should add to the cache */
   if ( ld->ld_cache_on && ld->ld_cache_modify != NULL ) {
       LDAP_MUTEX_LOCK( ld, LDAP_CACHE_LOCK );
       if ( (rc = (ld->ld_cache_modify)( ld, *msgidp, LDAP_REQ_MODIFY,
           dn, mods )) != 0 ) {
           *msgidp = rc;
           LDAP_MUTEX_LOCK( ld, LDAP_CACHE_LOCK );
           return( LDAP_SUCCESS );
       }
       LDAP_MUTEX_UNLOCK( ld, LDAP_CACHE_LOCK );
   }
   
   /* create a message to send */
   if (( lderr = nsldapi_alloc_ber_with_options( ld, &ber ))
       != LDAP_SUCCESS ) {
       return( lderr );
   }
   
   if ( ber_printf( ber, "{it{s{", *msgidp, LDAP_REQ_MODIFY, dn )
       == -1 ) {
       lderr = LDAP_ENCODING_ERROR;
       LDAP_SET_LDERRNO( ld, lderr, NULL, NULL );
       ber_free( ber, 1 );
       return( lderr );
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 23: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.878 | CED: 2 | FED: 6 (1.6%) | SZ: 376 | XF: T | XP: F | D: inf
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\jpeg\jcmaster.c 315:2 -> 377:51
   -------------------------------------------------------------------------
   if (cinfo->comps_in_scan == 1) {
   
     /* Noninterleaved (single-component) scan */
     compptr = cinfo->cur_comp_info[0];
   
     /* Overall image size in MCUs */
     cinfo->MCUs_per_row = compptr->width_in_blocks;
     cinfo->MCU_rows_in_scan = compptr->height_in_blocks;
   
     /* For noninterleaved scan, always one block per MCU */
     compptr->MCU_width = 1;
     compptr->MCU_height = 1;
     compptr->MCU_blocks = 1;
     compptr->MCU_sample_width = DCTSIZE;
     compptr->last_col_width = 1;
     /* For noninterleaved scans, it is convenient to define last_row_height
      * as the number of block rows present in the last iMCU row.
      */
     tmp = (int) (compptr->height_in_blocks % compptr->v_samp_factor);
     if (tmp == 0) tmp = compptr->v_samp_factor;
     compptr->last_row_height = tmp;
   
     /* Prepare array describing MCU composition */
     cinfo->blocks_in_MCU = 1;
     cinfo->MCU_membership[0] = 0;
   
   } else {
   
     /* Interleaved (multi-component) scan */
     if (cinfo->comps_in_scan <= 0 || cinfo->comps_in_scan > MAX_COMPS_IN_SCAN)
       ERREXIT2(cinfo, JERR_COMPONENT_COUNT, cinfo->comps_in_scan,
            MAX_COMPS_IN_SCAN);
   
     /* Overall image size in MCUs */
     cinfo->MCUs_per_row = (JDIMENSION)
       jdiv_round_up((long) cinfo->image_width,
             (long) (cinfo->max_h_samp_factor*DCTSIZE));
     cinfo->MCU_rows_in_scan = (JDIMENSION)
       jdiv_round_up((long) cinfo->image_height,
             (long) (cinfo->max_v_samp_factor*DCTSIZE));
   
     cinfo->blocks_in_MCU = 0;
   
     for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
       compptr = cinfo->cur_comp_info[ci];
       /* Sampling factors give # of blocks of component in each MCU */
       compptr->MCU_width = compptr->h_samp_factor;
       compptr->MCU_height = compptr->v_samp_factor;
       compptr->MCU_blocks = compptr->MCU_width * compptr->MCU_height;
       compptr->MCU_sample_width = compptr->MCU_width * DCTSIZE;
       /* Figure number of non-dummy blocks in last MCU column & row */
       tmp = (int) (compptr->width_in_blocks % compptr->MCU_width);
       if (tmp == 0) tmp = compptr->MCU_width;
       compptr->last_col_width = tmp;
       tmp = (int) (compptr->height_in_blocks % compptr->MCU_height);
       if (tmp == 0) tmp = compptr->MCU_height;
       compptr->last_row_height = tmp;
       /* Prepare array describing MCU composition */
       mcublks = compptr->MCU_blocks;
       if (cinfo->blocks_in_MCU + mcublks > C_MAX_BLOCKS_IN_MCU)
     ERREXIT(cinfo, JERR_BAD_MCU_SIZE);
       while (mcublks-- > 0) {
     cinfo->MCU_membership[cinfo->blocks_in_MCU++] = ci;
   -------------------------------------------------------------------------
   Potentially buggy differences:
1|   compptr->MCU_sample_width = DCTSIZE;
>                                -------
2|   compptr->MCU_sample_width = compptr->DCT_scaled_size;
>                                ------------------------

1|     compptr->MCU_sample_width = compptr->MCU_width * DCTSIZE;
>                                                       -------
2|     compptr->MCU_sample_width = compptr->MCU_width * compptr->DCT_scaled_size;
>                                                       ------------------------
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\jpeg\jdinput.c 128:2 -> 190:51
   -------------------------------------------------------------------------
   if (cinfo->comps_in_scan == 1) {
   
     /* Noninterleaved (single-component) scan */
     compptr = cinfo->cur_comp_info[0];
   
     /* Overall image size in MCUs */
     cinfo->MCUs_per_row = compptr->width_in_blocks;
     cinfo->MCU_rows_in_scan = compptr->height_in_blocks;
   
     /* For noninterleaved scan, always one block per MCU */
     compptr->MCU_width = 1;
     compptr->MCU_height = 1;
     compptr->MCU_blocks = 1;
     compptr->MCU_sample_width = compptr->DCT_scaled_size;
     compptr->last_col_width = 1;
     /* For noninterleaved scans, it is convenient to define last_row_height
      * as the number of block rows present in the last iMCU row.
      */
     tmp = (int) (compptr->height_in_blocks % compptr->v_samp_factor);
     if (tmp == 0) tmp = compptr->v_samp_factor;
     compptr->last_row_height = tmp;
   
     /* Prepare array describing MCU composition */
     cinfo->blocks_in_MCU = 1;
     cinfo->MCU_membership[0] = 0;
   
   } else {
   
     /* Interleaved (multi-component) scan */
     if (cinfo->comps_in_scan <= 0 || cinfo->comps_in_scan > MAX_COMPS_IN_SCAN)
       ERREXIT2(cinfo, JERR_COMPONENT_COUNT, cinfo->comps_in_scan,
            MAX_COMPS_IN_SCAN);
   
     /* Overall image size in MCUs */
     cinfo->MCUs_per_row = (JDIMENSION)
       jdiv_round_up((long) cinfo->image_width,
             (long) (cinfo->max_h_samp_factor*DCTSIZE));
     cinfo->MCU_rows_in_scan = (JDIMENSION)
       jdiv_round_up((long) cinfo->image_height,
             (long) (cinfo->max_v_samp_factor*DCTSIZE));
   
     cinfo->blocks_in_MCU = 0;
   
     for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
       compptr = cinfo->cur_comp_info[ci];
       /* Sampling factors give # of blocks of component in each MCU */
       compptr->MCU_width = compptr->h_samp_factor;
       compptr->MCU_height = compptr->v_samp_factor;
       compptr->MCU_blocks = compptr->MCU_width * compptr->MCU_height;
       compptr->MCU_sample_width = compptr->MCU_width * compptr->DCT_scaled_size;
       /* Figure number of non-dummy blocks in last MCU column & row */
       tmp = (int) (compptr->width_in_blocks % compptr->MCU_width);
       if (tmp == 0) tmp = compptr->MCU_width;
       compptr->last_col_width = tmp;
       tmp = (int) (compptr->height_in_blocks % compptr->MCU_height);
       if (tmp == 0) tmp = compptr->MCU_height;
       compptr->last_row_height = tmp;
       /* Prepare array describing MCU composition */
       mcublks = compptr->MCU_blocks;
       if (cinfo->blocks_in_MCU + mcublks > D_MAX_BLOCKS_IN_MCU)
     ERREXIT(cinfo, JERR_BAD_MCU_SIZE);
       while (mcublks-- > 0) {
     cinfo->MCU_membership[cinfo->blocks_in_MCU++] = ci;
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 24: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.508 | CED: 1 | FED: 2 (1.6%) | SZ: 123 | XF: F | XP: F | D: 486
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\layout\build\nslayoutmodule.cpp 169:0 -> 189:0
   -------------------------------------------------------------------------
   nsEditorControllerConstructor(nsISupports *aOuter, REFNSIID aIID,
                                               void **aResult)
   {
     nsresult rv;
     nsCOMPtr<nsIController> controller = do_CreateInstance("@mozilla.org/embedcomp/base-command-controller;1", &rv);
     if (NS_FAILED(rv)) return rv;
   
     nsCOMPtr<nsIControllerCommandTable> editorCommandTable = do_GetService(kEditorCommandTableCID, &rv);
     if (NS_FAILED(rv)) return rv;
   
     // this guy is a singleton, so make it immutable
     editorCommandTable->MakeImmutable();
   
     nsCOMPtr<nsIControllerContext> controllerContext = do_QueryInterface(controller, &rv);
     if (NS_FAILED(rv)) return rv;
   
     rv = controllerContext->Init(editorCommandTable);
     if (NS_FAILED(rv)) return rv;
   
     return controller->QueryInterface(aIID, aResult);
   }
   -------------------------------------------------------------------------
   Potentially buggy differences:
1|   rv = controllerContext->Init(editorCommandTable);
>    ^^ ^
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\layout\build\nslayoutmodule.cpp 675:0 -> 697:0
   -------------------------------------------------------------------------
   CreateWindowControllerWithSingletonCommandTable(nsISupports *aOuter,
                                         REFNSIID aIID, void **aResult)
   {
     nsresult rv;
     nsCOMPtr<nsIController> controller =
          do_CreateInstance("@mozilla.org/embedcomp/base-command-controller;1", &rv);
   
    if (NS_FAILED(rv)) return rv;
   
     nsCOMPtr<nsIControllerCommandTable> windowCommandTable = do_GetService(kWindowCommandTableCID, &rv);
     if (NS_FAILED(rv)) return rv;
   
     // this is a singleton; make it immutable
     windowCommandTable->MakeImmutable();
   
     nsCOMPtr<nsIControllerContext> controllerContext = do_QueryInterface(controller, &rv);
     if (NS_FAILED(rv)) return rv;
   
     controllerContext->Init(windowCommandTable);
     if (NS_FAILED(rv)) return rv;
   
     return controller->QueryInterface(aIID, aResult);
   }
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 25: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.579 | CED: 2 | FED: 14 (13.1%) | SZ: 107 | XF: F | XP: F | D: 2
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\accessible\src\base\nsaccutils.cpp 201:2 -> 219:2
   -------------------------------------------------------------------------
   for (PRInt32 index = indexOf; index >= 0; index--) {
     nsCOMPtr<nsIDOMXULElement> item;
     container->GetItemAtIndex(index, getter_AddRefs(item));
     nsCOMPtr<nsINode> itemNode(do_QueryInterface(item));
   
     nsAccessible* itemAcc = GetAccService()->GetAccessible(itemNode);
   
     if (itemAcc) {
       PRUint32 itemRole = Role(itemAcc);
       if (itemRole == nsIAccessibleRole::ROLE_SEPARATOR)
         break; // We reached the beginning of our group.
   
       PRUint32 itemState = State(itemAcc);
       if (!(itemState & nsIAccessibleStates::STATE_INVISIBLE)) {
         (*aSetSize)++;
         (*aPosInSet)++;
       }
     }
   }
   -------------------------------------------------------------------------
   Potentially buggy differences:
1| for (PRInt32 index = indexOf; index >= 0; index--) {
>                                ----- --         --
2| for (PRInt32 index = indexOf + 1; index < static_cast<PRInt32>(itemsCount);
>                               -          - --------------------------------
2|      index++) {
>       -------
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\accessible\src\base\nsaccutils.cpp 221:6 -> 239:0
   -------------------------------------------------------------------------
   for (PRInt32 index = indexOf + 1; index < static_cast<PRInt32>(itemsCount);
        index++) {
     nsCOMPtr<nsIDOMXULElement> item;
     container->GetItemAtIndex(index, getter_AddRefs(item));
     nsCOMPtr<nsINode> itemNode(do_QueryInterface(item));
   
     nsAccessible* itemAcc = GetAccService()->GetAccessible(itemNode);
   
     if (itemAcc) {
       PRUint32 itemRole = Role(itemAcc);
       if (itemRole == nsIAccessibleRole::ROLE_SEPARATOR)
         break; // We reached the end of our group.
   
       PRUint32 itemState = State(itemAcc);
       if (!(itemState & nsIAccessibleStates::STATE_INVISIBLE))
         (*aSetSize)++;
     }
   }
   }
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 26: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.783 | CED: 1 | FED: 9 (4.0%) | SZ: 226 | XF: T | XP: T | D: inf
   -------------------------------------------------------------------------
   c:\comm-central\mailnews\base\src\nsmsggroupthread.cpp 530:11 -> 595:13
   -------------------------------------------------------------------------
   nsresult rv=NS_OK;          // XXX or should this default to an error?
   mResultHdr = nsnull;
   if (mThreadParentKey == nsMsgKey_None)
   {
     rv = mThread->GetRootHdr(&mChildIndex, getter_AddRefs(mResultHdr));
     NS_ASSERTION(NS_SUCCEEDED(rv) && mResultHdr, "better be able to get root hdr");
     mChildIndex = 0; // since root can be anywhere, set mChildIndex to 0.
   }
   else if (!mDone)
   {
     PRUint32 numChildren;
     mThread->GetNumChildren(&numChildren);
   
     while (mChildIndex < (PRInt32) numChildren)
     {
       rv  = mThread->GetChildHdrAt(mChildIndex++, getter_AddRefs(mResultHdr));
       if (NS_SUCCEEDED(rv) && mResultHdr)
       {
         nsMsgKey parentKey;
         nsMsgKey curKey;
   
         if (mFilter && NS_FAILED(mFilter(mResultHdr, mClosure))) {
           mResultHdr = nsnull;
           continue;
         }
   
         mResultHdr->GetThreadParent(&parentKey);
         mResultHdr->GetMessageKey(&curKey);
         // if the parent is the same as the msg we're enumerating over,
         // or the parentKey isn't set, and we're iterating over the top
         // level message in the thread, then leave mResultHdr set to cur msg.
         if (parentKey == mThreadParentKey ||
           (parentKey == nsMsgKey_None
           && mThreadParentKey == mFirstMsgKey && curKey != mThreadParentKey))
           break;
         mResultHdr = nsnull;
       }
       else
         NS_ASSERTION(PR_FALSE, "better be able to get child");
     }
     if (!mResultHdr && mThreadParentKey == mFirstMsgKey && !mFoundChildren && numChildren > 1)
     {
   //      mThread->ReparentMsgsWithInvalidParent(numChildren, mThreadParentKey);
       }
     }
     if (!mResultHdr)
     {
       mDone = PR_TRUE;
       return NS_ERROR_FAILURE;
     }
     if (NS_FAILED(rv))
     {
       mDone = PR_TRUE;
       return rv;
     }
     else
       mNeedToPrefetch = PR_FALSE;
     mFoundChildren = PR_TRUE;
   
   #ifdef DEBUG_bienvenu1
       nsMsgKey debugMsgKey;
       mResultHdr->GetMessageKey(&debugMsgKey);
       printf("next for %ld = %ld\n", mThreadParentKey, debugMsgKey);
   #endif
   
       return rv;
   -------------------------------------------------------------------------
   Potentially buggy differences:
1|   {
>    -
1|     }
>      -
2|     mThread->ReparentMsgsWithInvalidParent(numChildren, mThreadParentKey);
>      --------------------------------------------------- -----------------
   -------------------------------------------------------------------------
   c:\comm-central\mailnews\db\msgdb\src\nsmsgthread.cpp 830:2 -> 882:30
   -------------------------------------------------------------------------
   if (mThreadParentKey == nsMsgKey_None)
   {
     rv = mThread->GetRootHdr(&mChildIndex, getter_AddRefs(mResultHdr));
     NS_ASSERTION(NS_SUCCEEDED(rv) && mResultHdr, "better be able to get root hdr");
     mChildIndex = 0; // since root can be anywhere, set mChildIndex to 0.
   }
   else if (!mDone)
   {
     PRUint32 numChildren;
     mThread->GetNumChildren(&numChildren);
   
     while (mChildIndex < (PRInt32) numChildren)
     {
       rv  = mThread->GetChildHdrAt(mChildIndex++, getter_AddRefs(mResultHdr));
       if (NS_SUCCEEDED(rv) && mResultHdr)
       {
         nsMsgKey parentKey;
         nsMsgKey curKey;
   
         if (mFilter && NS_FAILED(mFilter(mResultHdr, mClosure))) {
           mResultHdr = nsnull;
           continue;
         }
   
         mResultHdr->GetThreadParent(&parentKey);
         mResultHdr->GetMessageKey(&curKey);
         // if the parent is the same as the msg we're enumerating over,
         // or the parentKey isn't set, and we're iterating over the top
         // level message in the thread, then leave mResultHdr set to cur msg.
         if (parentKey == mThreadParentKey ||
           (parentKey == nsMsgKey_None
           && mThreadParentKey == mFirstMsgKey && curKey != mThreadParentKey))
           break;
         mResultHdr = nsnull;
       }
       else
         NS_ASSERTION(PR_FALSE, "better be able to get child");
     }
     if (!mResultHdr && mThreadParentKey == mFirstMsgKey && !mFoundChildren && numChildren > 1)
       mThread->ReparentMsgsWithInvalidParent(numChildren, mThreadParentKey);
   }
   if (!mResultHdr)
   {
     mDone = PR_TRUE;
     return NS_ERROR_FAILURE;
   }
   if (NS_FAILED(rv))
   {
     mDone = PR_TRUE;
     return rv;
   }
   else
     mNeedToPrefetch = PR_FALSE;
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 27: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.739 | CED: 1 | FED: 7 (12.3%) | SZ: 57 | XF: F | XP: F | D: 66
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\layout\forms\nstextcontrolframe.cpp 968:11 -> 979:2
   -------------------------------------------------------------------------
   *aResult = 0;
   
   nsCOMPtr<nsIDOMElement> rootElement;
   nsresult rv = GetRootNodeAndInitializeEditor(getter_AddRefs(rootElement));
   nsCOMPtr<nsIDOMNode> rootNode(do_QueryInterface(rootElement));
   
   NS_ENSURE_TRUE(rootNode, NS_ERROR_FAILURE);
   
   nsCOMPtr<nsIDOMNodeList> nodeList;
   
   rv = rootNode->GetChildNodes(getter_AddRefs(nodeList));
   NS_ENSURE_SUCCESS(rv, rv);
   -------------------------------------------------------------------------
   Potentially buggy differences:
2| nsresult rv = GetRootNodeAndInitializeEditor(getter_AddRefs(rootElement));
>                                                                          ^
2| NS_ENSURE_SUCCESS(rv, rv);
>  ^^^^^^^^^^^^^^^^^^^^^ ^^
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\layout\forms\nstextcontrolframe.cpp 1045:13 -> 1056:56
   -------------------------------------------------------------------------
   *aPosition = 0;
   
   nsCOMPtr<nsIDOMElement> rootElement;
   nsresult rv = GetRootNodeAndInitializeEditor(getter_AddRefs(rootElement));
   NS_ENSURE_SUCCESS(rv, rv);
   nsCOMPtr<nsIDOMNode> rootNode(do_QueryInterface(rootElement));
   
   NS_ENSURE_TRUE(rootNode, NS_ERROR_FAILURE);
   
   nsCOMPtr<nsIDOMNodeList> nodeList;
   
   rv = rootNode->GetChildNodes(getter_AddRefs(nodeList));
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 28: 2 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.554 | CED: 1 | FED: 11 (12.1%) | SZ: 91 | XF: T | XP: F | D: inf
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\accessible\src\base\nsariagridaccessible.cpp 946:34 -> 964:0
   -------------------------------------------------------------------------
   nsARIAGridCellAccessible::GetTable(nsIAccessibleTable **aTable)
   {
     NS_ENSURE_ARG_POINTER(aTable);
     *aTable = nsnull;
   
     nsCOMPtr<nsIAccessible> thisRow;
     GetParent(getter_AddRefs(thisRow));
     if (nsAccUtils::Role(thisRow) != nsIAccessibleRole::ROLE_ROW)
       return NS_OK;
   
     nsCOMPtr<nsIAccessible> table;
     thisRow->GetParent(getter_AddRefs(table));
     if (nsAccUtils::Role(table) != nsIAccessibleRole::ROLE_TABLE &&
         nsAccUtils::Role(table) != nsIAccessibleRole::ROLE_TREE_TABLE)
       return NS_OK;
   
     CallQueryInterface(table, aTable);
     return NS_OK;
   }
   -------------------------------------------------------------------------
   Potentially buggy differences:
1|   if (nsAccUtils::Role(table) != nsIAccessibleRole::ROLE_TABLE &&
>                                                                 ^^
1|       nsAccUtils::Role(table) != nsIAccessibleRole::ROLE_TREE_TABLE)
>        ^^^^^^^^^^^^^^^^^^^^^^^ ^^ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\accessible\src\xul\nsxullistboxaccessible.cpp 1044:2 -> 1061:14
   -------------------------------------------------------------------------
   NS_ENSURE_ARG_POINTER(aTable);
   *aTable = nsnull;
   
   if (IsDefunct())
     return NS_ERROR_FAILURE;
   
   nsCOMPtr<nsIAccessible> thisRow;
   GetParent(getter_AddRefs(thisRow));
   if (nsAccUtils::Role(thisRow) != nsIAccessibleRole::ROLE_ROW)
     return NS_OK;
   
   nsCOMPtr<nsIAccessible> table;
   thisRow->GetParent(getter_AddRefs(table));
   if (nsAccUtils::Role(table) != nsIAccessibleRole::ROLE_TABLE)
     return NS_OK;
   
   CallQueryInterface(table, aTable);
   return NS_OK;
   -------------------------------------------------------------------------

 Pair b.) TxtSim: 0.554 | CED: 1 | FED: 11 (12.1%) | SZ: 91 | XF: T | XP: T | D: inf
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\accessible\src\xul\nsxullistboxaccessible.cpp 1044:2 -> 1061:14
   -------------------------------------------------------------------------
   NS_ENSURE_ARG_POINTER(aTable);
   *aTable = nsnull;
   
   if (IsDefunct())
     return NS_ERROR_FAILURE;
   
   nsCOMPtr<nsIAccessible> thisRow;
   GetParent(getter_AddRefs(thisRow));
   if (nsAccUtils::Role(thisRow) != nsIAccessibleRole::ROLE_ROW)
     return NS_OK;
   
   nsCOMPtr<nsIAccessible> table;
   thisRow->GetParent(getter_AddRefs(table));
   if (nsAccUtils::Role(table) != nsIAccessibleRole::ROLE_TABLE)
     return NS_OK;
   
   CallQueryInterface(table, aTable);
   return NS_OK;
   -------------------------------------------------------------------------
   Potentially buggy differences:
2|   if (nsAccUtils::Role(table) != nsIAccessibleRole::ROLE_TABLE &&
>                                                                 ^^
2|       nsAccUtils::Role(table) != nsIAccessibleRole::ROLE_TREE_TABLE)
>        ^^^^^^^^^^^^^^^^^^^^^^^ ^^ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   -------------------------------------------------------------------------
   c:\mozilla-central\accessible\src\base\nsariagridaccessible.cpp 946:34 -> 964:0
   -------------------------------------------------------------------------
   nsARIAGridCellAccessible::GetTable(nsIAccessibleTable **aTable)
   {
     NS_ENSURE_ARG_POINTER(aTable);
     *aTable = nsnull;
   
     nsCOMPtr<nsIAccessible> thisRow;
     GetParent(getter_AddRefs(thisRow));
     if (nsAccUtils::Role(thisRow) != nsIAccessibleRole::ROLE_ROW)
       return NS_OK;
   
     nsCOMPtr<nsIAccessible> table;
     thisRow->GetParent(getter_AddRefs(table));
     if (nsAccUtils::Role(table) != nsIAccessibleRole::ROLE_TABLE &&
         nsAccUtils::Role(table) != nsIAccessibleRole::ROLE_TREE_TABLE)
       return NS_OK;
   
     CallQueryInterface(table, aTable);
     return NS_OK;
   }
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 29: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.637 | CED: 1 | FED: 3 (2.3%) | SZ: 133 | XF: F | XP: F | D: 12
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\content\html\document\src\nshtmldocument.cpp 3846:11 -> 3875:13
   -------------------------------------------------------------------------
   *_retval = PR_FALSE;
   
   // if editing is not on, bail
   if (!IsEditingOnAfterFlush())
     return NS_ERROR_FAILURE;
   
   // get command manager and dispatch command to our window if it's acceptable
   nsCOMPtr<nsICommandManager> cmdMgr;
   GetMidasCommandManager(getter_AddRefs(cmdMgr));
   if (!cmdMgr)
     return NS_ERROR_FAILURE;
   
   nsIDOMWindow *window = GetWindow();
   if (!window)
     return NS_ERROR_FAILURE;
   
   nsCAutoString cmdToDispatch, paramToCheck;
   PRBool dummy;
   if (!ConvertToMidasInternalCommand(commandID, commandID,
                                      cmdToDispatch, paramToCheck, dummy, dummy))
     return NS_ERROR_NOT_IMPLEMENTED;
   
   nsresult rv;
   nsCOMPtr<nsICommandParams> cmdParams = do_CreateInstance(
                                            NS_COMMAND_PARAMS_CONTRACTID, &rv);
   NS_ENSURE_SUCCESS(rv, rv);
   
   rv = cmdMgr->GetCommandState(cmdToDispatch.get(), window, cmdParams);
   if (NS_FAILED(rv))
     return rv;
   -------------------------------------------------------------------------
   Potentially buggy differences:
1| NS_ENSURE_SUCCESS(rv, rv);
>                    --- --
2| if (!cmdParams)
>      ----------
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\content\html\document\src\nshtmldocument.cpp 3887:2 -> 3918:13
   -------------------------------------------------------------------------
   NS_ENSURE_ARG_POINTER(_retval);
   *_retval = PR_FALSE;
   
   // if editing is not on, bail
   if (!IsEditingOnAfterFlush())
     return NS_ERROR_FAILURE;
   
   // get command manager and dispatch command to our window if it's acceptable
   nsCOMPtr<nsICommandManager> cmdMgr;
   GetMidasCommandManager(getter_AddRefs(cmdMgr));
   if (!cmdMgr)
     return NS_ERROR_FAILURE;
   
   nsIDOMWindow *window = GetWindow();
   if (!window)
     return NS_ERROR_FAILURE;
   
   nsCAutoString cmdToDispatch, paramToCheck;
   PRBool dummy, dummy2;
   if (!ConvertToMidasInternalCommand(commandID, commandID,
                                      cmdToDispatch, paramToCheck, dummy, dummy2))
     return NS_ERROR_NOT_IMPLEMENTED;
   
   nsresult rv;
   nsCOMPtr<nsICommandParams> cmdParams = do_CreateInstance(
                                            NS_COMMAND_PARAMS_CONTRACTID, &rv);
   if (!cmdParams)
     return NS_ERROR_OUT_OF_MEMORY;
   
   rv = cmdMgr->GetCommandState(cmdToDispatch.get(), window, cmdParams);
   if (NS_FAILED(rv))
     return rv;
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 30: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.898 | CED: 1 | FED: 8 (2.2%) | SZ: 366 | XF: T | XP: F | D: inf
   -------------------------------------------------------------------------
   c:\comm-central\mailnews\import\eudora\src\nseudoracompose.cpp 950:21 -> 1015:13
   -------------------------------------------------------------------------
   copy.m_writeOffset = 0;
   ReadFileState  state;
   state.pFile = pSrc;
   state.offset = 0;
   state.size = 0;
   
   pSrc->GetFileSize( &state.size);
   if (!state.size) {
     IMPORT_LOG0( "*** Error, unexpected zero file size for composed message\n");
     return( NS_ERROR_FAILURE);
   }
   
         nsresult rv = NS_NewLocalFileInputStream(getter_AddRefs(state.pInputStream), pSrc);
   
   if (NS_FAILED( rv)) {
     IMPORT_LOG0( "*** Error, unable to open composed message file\n");
     return( NS_ERROR_FAILURE);
   }
   
   PRUint32 written;
   rv = pDst->Write( fromLine.get(), fromLine.Length(), &written);
   
   // well, isn't this a hoot!
   // Read the headers from the new message, get the ones we like
   // and write out only the headers we want from the new message,
   // along with all of the other headers from the "old" message!
   if (NS_SUCCEEDED( rv))
     rv = FillMailBuffer( &state, copy);
   if (NS_SUCCEEDED( rv))
     rv = ReadHeaders( &state, copy, m_readHeaders);
   
   if (NS_SUCCEEDED( rv)) {
     rv = WriteHeaders( pDst, m_readHeaders);
   }
   
   // We need to go ahead and write out the rest of the copy buffer
   // so that the following will properly copy the rest of the body
   char lastChar = 0;
   
   rv = EscapeFromSpaceLine(pDst, copy.m_pBuffer + copy.m_writeOffset, copy.m_pBuffer+copy.m_bytesInBuf);
   if (copy.m_bytesInBuf)
     lastChar = copy.m_pBuffer[copy.m_bytesInBuf - 1];
   if (NS_SUCCEEDED(rv))
     copy.m_writeOffset = copy.m_bytesInBuf;
   
   while ((state.offset < state.size) && NS_SUCCEEDED( rv)) {
     rv = FillMailBuffer( &state, copy);
     if (NS_SUCCEEDED( rv)) {
       rv = EscapeFromSpaceLine(pDst, copy.m_pBuffer + copy.m_writeOffset, copy.m_pBuffer+copy.m_bytesInBuf);
       lastChar = copy.m_pBuffer[copy.m_bytesInBuf - 1];
       if (NS_SUCCEEDED( rv))
         copy.m_writeOffset = copy.m_bytesInBuf;
       else
         IMPORT_LOG0( "*** Error writing to destination mailbox\n");
     }
   }
   
   state.pInputStream->Close();
   
   if ((lastChar != 0x0A) && NS_SUCCEEDED( rv)) {
     rv = pDst->Write( "\x0D\x0A", 2, &written);
     if (written != 2)
       rv = NS_ERROR_FAILURE;
   }
   
   return( rv);
   -------------------------------------------------------------------------
   Potentially buggy differences:
1| state.pInputStream->Close();
>  ^^^^^^^^^^^^^^^^^^^^^^^^^^^
   -------------------------------------------------------------------------
   c:\comm-central\mailnews\import\outlook\src\nsoutlookcompose.cpp 852:20 -> 915:11
   -------------------------------------------------------------------------
   copy.m_bytesInBuf = 0;
   copy.m_writeOffset = 0;
   ReadFileState  state;
   state.pFile = pSrc;
   state.offset = 0;
   state.size = 0;
   pSrc->GetFileSize( &state.size);
   if (!state.size) {
     IMPORT_LOG0( "*** Error, unexpected zero file size for composed message\n");
     return( NS_ERROR_FAILURE);
   }
   
         nsresult rv = NS_NewLocalFileInputStream(getter_AddRefs(state.pInputStream), pSrc);
   if (NS_FAILED( rv)) {
     IMPORT_LOG0( "*** Error, unable to open composed message file\n");
     return( NS_ERROR_FAILURE);
   }
   
   PRUint32 written;
   rv = pDst->Write( fromLine.get(), fromLine.Length(), &written);
   
   // well, isn't this a hoot!
   // Read the headers from the new message, get the ones we like
   // and write out only the headers we want from the new message,
   // along with all of the other headers from the "old" message!
   if (NS_SUCCEEDED( rv))
     rv = FillMailBuffer( &state, copy);
   if (NS_SUCCEEDED( rv))
     rv = ReadHeaders( &state, copy, m_readHeaders);
   
   if (NS_SUCCEEDED( rv)) {
     rv = WriteHeaders( pDst, m_readHeaders);
   }
   
   // We need to go ahead and write out the rest of the copy buffer
   // so that the following will properly copy the rest of the body
   char lastChar = 0;
   
     rv = EscapeFromSpaceLine(pDst, copy.m_pBuffer + copy.m_writeOffset, copy.m_pBuffer+copy.m_bytesInBuf);
     if (copy.m_bytesInBuf)
       lastChar = copy.m_pBuffer[copy.m_bytesInBuf - 1];
     if (NS_SUCCEEDED(rv))
       copy.m_writeOffset = copy.m_bytesInBuf;
   
   while ((state.offset < state.size) && NS_SUCCEEDED( rv)) {
     rv = FillMailBuffer( &state, copy);
     if (NS_SUCCEEDED( rv)) {
       rv = EscapeFromSpaceLine(pDst, copy.m_pBuffer + copy.m_writeOffset, copy.m_pBuffer+copy.m_bytesInBuf);
       lastChar = copy.m_pBuffer[copy.m_bytesInBuf - 1];
       if (NS_SUCCEEDED( rv))
         copy.m_writeOffset = copy.m_bytesInBuf;
       else
         IMPORT_LOG0( "*** Error writing to destination mailbox\n");
     }
   }
   
   
   if ((lastChar != 0x0A) && NS_SUCCEEDED( rv)) {
     rv = pDst->Write( "\x0D\x0A", 2, &written);
     if (written != 2)
       rv = NS_ERROR_FAILURE;
   }
   
   return rv;
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 31: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.775 | CED: 1 | FED: 8 (5.9%) | SZ: 135 | XF: F | XP: F | D: 164
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\editor\libeditor\html\nshtmleditrules.cpp 3637:4 -> 3656:42
   -------------------------------------------------------------------------
   NS_ENSURE_SUCCESS(res, res);
   // make sure we can put a block here
   res = SplitAsNeeded(&quoteType, address_of(parent), &offset);
   NS_ENSURE_SUCCESS(res, res);
   res = mHTMLEditor->CreateNode(quoteType, parent, offset, getter_AddRefs(theBlock));
   NS_ENSURE_SUCCESS(res, res);
   // remember our new block for postprocessing
   mNewBlock = theBlock;
   RelativeChangeIndentationOfElementNode(theBlock, +1);
   // delete anything that was in the list of nodes
   for (PRInt32 j = arrayOfNodes.Count() - 1; j >= 0; --j)
   {
     nsCOMPtr<nsIDOMNode> curNode = arrayOfNodes[0];
     res = mHTMLEditor->DeleteNode(curNode);
     NS_ENSURE_SUCCESS(res, res);
     res = arrayOfNodes.RemoveObjectAt(0);
     NS_ENSURE_SUCCESS(res, res);
   }
   // put selection in new block
   res = aSelection->Collapse(theBlock,0);
   -------------------------------------------------------------------------
   Potentially buggy differences:
1| RelativeChangeIndentationOfElementNode(theBlock, +1);
>  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ^^^
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\editor\libeditor\html\nshtmleditrules.cpp 3820:4 -> 3841:14
   -------------------------------------------------------------------------
   NS_ENSURE_SUCCESS(res, res);
   // make sure we can put a block here
   res = SplitAsNeeded(&quoteType, address_of(parent), &offset);
   NS_ENSURE_SUCCESS(res, res);
   res = mHTMLEditor->CreateNode(quoteType, parent, offset, getter_AddRefs(theBlock));
   NS_ENSURE_SUCCESS(res, res);
   // remember our new block for postprocessing
   mNewBlock = theBlock;
   // delete anything that was in the list of nodes
   for (PRInt32 j = arrayOfNodes.Count() - 1; j >= 0; --j)
   {
     nsCOMPtr<nsIDOMNode> curNode = arrayOfNodes[0];
     res = mHTMLEditor->DeleteNode(curNode);
     NS_ENSURE_SUCCESS(res, res);
     res = arrayOfNodes.RemoveObjectAt(0);
     NS_ENSURE_SUCCESS(res, res);
   }
   // put selection in new block
   res = aSelection->Collapse(theBlock,0);
   selectionResetter.Abort();  // to prevent selection reseter from overriding us.
   *aHandled = PR_TRUE;
   return res;
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 32: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.677 | CED: 1 | FED: 4 (2.9%) | SZ: 138 | XF: T | XP: T | D: inf
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\content\canvas\src\webglcontextgl.cpp 186:24 -> 213:0
   -------------------------------------------------------------------------
   WebGLContext::BindBuffer(WebGLenum target, nsIWebGLBuffer *bobj)
   {
       WebGLuint bufname;
       WebGLBuffer* buf;
       PRBool isNull;
       if (!GetConcreteObjectAndGLName("bindBuffer", bobj, &buf, &bufname, &isNull))
           return NS_OK;
   
       if (target == LOCAL_GL_ARRAY_BUFFER) {
           mBoundArrayBuffer = buf;
       } else if (target == LOCAL_GL_ELEMENT_ARRAY_BUFFER) {
           mBoundElementArrayBuffer = buf;
       } else {
           return ErrorInvalidEnumInfo("BindBuffer: target", target);
       }
   
       if (!isNull) {
           if ((buf->Target() != LOCAL_GL_NONE) && (target != buf->Target()))
               return ErrorInvalidOperation("BindBuffer: buffer already bound to a different target");
           buf->SetTarget(target);
       }
   
       MakeContextCurrent();
   
       gl->fBindBuffer(target, bufname);
   
       return NS_OK;
   }
   -------------------------------------------------------------------------
   Potentially buggy differences:
1|         return NS_OK;
>                 -----
2|         return ErrorInvalidOperation("BindBuffer: invalid buffer");
>                 ---------------------------------------------------
   -------------------------------------------------------------------------
   c:\mozilla-central\content\canvas\src\webglcontextgl.cpp 188:24 -> 215:0
   -------------------------------------------------------------------------
   WebGLContext::BindBuffer(WebGLenum target, nsIWebGLBuffer *bobj)
   {
       WebGLuint bufname;
       WebGLBuffer* buf;
       PRBool isNull;
       if (!GetConcreteObjectAndGLName(bobj, &buf, &bufname, &isNull))
           return ErrorInvalidOperation("BindBuffer: invalid buffer");
   
       if (target == LOCAL_GL_ARRAY_BUFFER) {
           mBoundArrayBuffer = buf;
       } else if (target == LOCAL_GL_ELEMENT_ARRAY_BUFFER) {
           mBoundElementArrayBuffer = buf;
       } else {
           return ErrorInvalidEnum("BindBuffer: invalid target");
       }
   
       if (!isNull) {
           if ((buf->Target() != LOCAL_GL_NONE) && (target != buf->Target()))
               return ErrorInvalidOperation("BindBuffer: buffer already bound to a different target");
           buf->SetTarget(target);
       }
   
       MakeContextCurrent();
   
       gl->fBindBuffer(target, bufname);
   
       return NS_OK;
   }
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 33: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.636 | CED: 6 | FED: 44 (17.3%) | SZ: 254 | XF: F | XP: F | D: 28
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\js\src\jslock.cpp 708:4 -> 768:12
   -------------------------------------------------------------------------
   JS_ASSERT(title->ownercx != cx);
   JS_ASSERT(slot < scope->freeslot);
   
   /*
    * Avoid locking if called from the GC.  Also avoid locking an object
    * owning a sealed scope.  If neither of those special cases applies, try
    * to claim scope's flyweight lock from whatever context may have had it in
    * an earlier request.
    */
   if (CX_THREAD_IS_RUNNING_GC(cx) ||
       scope->sealed() ||
       (title->ownercx && ClaimTitle(title, cx))) {
       return obj->getSlot(slot);
   }
   
   def NSPR_LOCK
   tl = &title->lock;
   me = CX_THINLOCK_ID(cx);
   JS_ASSERT(CURRENT_THREAD_IS_ME(me));
   if (NativeCompareAndSwap(&tl->owner, 0, me)) {
       /*
        * Got the lock with one compare-and-swap.  Even so, someone else may
        * have mutated obj so it now has its own scope and lock, which would
        * require either a restart from the top of this routine, or a thin
        * lock release followed by fat lock acquisition.
        */
       if (scope == obj->scope()) {
           v = obj->getSlot(slot);
           if (!NativeCompareAndSwap(&tl->owner, me, 0)) {
               /* Assert that scope locks never revert to flyweight. */
               JS_ASSERT(title->ownercx != cx);
               LOGIT(title, '1');
               title->u.count = 1;
               js_UnlockObj(cx, obj);
           }
           return v;
       }
       if (!NativeCompareAndSwap(&tl->owner, me, 0))
           js_Dequeue(tl);
   }
   else if (Thin_RemoveWait(ReadWord(tl->owner)) == me) {
       return obj->getSlot(slot);
   }
   if
   
   js_LockObj(cx, obj);
   v = obj->getSlot(slot);
   
   /*
    * Test whether cx took ownership of obj's scope during js_LockObj.
    *
    * This does not mean that a given scope reverted to flyweight from "thin"
    * or "fat" -- it does mean that obj's map pointer changed due to another
    * thread setting a property, requiring obj to cease sharing a prototype
    * object's scope (whose lock was not flyweight, else we wouldn't be here
    * in the first place!).
    */
   title = &obj->scope()->title;
   if (title->ownercx != cx)
       js_UnlockTitle(cx, title);
   return v;
   -------------------------------------------------------------------------
   Potentially buggy differences:
2|     obj->lockedSetSlot(slot, v);
>      ^^^^^^^^^^^^^^^^^^^^^^^^ ^^

1|     return obj->getSlot(slot);
>             ^^^^^^^^^^^^^^^^^^

1|         v = obj->getSlot(slot);
>          - - -----------------
2|         obj->lockedSetSlot(slot, v);
>          ------------------------ -

2|     obj->lockedSetSlot(slot, v);
>      ^^^^^^^^^^^^^^^^^^^^^^^^ ^^

1|     return obj->getSlot(slot);
>             ^^^^^^^^^^^^^^^^^^

1| v = obj->getSlot(slot);
>  - - -----------------
2| obj->lockedSetSlot(slot, v);
>  ------------------------ -
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\js\src\jslock.cpp 796:4 -> 844:33
   -------------------------------------------------------------------------
   JS_ASSERT(title->ownercx != cx);
   JS_ASSERT(slot < scope->freeslot);
   
   /*
    * Avoid locking if called from the GC.  Also avoid locking an object
    * owning a sealed scope.  If neither of those special cases applies, try
    * to claim scope's flyweight lock from whatever context may have had it in
    * an earlier request.
    */
   if (CX_THREAD_IS_RUNNING_GC(cx) ||
       scope->sealed() ||
       (title->ownercx && ClaimTitle(title, cx))) {
       obj->lockedSetSlot(slot, v);
       return;
   }
   
   def NSPR_LOCK
   tl = &title->lock;
   me = CX_THINLOCK_ID(cx);
   JS_ASSERT(CURRENT_THREAD_IS_ME(me));
   if (NativeCompareAndSwap(&tl->owner, 0, me)) {
       if (scope == obj->scope()) {
           obj->lockedSetSlot(slot, v);
           if (!NativeCompareAndSwap(&tl->owner, me, 0)) {
               /* Assert that scope locks never revert to flyweight. */
               JS_ASSERT(title->ownercx != cx);
               LOGIT(title, '1');
               title->u.count = 1;
               js_UnlockObj(cx, obj);
           }
           return;
       }
       if (!NativeCompareAndSwap(&tl->owner, me, 0))
           js_Dequeue(tl);
   } else if (Thin_RemoveWait(ReadWord(tl->owner)) == me) {
       obj->lockedSetSlot(slot, v);
       return;
   }
   if
   
   js_LockObj(cx, obj);
   obj->lockedSetSlot(slot, v);
   
   /*
    * Same drill as above, in js_GetSlotThreadSafe.
    */
   title = &obj->scope()->title;
   if (title->ownercx != cx)
       js_UnlockTitle(cx, title);
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 34: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.654 | CED: 1 | FED: 8 (2.9%) | SZ: 280 | XF: F | XP: F | D: 5
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\js\src\xpconnect\src\xpcconvert.cpp 2290:18 -> 2351:26
   -------------------------------------------------------------------------
   char* bytes=nsnull;
   JSString* str;
   
   if(JSVAL_IS_VOID(s) || JSVAL_IS_NULL(s))
   {
       if(0 != count)
       {
           if(pErr)
               *pErr = NS_ERROR_XPC_NOT_ENOUGH_CHARS_IN_STRING;
           return JS_FALSE;
       }
       if(type.IsReference())
       {
           if(pErr)
               *pErr = NS_ERROR_XPC_BAD_CONVERT_JS_NULL_REF;
           return JS_FALSE;
       }
   
       if(useAllocator && 0 != capacity)
       {
           len = (capacity + 1) * sizeof(char);
           if(!(*((void**)d) = nsMemory::Alloc(len)))
               return JS_FALSE;
           return JS_TRUE;
       }
       // else ...
   
       *((char**)d) = nsnull;
       return JS_TRUE;
   }
   
   if(!(str = JS_ValueToString(cx, s))||
      !(bytes = JS_GetStringBytes(str)))
   {
       return JS_FALSE;
   }
   
   len = JS_GetStringLength(str);
   if(len > count)
   {
       if(pErr)
           *pErr = NS_ERROR_XPC_NOT_ENOUGH_CHARS_IN_STRING;
       return JS_FALSE;
   }
   
   if(len < capacity)
       len = capacity;
   
   if(useAllocator)
   {
       JSUint32 alloc_len = (len + 1) * sizeof(char);
       if(!(*((void**)d) = nsMemory::Alloc(alloc_len)))
       {
           return JS_FALSE;
       }
       memcpy(*((char**)d), bytes, count);
       (*((char**)d))[count] = 0;
   }
   else
       *((char**)d) = bytes;
   
   return JS_TRUE;
   -------------------------------------------------------------------------
   Potentially buggy differences:
1|     memcpy(*((char**)d), bytes, count);
>                                  ------
1|     (*((char**)d))[count] = 0;
>      --------
2|     memcpy(*((jschar**)d), chars, alloc_len);
>                                    ----------
2|     (*((jschar**)d))[count] = 0;
>      ----------
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\js\src\xpconnect\src\xpcconvert.cpp 2356:20 -> 2417:26
   -------------------------------------------------------------------------
   jschar* chars=nsnull;
   JSString* str;
   
   if(JSVAL_IS_VOID(s) || JSVAL_IS_NULL(s))
   {
       if(0 != count)
       {
           if(pErr)
               *pErr = NS_ERROR_XPC_NOT_ENOUGH_CHARS_IN_STRING;
           return JS_FALSE;
       }
       if(type.IsReference())
       {
           if(pErr)
               *pErr = NS_ERROR_XPC_BAD_CONVERT_JS_NULL_REF;
           return JS_FALSE;
       }
   
       if(useAllocator && 0 != capacity)
       {
           len = (capacity + 1) * sizeof(jschar);
           if(!(*((void**)d) = nsMemory::Alloc(len)))
               return JS_FALSE;
           return JS_TRUE;
       }
   
       // else ...
       *((jschar**)d) = nsnull;
       return JS_TRUE;
   }
   
   if(!(str = JS_ValueToString(cx, s))||
      !(chars = JS_GetStringChars(str)))
   {
       return JS_FALSE;
   }
   
   len = JS_GetStringLength(str);
   if(len > count)
   {
       if(pErr)
           *pErr = NS_ERROR_XPC_NOT_ENOUGH_CHARS_IN_STRING;
       return JS_FALSE;
   }
   if(len < capacity)
       len = capacity;
   
   if(useAllocator)
   {
       JSUint32 alloc_len = (len + 1) * sizeof(jschar);
       if(!(*((void**)d) = nsMemory::Alloc(alloc_len)))
       {
           // XXX should report error
           return JS_FALSE;
       }
       memcpy(*((jschar**)d), chars, alloc_len);
       (*((jschar**)d))[count] = 0;
   }
   else
       *((jschar**)d) = chars;
   
   return JS_TRUE;
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 35: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.644 | CED: 2 | FED: 4 (3.3%) | SZ: 122 | XF: F | XP: F | D: 168
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\editor\libeditor\html\nstableeditor.cpp 775:25 -> 801:45
   -------------------------------------------------------------------------
   nsCOMPtr<nsISelection> selection;
   nsCOMPtr<nsIDOMElement> table;
   nsCOMPtr<nsIDOMElement> cell;
   PRInt32 startRowIndex, startColIndex;
   
   
   nsresult res = GetCellContext(getter_AddRefs(selection),
                          getter_AddRefs(table),
                          getter_AddRefs(cell),
                          nsnull, nsnull,
                          &startRowIndex, &startColIndex);
   
   NS_ENSURE_SUCCESS(res, res);
   // Don't fail if we didn't find a table or cell
   NS_ENSURE_TRUE(table && cell, NS_EDITOR_ELEMENT_NOT_FOUND);
   
   nsAutoEditBatch beginBatching(this);
   // Prevent rules testing until we're done
   nsAutoRules beginRulesSniffing(this, kOpDeleteNode, nsIEditor::eNext);
   
   nsCOMPtr<nsIDOMElement> firstCell;
   nsCOMPtr<nsIDOMRange> range;
   res = GetFirstSelectedCell(getter_AddRefs(range), getter_AddRefs(firstCell));
   NS_ENSURE_SUCCESS(res, res);
   
   PRInt32 rangeCount;
   res = selection->GetRangeCount(&rangeCount);
   -------------------------------------------------------------------------
   Potentially buggy differences:
2| nsresult res;
>           ^^^

1| NS_ENSURE_TRUE(table && cell, NS_EDITOR_ELEMENT_NOT_FOUND);
>                 ^^^^^ ^^
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\editor\libeditor\html\nstableeditor.cpp 969:25 -> 994:2
   -------------------------------------------------------------------------
   nsCOMPtr<nsISelection> selection;
   nsCOMPtr<nsIDOMElement> table;
   nsCOMPtr<nsIDOMElement> cell;
   PRInt32 startRowIndex, startColIndex;
   nsresult res;
   res = GetCellContext(getter_AddRefs(selection),
                        getter_AddRefs(table),
                        getter_AddRefs(cell),
                        nsnull, nsnull,
                        &startRowIndex, &startColIndex);
   NS_ENSURE_SUCCESS(res, res);
   // Don't fail if no cell found
   NS_ENSURE_TRUE(cell, NS_EDITOR_ELEMENT_NOT_FOUND);
   
   
   nsAutoEditBatch beginBatching(this);
   // Prevent rules testing until we're done
   nsAutoRules beginRulesSniffing(this, kOpDeleteNode, nsIEditor::eNext);
   //Don't let Rules System change the selection
   nsAutoTxnsConserveSelection dontChangeSelection(this);
   
   
   nsCOMPtr<nsIDOMElement> firstCell;
   nsCOMPtr<nsIDOMRange> range;
   res = GetFirstSelectedCell(getter_AddRefs(range), getter_AddRefs(firstCell));
   NS_ENSURE_SUCCESS(res, res);
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 36: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.540 | CED: 1 | FED: 1 (1.1%) | SZ: 87 | XF: F | XP: F | D: 9
   -------------------------------------------------------------------------
   c:\mozilla-central\ipc\chromium\src\base\string_piece.cc 102:2 -> 115:2
   -------------------------------------------------------------------------
   if (length_ == 0 || s.length_ == 0)
     return npos;
   
   // Avoid the cost of BuildLookupTable() for a single-character search.
   if (s.length_ == 1)
     return find_first_of(s.ptr_[0], pos);
   
   bool lookup[UCHAR_MAX + 1] = { false };
   BuildLookupTable(s, lookup);
   for (size_type i = pos; i < length_; ++i) {
     if (lookup[static_cast<unsigned char>(ptr_[i])]) {
       return i;
     }
   }
   -------------------------------------------------------------------------
   Potentially buggy differences:
1|   return npos;
>           ----
2|   return 0;
>           -
   -------------------------------------------------------------------------
   c:\mozilla-central\ipc\chromium\src\base\string_piece.cc 124:2 -> 138:13
   -------------------------------------------------------------------------
   if (s.length_ == 0)
     return 0;
   
   // Avoid the cost of BuildLookupTable() for a single-character search.
   if (s.length_ == 1)
     return find_first_not_of(s.ptr_[0], pos);
   
   bool lookup[UCHAR_MAX + 1] = { false };
   BuildLookupTable(s, lookup);
   for (size_type i = pos; i < length_; ++i) {
     if (!lookup[static_cast<unsigned char>(ptr_[i])]) {
       return i;
     }
   }
   return npos;
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 37: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.584 | CED: 1 | FED: 1 (0.3%) | SZ: 359 | XF: F | XP: F | D: 8
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\js\src\xpconnect\src\xpcjsid.cpp 724:4 -> 789:39
   -------------------------------------------------------------------------
   if(!mDetails.IsValid())
       return NS_ERROR_XPC_BAD_CID;
   
   nsXPConnect* xpc = nsXPConnect::GetXPConnect();
   if(!xpc)
       return NS_ERROR_UNEXPECTED;
   
   nsAXPCNativeCallContext *ccxp = nsnull;
   xpc->GetCurrentNativeCallContext(&ccxp);
   if(!ccxp)
       return NS_ERROR_UNEXPECTED;
   
   PRUint32 argc;
   jsval * argv;
   jsval * vp;
   JSContext* cx;
   JSObject* obj;
   
   ccxp->GetJSContext(&cx);
   ccxp->GetArgc(&argc);
   ccxp->GetArgvPtr(&argv);
   ccxp->GetRetValPtr(&vp);
   
   nsCOMPtr<nsIXPConnectWrappedNative> wrapper;
   ccxp->GetCalleeWrapper(getter_AddRefs(wrapper));
   wrapper->GetJSObject(&obj);
   
   // Do the security check if necessary
   
   XPCContext* xpcc = XPCContext::GetXPCContext(cx);
   
   nsIXPCSecurityManager* sm;
   sm = xpcc->GetAppropriateSecurityManager(
                       nsIXPCSecurityManager::HOOK_CREATE_INSTANCE);
   if(sm && NS_FAILED(sm->CanCreateInstance(cx, mDetails.ID())))
   {
       NS_ASSERTION(JS_IsExceptionPending(cx),
                    "security manager vetoed CreateInstance without setting exception");
       return NS_OK;
   }
   
   // If an IID was passed in then use it
   const nsID* iid = GetIIDArg(argc, argv, cx);
   if (!iid)
       return NS_ERROR_XPC_BAD_IID;
   
   nsCOMPtr<nsIComponentManager> compMgr;
   nsresult rv = NS_GetComponentManager(getter_AddRefs(compMgr));
   if (NS_FAILED(rv))
       return NS_ERROR_UNEXPECTED;
   
   nsCOMPtr<nsISupports> inst;
   rv = compMgr->CreateInstance(mDetails.ID(), nsnull, *iid, getter_AddRefs(inst));
   NS_ASSERTION(NS_FAILED(rv) || inst, "component manager returned success, but instance is null!");
   
   if(NS_FAILED(rv) || !inst)
       return NS_ERROR_XPC_CI_RETURNED_FAILURE;
   
   JSObject* instJSObj;
   nsCOMPtr<nsIXPConnectJSObjectHolder> holder;
   rv = xpc->WrapNative(cx, obj, inst, *iid, getter_AddRefs(holder));
   if(NS_FAILED(rv) || !holder || NS_FAILED(holder->GetJSObject(&instJSObj)))
       return NS_ERROR_XPC_CANT_CREATE_WN;
   
   *vp = OBJECT_TO_JSVAL(instJSObj);
   ccxp->SetReturnValueWasSet(JS_TRUE);
   -------------------------------------------------------------------------
   Potentially buggy differences:
1|     return NS_ERROR_UNEXPECTED;
>             -------------------
2|     return rv;
>             --
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\js\src\xpconnect\src\xpcjsid.cpp 797:4 -> 862:16
   -------------------------------------------------------------------------
   if(!mDetails.IsValid())
       return NS_ERROR_XPC_BAD_CID;
   
   nsXPConnect* xpc = nsXPConnect::GetXPConnect();
   if(!xpc)
       return NS_ERROR_UNEXPECTED;
   
   nsAXPCNativeCallContext *ccxp = nsnull;
   xpc->GetCurrentNativeCallContext(&ccxp);
   if(!ccxp)
       return NS_ERROR_UNEXPECTED;
   
   PRUint32 argc;
   jsval * argv;
   jsval * vp;
   JSContext* cx;
   JSObject* obj;
   
   ccxp->GetJSContext(&cx);
   ccxp->GetArgc(&argc);
   ccxp->GetArgvPtr(&argv);
   ccxp->GetRetValPtr(&vp);
   
   nsCOMPtr<nsIXPConnectWrappedNative> wrapper;
   ccxp->GetCalleeWrapper(getter_AddRefs(wrapper));
   wrapper->GetJSObject(&obj);
   
   // Do the security check if necessary
   
   XPCContext* xpcc = XPCContext::GetXPCContext(cx);
   
   nsIXPCSecurityManager* sm;
   sm = xpcc->GetAppropriateSecurityManager(
                       nsIXPCSecurityManager::HOOK_GET_SERVICE);
   if(sm && NS_FAILED(sm->CanCreateInstance(cx, mDetails.ID())))
   {
       NS_ASSERTION(JS_IsExceptionPending(cx),
                    "security manager vetoed GetService without setting exception");
       return NS_OK;
   }
   
   // If an IID was passed in then use it
   const nsID* iid = GetIIDArg(argc, argv, cx);
   if (!iid)
       return NS_ERROR_XPC_BAD_IID;
   
   nsCOMPtr<nsIServiceManager> svcMgr;
   nsresult rv = NS_GetServiceManager(getter_AddRefs(svcMgr));
   if (NS_FAILED(rv))
       return rv;
   
   nsCOMPtr<nsISupports> srvc;
   rv = svcMgr->GetService(mDetails.ID(), *iid, getter_AddRefs(srvc));
   NS_ASSERTION(NS_FAILED(rv) || srvc, "service manager returned success, but service is null!");
   if(NS_FAILED(rv) || !srvc)
       return NS_ERROR_XPC_GS_RETURNED_FAILURE;
   
   JSObject* instJSObj;
   nsCOMPtr<nsIXPConnectJSObjectHolder> holder;
   rv = xpc->WrapNative(cx, obj, srvc, *iid, getter_AddRefs(holder));
   if(NS_FAILED(rv) || !holder || NS_FAILED(holder->GetJSObject(&instJSObj)))
       return NS_ERROR_XPC_CANT_CREATE_WN;
   
   *vp = OBJECT_TO_JSVAL(instJSObj);
   ccxp->SetReturnValueWasSet(JS_TRUE);
   return NS_OK;
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 38: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.638 | CED: 1 | FED: 8 (4.3%) | SZ: 188 | XF: T | XP: F | D: inf
   -------------------------------------------------------------------------
   c:\comm-central\mailnews\import\eudora\src\nseudoracompose.cpp 561:12 -> 593:12
   -------------------------------------------------------------------------
   nsCString urlStr;
   ImportAttachment * pAttach;
   
   for (PRInt32 i = 0; i < count; i++) {
     // nsMsgNewURL(&url, "file://C:/boxster.jpg");
     // a[i].orig_url = url;
   
     // NS_PRECONDITION( PR_FALSE, "Forced Break");
   
     pAttach = (ImportAttachment *) m_pAttachments->ElementAt( i);
                 a[i].tmp_file = do_QueryInterface(pAttach->pAttachment);
     urlStr.Adopt(0);
   
     nsCOMPtr <nsIURI> uri;
     nsresult rv = NS_NewFileURI(getter_AddRefs(uri), pAttach->pAttachment);
     NS_ENSURE_SUCCESS(rv, nsnull);
     uri->GetSpec(urlStr);
     if (urlStr.IsEmpty()) {
       CleanUpAttach( a, count);
       return( nsnull);
     }
     rv = m_pIOService->NewURI( urlStr, nsnull, nsnull, getter_AddRefs(a[i].orig_url));
     if (NS_FAILED( rv)) {
       CleanUpAttach( a, count);
       return( nsnull);
     }
   
     a[i].type = strdup( pAttach->mimeType);
     a[i].real_name = strdup( pAttach->description);
     a[i].encoding = strdup( ENCODING_BINARY);
   }
   
   return( a);
   -------------------------------------------------------------------------
   Potentially buggy differences:
1|               a[i].tmp_file = do_QueryInterface(pAttach->pAttachment);
>                                                                      ^
1|   urlStr.Adopt(0);
>    ^^^^^^^^^^^^^^^
   -------------------------------------------------------------------------
   c:\comm-central\mailnews\import\outlook\src\nsoutlookcompose.cpp 533:8 -> 567:12
   -------------------------------------------------------------------------
   memset(a, 0, sizeof(nsMsgAttachedFile) * (count + 1));
   
   nsresult rv;
   nsCString urlStr;
   OutlookAttachment * pAttach;
   
   for (PRInt32 i = 0; i < count; i++) {
     // nsMsgNewURL(&url, "file://C:/boxster.jpg");
     // a[i].orig_url = url;
   
     // NS_PRECONDITION( PR_FALSE, "Forced Break");
   
     pAttach = (OutlookAttachment *) m_pAttachments->ElementAt( i);
                 // should we clone here?
     a[i].tmp_file = pAttach->pAttachment;
     nsCOMPtr <nsIURI> uri;
     rv = NS_NewFileURI(getter_AddRefs(uri), pAttach->pAttachment);
     NS_ENSURE_SUCCESS(rv, nsnull);
     uri->GetSpec(urlStr);
     if (urlStr.IsEmpty()) {
       CleanUpAttach( a, count);
       return( nsnull);
     }
     rv = m_pIOService->NewURI( urlStr, nsnull, nsnull, getter_AddRefs(a[i].orig_url));
     if (NS_FAILED( rv)) {
       CleanUpAttach( a, count);
       return( nsnull);
     }
   
     a[i].type = strdup( pAttach->mimeType);
     a[i].real_name = strdup( pAttach->description);
     a[i].encoding = strdup( ENCODING_BINARY);
   }
   
   return( a);
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 39: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.558 | CED: 1 | FED: 8 (9.3%) | SZ: 86 | XF: F | XP: F | D: 114
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\accessible\src\xul\nsxullistboxaccessible.cpp 529:2 -> 553:44
   -------------------------------------------------------------------------
   NS_ENSURE_ARG_POINTER(aCount);
   *aCount = 0;
   
   nsCOMPtr<nsIDOMXULMultiSelectControlElement> control =
     do_QueryInterface(mContent);
   NS_ASSERTION(control,
                "Doesn't implement nsIDOMXULMultiSelectControlElement.");
   
   nsCOMPtr<nsIDOMNodeList> selectedItems;
   control->GetSelectedItems(getter_AddRefs(selectedItems));
   if (!selectedItems)
     return NS_OK;
   
   PRUint32 selectedItemsCount = 0;
   nsresult rv = selectedItems->GetLength(&selectedItemsCount);
   NS_ENSURE_SUCCESS(rv, rv);
   
   if (!selectedItemsCount)
     return NS_OK;
   
   PRInt32 columnCount = 0;
   rv = GetColumnCount(&columnCount);
   NS_ENSURE_SUCCESS(rv, rv);
   
   *aCount = selectedItemsCount * columnCount;
   -------------------------------------------------------------------------
   Potentially buggy differences:
1| if (!selectedItemsCount)
>  ^^ ^^^^^^^^^^^^^^^^^^^^^
1|   return NS_OK;
>    ^^^^^^ ^^^^^
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\accessible\src\xul\nsxullistboxaccessible.cpp 667:13 -> 690:2
   -------------------------------------------------------------------------
   *aNumCells = 0;
   NS_ENSURE_ARG_POINTER(aCells);
   *aCells = nsnull;
   
   if (IsDefunct())
     return NS_ERROR_FAILURE;
   
   nsCOMPtr<nsIDOMXULMultiSelectControlElement> control =
     do_QueryInterface(mContent);
   NS_ASSERTION(control,
                "Doesn't implement nsIDOMXULMultiSelectControlElement.");
   
   nsCOMPtr<nsIDOMNodeList> selectedItems;
   control->GetSelectedItems(getter_AddRefs(selectedItems));
   if (!selectedItems)
     return NS_OK;
   
   PRUint32 selectedItemsCount = 0;
   nsresult rv = selectedItems->GetLength(&selectedItemsCount);
   NS_ENSURE_SUCCESS(rv, rv);
   
   PRInt32 columnCount = 0;
   rv = GetColumnCount(&columnCount);
   NS_ENSURE_SUCCESS(rv, rv);
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 40: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.719 | CED: 1 | FED: 1 (1.0%) | SZ: 104 | XF: F | XP: F | D: 12
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\content\xslt\src\xpath\txrelationalexpr.cpp 63:19 -> 76:8
   -------------------------------------------------------------------------
   txNodeSet* nodeSet = static_cast<txNodeSet*>(aLeft);
   nsRefPtr<StringResult> strResult;
   rv = aContext->recycler()->getStringResult(getter_AddRefs(strResult));
   NS_ENSURE_SUCCESS(rv, PR_FALSE);
   
   PRInt32 i;
   for (i = 0; i < nodeSet->size(); ++i) {
       strResult->mValue.Truncate();
       txXPathNodeUtils::appendNodeValue(nodeSet->get(i),
                                         strResult->mValue);
       if (compareResults(aContext, strResult, aRight)) {
           return PR_TRUE;
       }
   }
   -------------------------------------------------------------------------
   Potentially buggy differences:
1| txNodeSet* nodeSet = static_cast<txNodeSet*>(aLeft);
>                                               -----
2| txNodeSet* nodeSet = static_cast<txNodeSet*>(aRight);
>                                               ------
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\content\xslt\src\xpath\txrelationalexpr.cpp 88:19 -> 101:8
   -------------------------------------------------------------------------
   txNodeSet* nodeSet = static_cast<txNodeSet*>(aRight);
   nsRefPtr<StringResult> strResult;
   rv = aContext->recycler()->getStringResult(getter_AddRefs(strResult));
   NS_ENSURE_SUCCESS(rv, PR_FALSE);
   
   PRInt32 i;
   for (i = 0; i < nodeSet->size(); ++i) {
       strResult->mValue.Truncate();
       txXPathNodeUtils::appendNodeValue(nodeSet->get(i),
                                         strResult->mValue);
       if (compareResults(aContext, aLeft, strResult)) {
           return PR_TRUE;
       }
   }
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 41: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.827 | CED: 1 | FED: 4 (2.1%) | SZ: 194 | XF: T | XP: F | D: inf
   -------------------------------------------------------------------------
   c:\comm-central\mailnews\import\eudora\src\nseudoracompose.cpp 263:12 -> 301:25
   -------------------------------------------------------------------------
   nsresult  rv = NS_OK;
   
   if (!m_pIOService) {
     IMPORT_LOG0( "Creating nsIOService\n");
   
     NS_WITH_PROXIED_SERVICE(nsIIOService, service, NS_IOSERVICE_CONTRACTID, NS_PROXY_TO_MAIN_THREAD, &rv);
     if (NS_FAILED(rv))
       return( rv);
     m_pIOService = service;
     NS_IF_ADDREF( m_pIOService);
   }
   
   NS_IF_RELEASE( m_pMsgFields);
   if (!m_pMsgSend) {
     rv = CallCreateInstance( kMsgSendCID, &m_pMsgSend);
     if (NS_SUCCEEDED( rv) && m_pMsgSend) {
       rv = NS_GetProxyForObject( NS_PROXY_TO_MAIN_THREAD, NS_GET_IID(nsIMsgSend),
                   m_pMsgSend, NS_PROXY_SYNC, (void**)&m_pSendProxy);
       if (NS_FAILED( rv)) {
         m_pSendProxy = nsnull;
         NS_RELEASE( m_pMsgSend);
         m_pMsgSend = nsnull;
       }
     }
   }
   if (!m_pListener && NS_SUCCEEDED( rv)) {
     rv = EudoraSendListener::CreateSendListener( &m_pListener);
   }
   
   if (NS_SUCCEEDED(rv) && m_pMsgSend) {
       rv = CallCreateInstance( kMsgCompFieldsCID, &m_pMsgFields);
     if (NS_SUCCEEDED(rv) && m_pMsgFields) {
       // IMPORT_LOG0( "nsOutlookCompose - CreateComponents succeeded\n");
       m_pMsgFields->SetForcePlainText( PR_FALSE);
       return( NS_OK);
     }
   }
   
   return NS_ERROR_FAILURE;
   -------------------------------------------------------------------------
   Potentially buggy differences:
1|       m_pMsgSend = nsnull;
>        ^^^^^^^^^^ ^ ^^^^^^
   -------------------------------------------------------------------------
   c:\comm-central\mailnews\import\outlook\src\nsoutlookcompose.cpp 237:11 -> 274:27
   -------------------------------------------------------------------------
   nsresult rv = NS_OK;
   
   if (!m_pIOService) {
     IMPORT_LOG0( "Creating nsIOService\n");
   
     NS_WITH_PROXIED_SERVICE(nsIIOService, service, NS_IOSERVICE_CONTRACTID, NS_PROXY_TO_MAIN_THREAD, &rv);
     if (NS_FAILED(rv))
       return( rv);
     m_pIOService = service;
     NS_IF_ADDREF( m_pIOService);
   }
   
   NS_IF_RELEASE( m_pMsgFields);
   if (!m_pMsgSend) {
     rv = CallCreateInstance( kMsgSendCID, &m_pMsgSend);
     if (NS_SUCCEEDED( rv) && m_pMsgSend) {
       rv = NS_GetProxyForObject( NS_PROXY_TO_MAIN_THREAD, NS_GET_IID(nsIMsgSend),
                   m_pMsgSend, NS_PROXY_SYNC, (void **)&m_pSendProxy);
       if (NS_FAILED( rv)) {
         m_pSendProxy = nsnull;
         NS_RELEASE( m_pMsgSend);
       }
     }
   }
   if (!m_pListener && NS_SUCCEEDED( rv)) {
     rv = OutlookSendListener::CreateSendListener( &m_pListener);
   }
   
   if (NS_SUCCEEDED(rv) && m_pMsgSend) {
       rv = CallCreateInstance( kMsgCompFieldsCID, &m_pMsgFields);
     if (NS_SUCCEEDED(rv) && m_pMsgFields) {
       // IMPORT_LOG0( "nsOutlookCompose - CreateComponents succeeded\n");
       m_pMsgFields->SetForcePlainText( PR_FALSE);
       return( NS_OK);
     }
   }
   
   return( NS_ERROR_FAILURE);
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 42: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.644 | CED: 1 | FED: 4 (5.2%) | SZ: 77 | XF: T | XP: T | D: inf
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\content\canvas\src\webglcontextgl.cpp 216:29 -> 235:0
   -------------------------------------------------------------------------
   WebGLContext::BindFramebuffer(WebGLenum target, nsIWebGLFramebuffer *fbobj)
   {
       WebGLuint framebuffername;
       PRBool isNull;
       WebGLFramebuffer *wfb;
   
       if (target != LOCAL_GL_FRAMEBUFFER)
           return ErrorInvalidOperation("BindFramebuffer: target must be GL_FRAMEBUFFER");
   
       if (!GetConcreteObjectAndGLName("bindFramebuffer", fbobj, &wfb, &framebuffername, &isNull))
           return NS_OK;
   
       MakeContextCurrent();
   
       gl->fBindFramebuffer(target, framebuffername);
   
       mBoundFramebuffer = wfb;
   
       return NS_OK;
   }
   -------------------------------------------------------------------------
   Potentially buggy differences:
1|         return NS_OK;
>                 -----
2|         return ErrorInvalidOperation("BindFramebuffer: invalid framebuffer");
>                 -------------------------------------------------------------
   -------------------------------------------------------------------------
   c:\mozilla-central\content\canvas\src\webglcontextgl.cpp 218:29 -> 237:0
   -------------------------------------------------------------------------
   WebGLContext::BindFramebuffer(WebGLenum target, nsIWebGLFramebuffer *fbobj)
   {
       WebGLuint framebuffername;
       PRBool isNull;
       WebGLFramebuffer *wfb;
   
       if (target != LOCAL_GL_FRAMEBUFFER)
           return ErrorInvalidOperation("BindFramebuffer: target must be GL_FRAMEBUFFER");
   
       if (!GetConcreteObjectAndGLName(fbobj, &wfb, &framebuffername, &isNull))
           return ErrorInvalidOperation("BindFramebuffer: invalid framebuffer");
   
       MakeContextCurrent();
   
       gl->fBindFramebuffer(target, framebuffername);
   
       mBoundFramebuffer = wfb;
   
       return NS_OK;
   }
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 43: 3 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.697 | CED: 1 | FED: 2 (2.4%) | SZ: 83 | XF: F | XP: F | D: 1117
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\js\src\jsxml.cpp 5330:19 -> 5343:65
   -------------------------------------------------------------------------
   ok = js_EnterLocalRootScope(cx);
   if (!ok)
       break;
   kidobj = js_GetXMLObject(cx, kid);
   if (kidobj) {
       ok = xml_comments_helper(cx, kidobj, kid, &v);
   } else {
       ok = JS_FALSE;
       v = JSVAL_NULL;
   }
   js_LeaveLocalRootScopeWithResult(cx, v);
   if (!ok)
       break;
   vxml = (JSXML *) JSVAL_TO_OBJECT(v)->getPrivate();
   -------------------------------------------------------------------------
   Potentially buggy differences:
1|     break;
>      -----
2|     return JS_FALSE;
>      ------ --------
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\js\src\jsxml.cpp 6460:19 -> 6473:65
   -------------------------------------------------------------------------
   ok = js_EnterLocalRootScope(cx);
   if (!ok)
       break;
   kidobj = js_GetXMLObject(cx, kid);
   if (kidobj) {
       ok = xml_text_helper(cx, kidobj, kid, &v);
   } else {
       ok = JS_FALSE;
       v = JSVAL_NULL;
   }
   js_LeaveLocalRootScopeWithResult(cx, v);
   if (!ok)
       return JS_FALSE;
   vxml = (JSXML *) JSVAL_TO_OBJECT(v)->getPrivate();
   -------------------------------------------------------------------------

 Pair b.) TxtSim: 0.594 | CED: 1 | FED: 2 (2.4%) | SZ: 84 | XF: F | XP: F | D: 993
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\js\src\jsxml.cpp 5454:19 -> 5467:65
   -------------------------------------------------------------------------
   ok = js_EnterLocalRootScope(cx);
   if (!ok)
       break;
   kidobj = js_GetXMLObject(cx, kid);
   if (kidobj) {
       ok = xml_elements_helper(cx, kidobj, kid, nameqn, &v);
   } else {
       ok = JS_FALSE;
       v = JSVAL_NULL;
   }
   js_LeaveLocalRootScopeWithResult(cx, v);
   if (!ok)
       break;
   vxml = (JSXML *) JSVAL_TO_OBJECT(v)->getPrivate();
   -------------------------------------------------------------------------
   Potentially buggy differences:
1|     break;
>      -----
2|     return JS_FALSE;
>      ------ --------
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\js\src\jsxml.cpp 6460:19 -> 6473:65
   -------------------------------------------------------------------------
   ok = js_EnterLocalRootScope(cx);
   if (!ok)
       break;
   kidobj = js_GetXMLObject(cx, kid);
   if (kidobj) {
       ok = xml_text_helper(cx, kidobj, kid, &v);
   } else {
       ok = JS_FALSE;
       v = JSVAL_NULL;
   }
   js_LeaveLocalRootScopeWithResult(cx, v);
   if (!ok)
       return JS_FALSE;
   vxml = (JSXML *) JSVAL_TO_OBJECT(v)->getPrivate();
   -------------------------------------------------------------------------

 Pair c.) TxtSim: 0.594 | CED: 1 | FED: 2 (2.4%) | SZ: 84 | XF: F | XP: F | D: 454
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\js\src\jsxml.cpp 5992:19 -> 6006:65
   -------------------------------------------------------------------------
   ok = js_EnterLocalRootScope(cx);
   if (!ok)
       break;
   kidobj = js_GetXMLObject(cx, kid);
   if (kidobj) {
       ok = xml_processingInstructions_helper(cx, kidobj, kid,
                                              nameqn, &v);
   } else {
       ok = JS_FALSE;
       v = JSVAL_NULL;
   }
   js_LeaveLocalRootScopeWithResult(cx, v);
   if (!ok)
       break;
   vxml = (JSXML *) JSVAL_TO_OBJECT(v)->getPrivate();
   -------------------------------------------------------------------------
   Potentially buggy differences:
1|     break;
>      -----
2|     return JS_FALSE;
>      ------ --------
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\js\src\jsxml.cpp 6460:19 -> 6473:65
   -------------------------------------------------------------------------
   ok = js_EnterLocalRootScope(cx);
   if (!ok)
       break;
   kidobj = js_GetXMLObject(cx, kid);
   if (kidobj) {
       ok = xml_text_helper(cx, kidobj, kid, &v);
   } else {
       ok = JS_FALSE;
       v = JSVAL_NULL;
   }
   js_LeaveLocalRootScopeWithResult(cx, v);
   if (!ok)
       return JS_FALSE;
   vxml = (JSXML *) JSVAL_TO_OBJECT(v)->getPrivate();
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 44: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.663 | CED: 3 | FED: 15 (5.5%) | SZ: 274 | XF: F | XP: F | D: 411
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\extensions\spellcheck\hunspell\src\affixmgr.cpp 1642:12 -> 1678:12
   -------------------------------------------------------------------------
   if ((rv) && !hu_mov_rule &&
       ((pfx && pfx->getCont() &&
           TESTAFF(pfx->getCont(), compoundforbidflag,
               pfx->getContLen())) ||
       (sfx && sfx->getCont() &&
           TESTAFF(sfx->getCont(), compoundforbidflag,
               sfx->getContLen())))) {
           rv = NULL;
   }
   
   // check compoundend flag in suffix and prefix
   if ((rv) && !checked_prefix && compoundend && !hu_mov_rule &&
       ((pfx && pfx->getCont() &&
           TESTAFF(pfx->getCont(), compoundend,
               pfx->getContLen())) ||
       (sfx && sfx->getCont() &&
           TESTAFF(sfx->getCont(), compoundend,
               sfx->getContLen())))) {
           rv = NULL;
   }
   
   // check compoundmiddle flag in suffix and prefix
   if ((rv) && !checked_prefix && (wordnum==0) && compoundmiddle && !hu_mov_rule &&
       ((pfx && pfx->getCont() &&
           TESTAFF(pfx->getCont(), compoundmiddle,
               pfx->getContLen())) ||
       (sfx && sfx->getCont() &&
           TESTAFF(sfx->getCont(), compoundmiddle,
               sfx->getContLen())))) {
           rv = NULL;
   }
   
   // check forbiddenwords
   if ((rv) && (rv->astr) && (TESTAFF(rv->astr, forbiddenword, rv->alen) ||
       (is_sug && nosuggest && TESTAFF(rv->astr, nosuggest, rv->alen)))) {
           return NULL;
       }
   -------------------------------------------------------------------------
   Potentially buggy differences:
1|         rv = NULL;
>          -- - ----
2|         continue;
>          --------

1|         rv = NULL;
>          -- - ----
2|         continue;
>          --------

1| if ((rv) && (rv->astr) && (TESTAFF(rv->astr, forbiddenword, rv->alen) ||
>                                                                        --
2| if ((rv) && (rv->astr) && TESTAFF(rv->astr, forbiddenword, rv->alen)) continue;
>                                                                      - --------
2| if ((rv) && (compoundroot) &&
>  -- ----- --
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\extensions\spellcheck\hunspell\src\affixmgr.cpp 2089:12 -> 2128:8
   -------------------------------------------------------------------------
   if ((rv) && !hu_mov_rule &&
       ((pfx && pfx->getCont() &&
           TESTAFF(pfx->getCont(), compoundforbidflag,
               pfx->getContLen())) ||
       (sfx && sfx->getCont() &&
           TESTAFF(sfx->getCont(), compoundforbidflag,
               sfx->getContLen())))) {
           continue;
   }
   
   // check compoundend flag in suffix and prefix
   if ((rv) && !checked_prefix && compoundend && !hu_mov_rule &&
       ((pfx && pfx->getCont() &&
           TESTAFF(pfx->getCont(), compoundend,
               pfx->getContLen())) ||
       (sfx && sfx->getCont() &&
           TESTAFF(sfx->getCont(), compoundend,
               sfx->getContLen())))) {
           continue;
   }
   
   // check compoundmiddle flag in suffix and prefix
   if ((rv) && !checked_prefix && (wordnum==0) && compoundmiddle && !hu_mov_rule &&
       ((pfx && pfx->getCont() &&
           TESTAFF(pfx->getCont(), compoundmiddle,
               pfx->getContLen())) ||
       (sfx && sfx->getCont() &&
           TESTAFF(sfx->getCont(), compoundmiddle,
               sfx->getContLen())))) {
           rv = NULL;
   }
   
   // check forbiddenwords
   if ((rv) && (rv->astr) && TESTAFF(rv->astr, forbiddenword, rv->alen)) continue;
   
   // increment word number, if the second root has a compoundroot flag
   if ((rv) && (compoundroot) &&
       (TESTAFF(rv->astr, compoundroot, rv->alen))) {
           wordnum++;
   }
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 45: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.563 | CED: 2 | FED: 32 (19.8%) | SZ: 162 | XF: F | XP: F | D: 33
   -------------------------------------------------------------------------
   c:\comm-central\mailnews\db\msgdb\src\nsmsgdatabase.cpp 121:2 -> 151:57
   -------------------------------------------------------------------------
   NS_ENSURE_ARG(aFolder);
   nsCOMPtr <nsILocalFile> folderPath;
   nsresult rv = aFolder->GetFilePath(getter_AddRefs(folderPath));
   NS_ENSURE_SUCCESS(rv, rv);
   nsMsgDatabase *cacheDB = (nsMsgDatabase *) nsMsgDatabase::FindInCache(aFolder);
   if (cacheDB)
   {
     // this db could have ended up in the folder cache w/o an m_folder pointer via
     // OpenMailDBFromFile. If so, take this chance to fix the folder.
     if (!cacheDB->m_folder)
       cacheDB->m_folder = aFolder;
     *_retval = cacheDB; // FindInCache already addRefed.
     // if m_thumb is set, someone is asynchronously opening the db. But our
     // caller wants to synchronously open it, so just do it.
     if (cacheDB->m_thumb)
       return cacheDB->Open(folderPath, PR_FALSE, aLeaveInvalidDB);
     return NS_OK;
   }
   
   nsCOMPtr <nsIMsgIncomingServer> incomingServer;
   rv = aFolder->GetServer(getter_AddRefs(incomingServer));
   NS_ENSURE_SUCCESS(rv, rv);
   nsCString localStoreType;
   incomingServer->GetLocalStoreType(localStoreType);
   nsCAutoString dbContractID(NS_MSGDB_CONTRACTID);
   dbContractID.Append(localStoreType.get());
   nsCOMPtr <nsIMsgDatabase> msgDB = do_CreateInstance(dbContractID.get(), &rv);
   NS_ENSURE_SUCCESS(rv, rv);
   
   // Don't try to create the database yet--let the createNewDB call do that.
   rv = msgDB->Open(folderPath, PR_FALSE, aLeaveInvalidDB);
   -------------------------------------------------------------------------
   Potentially buggy differences:
1| nsMsgDatabase *cacheDB = (nsMsgDatabase *) nsMsgDatabase::FindInCache(aFolder);
>  ^^^^^^^^^^^^^ ^^^^^^^^ ^ ^^^^^^^^^^^^^^ ^^ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

2| nsMsgDatabase *msgDatabase = static_cast<nsMsgDatabase *>(msgDB.get());
>  ^^^^^^^^^^^^^ ^^^^^^^^^^^^ ^ ^^^^^^^^^^^^^^^^^^^^^^^^^ ^^^^^^^^^^^^^^^
   -------------------------------------------------------------------------
   c:\comm-central\mailnews\db\msgdb\src\nsmsgdatabase.cpp 184:2 -> 216:33
   -------------------------------------------------------------------------
   NS_ENSURE_ARG(aFolder);
   nsMsgDatabase *cacheDB = (nsMsgDatabase *) nsMsgDatabase::FindInCache(aFolder);
   nsCOMPtr <nsILocalFile> folderPath;
   nsresult rv = aFolder->GetFilePath(getter_AddRefs(folderPath));
   NS_ENSURE_SUCCESS(rv, rv);
   if (cacheDB)
   {
     // this db could have ended up in the folder cache w/o an m_folder pointer via
     // OpenMailDBFromFile. If so, take this chance to fix the folder.
     if (!cacheDB->m_folder)
       cacheDB->m_folder = aFolder;
     *_retval = cacheDB; // FindInCache already addRefed.
     // We don't care if an other consumer is thumbing the store. In that
     // case, they'll both thumb the store.
     return NS_OK;
   }
   
   nsCOMPtr <nsIMsgIncomingServer> incomingServer;
   rv = aFolder->GetServer(getter_AddRefs(incomingServer));
   NS_ENSURE_SUCCESS(rv, rv);
   nsCString localStoreType;
   incomingServer->GetLocalStoreType(localStoreType);
   nsCAutoString dbContractID(NS_MSGDB_CONTRACTID);
   dbContractID.Append(localStoreType.get());
   nsCOMPtr <nsIMsgDatabase> msgDB = do_CreateInstance(dbContractID.get(), &rv);
   NS_ENSURE_SUCCESS(rv, rv);
   
   nsMsgDatabase *msgDatabase = static_cast<nsMsgDatabase *>(msgDB.get());
   rv = msgDatabase->OpenInternal(folderPath, PR_FALSE, aLeaveInvalidDB,
                                  PR_FALSE /* open asynchronously */);
   
   NS_ADDREF(*_retval = msgDB);
   msgDatabase->m_folder = aFolder;
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 46: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.698 | CED: 1 | FED: 9 (8.9%) | SZ: 101 | XF: F | XP: F | D: 146
   -------------------------------------------------------------------------
   c:\comm-central\mailnews\import\oexpress\nsoesettings.cpp 490:7 -> 507:20
   -------------------------------------------------------------------------
   else if (NS_SUCCEEDED(rv) && in) {
     // for an existing server we create another identity,
     //  TB lists under 'manage identities'
     nsCOMPtr<nsIMsgAccount> account;
     rv = pMgr->FindAccountForServer(in, getter_AddRefs( account));
     if (NS_SUCCEEDED( rv) && account) {
       IMPORT_LOG0("Created an identity and added to existing IMAP incoming server\n");
       // Fiddle with the identities
       in->GetAuthMethod(&authMethod);
       SetIdentities(pMgr, account, hKey, pUserName, authMethod, PR_FALSE);
       result = PR_TRUE;
       if (ppAccount)
         account->QueryInterface(NS_GET_IID(nsIMsgAccount),
                                  (void **)ppAccount);
     }
   }
   else
     result = PR_TRUE;
   -------------------------------------------------------------------------
   Potentially buggy differences:
2|   IMPORT_LOG2("Existing POP3 server named: %s, userName: %s\n",
>    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
2|               pServerName, pUserName);
>                ^^^^^^^^^^^^ ^^^^^^^^^^
   -------------------------------------------------------------------------
   c:\comm-central\mailnews\import\oexpress\nsoesettings.cpp 653:7 -> 671:20
   -------------------------------------------------------------------------
   else if (NS_SUCCEEDED(rv) && in) {
     IMPORT_LOG2("Existing POP3 server named: %s, userName: %s\n",
                 pServerName, pUserName);
     // for an existing server we create another identity,
     // TB listed under 'manage identities'
     nsCOMPtr<nsIMsgAccount>  account;
     rv = pMgr->FindAccountForServer(in, getter_AddRefs( account));
     if (NS_SUCCEEDED(rv) && account) {
       IMPORT_LOG0("Created identity and added to existing POP3 incoming server.\n");
       // Fiddle with the identities
       in->GetAuthMethod(&authMethod);
       SetIdentities(pMgr, account, hKey, pUserName, authMethod, PR_FALSE);
       result = PR_TRUE;
       if (ppAccount)
         account->QueryInterface(NS_GET_IID(nsIMsgAccount), (void **)ppAccount);
     }
   }
   else
     result = PR_TRUE;
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 47: 2 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.538 | CED: 1 | FED: 6 (9.0%) | SZ: 67 | XF: T | XP: F | D: inf
   -------------------------------------------------------------------------
   c:\comm-central\mailnews\import\eudora\src\nseudoraaddress.cpp 127:27 -> 141:2
   -------------------------------------------------------------------------
   nsCOMPtr<nsIInputStream> inputStream;
   nsresult rv = NS_NewLocalFileInputStream(getter_AddRefs(inputStream), pSrc);
   if (NS_FAILED(rv)) {
     IMPORT_LOG0( "*** Error opening address file for reading\n");
     return rv;
   }
   
   PRUint32 bytesLeft = 0;
   
   rv = inputStream->Available(&bytesLeft);
   if (NS_FAILED(rv)) {
     IMPORT_LOG0( "*** Error checking address file for eof\n");
     inputStream->Close();
     return rv;
   }
   -------------------------------------------------------------------------
   Potentially buggy differences:
1| if (NS_FAILED(rv)) {
>                     ^
1|   IMPORT_LOG0( "*** Error opening address file for reading\n");
>    ^^^^^^^^^^^^ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   -------------------------------------------------------------------------
   c:\comm-central\mailnews\import\eudora\src\nseudorawin32.cpp 231:29 -> 244:4
   -------------------------------------------------------------------------
   nsCOMPtr<nsIInputStream> inputStream;
   nsresult rv = NS_NewLocalFileInputStream(getter_AddRefs(inputStream), descMap);
   if (NS_FAILED(rv))
     return rv;
   
   PRUint32 bytesLeft = 0;
   
   rv = inputStream->Available(&bytesLeft);
   if (NS_FAILED(rv))
   {
     IMPORT_LOG0( "*** Error checking address file for eof\n");
     inputStream->Close();
     return rv;
   }
   -------------------------------------------------------------------------

 Pair b.) TxtSim: 0.524 | CED: 1 | FED: 6 (9.0%) | SZ: 67 | XF: T | XP: F | D: inf
   -------------------------------------------------------------------------
   c:\comm-central\mailnews\import\eudora\src\nseudorawin32.cpp 231:29 -> 244:4
   -------------------------------------------------------------------------
   nsCOMPtr<nsIInputStream> inputStream;
   nsresult rv = NS_NewLocalFileInputStream(getter_AddRefs(inputStream), descMap);
   if (NS_FAILED(rv))
     return rv;
   
   PRUint32 bytesLeft = 0;
   
   rv = inputStream->Available(&bytesLeft);
   if (NS_FAILED(rv))
   {
     IMPORT_LOG0( "*** Error checking address file for eof\n");
     inputStream->Close();
     return rv;
   }
   -------------------------------------------------------------------------
   Potentially buggy differences:
2| if (NS_FAILED(rv)) {
>                     ^
2|   IMPORT_LOG0( "*** Error opening address file for reading\n");
>    ^^^^^^^^^^^^ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   -------------------------------------------------------------------------
   c:\comm-central\mailnews\import\text\src\nstextaddress.cpp 192:27 -> 207:2
   -------------------------------------------------------------------------
   nsCOMPtr<nsIInputStream> inputStream;
   nsresult rv = NS_NewLocalFileInputStream(getter_AddRefs(inputStream), aSrc);
   if (NS_FAILED(rv)) {
     IMPORT_LOG0( "*** Error opening address file for reading\n");
     return rv;
   }
   
   PRInt32 rIndex = 0;
   PRUint32 bytesLeft = 0;
   
   rv = inputStream->Available(&bytesLeft);
   if (NS_FAILED(rv)) {
     IMPORT_LOG0( "*** Error checking address file for eof\n");
     inputStream->Close();
     return rv;
   }
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 48: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.629 | CED: 1 | FED: 4 (3.7%) | SZ: 108 | XF: F | XP: F | D: 23
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\jpeg\jcapistd.c 80:13 -> 100:42
   -------------------------------------------------------------------------
   JDIMENSION row_ctr, rows_left;
   
   if (cinfo->global_state != CSTATE_SCANNING)
     ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
   if (cinfo->next_scanline >= cinfo->image_height)
     WARNMS(cinfo, JWRN_TOO_MUCH_DATA);
   
   /* Call progress monitor hook if present */
   if (cinfo->progress != NULL) {
     cinfo->progress->pass_counter = (long) cinfo->next_scanline;
     cinfo->progress->pass_limit = (long) cinfo->image_height;
     (*cinfo->progress->progress_monitor) ((j_common_ptr) cinfo);
   }
   
   /* Give master control module another chance if this is first call to
    * jpeg_write_scanlines.  This lets output of the frame/scan headers be
    * delayed so that application can write COM, etc, markers between
    * jpeg_start_compress and jpeg_write_scanlines.
    */
   if (cinfo->master->call_pass_startup)
     (*cinfo->master->pass_startup) (cinfo);
   -------------------------------------------------------------------------
   Potentially buggy differences:
2|   return 0;
>    ^^^^^^ ^
2| }
>  ^
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\jpeg\jcapistd.c 123:13 -> 145:42
   -------------------------------------------------------------------------
   JDIMENSION lines_per_iMCU_row;
   
   if (cinfo->global_state != CSTATE_RAW_OK)
     ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
   if (cinfo->next_scanline >= cinfo->image_height) {
     WARNMS(cinfo, JWRN_TOO_MUCH_DATA);
     return 0;
   }
   
   /* Call progress monitor hook if present */
   if (cinfo->progress != NULL) {
     cinfo->progress->pass_counter = (long) cinfo->next_scanline;
     cinfo->progress->pass_limit = (long) cinfo->image_height;
     (*cinfo->progress->progress_monitor) ((j_common_ptr) cinfo);
   }
   
   /* Give master control module another chance if this is first call to
    * jpeg_write_raw_data.  This lets output of the frame/scan headers be
    * delayed so that application can write COM, etc, markers between
    * jpeg_start_compress and jpeg_write_raw_data.
    */
   if (cinfo->master->call_pass_startup)
     (*cinfo->master->pass_startup) (cinfo);
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 49: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.637 | CED: 3 | FED: 14 (4.1%) | SZ: 345 | XF: F | XP: F | D: 2
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\content\base\src\nsdocumentencoder.cpp 1553:13 -> 1637:2
   -------------------------------------------------------------------------
   *outOffset = offset;
   
   if (common == node)
     return NS_OK;
   
   if (aWhere == kStart)
   {
     // some special casing for text nodes
     nsCOMPtr<nsINode> t = do_QueryInterface(aNode);
     if (IsTextNode(t))
     {
       // if not at beginning of text node, we are done
       if (offset >  0)
       {
         // unless everything before us in just whitespace.  NOTE: we need a more
         // general solution that truly detects all cases of non-significant
         // whitesace with no false alarms.
         nsCOMPtr<nsIDOMCharacterData> nodeAsText = do_QueryInterface(aNode);
         nsAutoString text;
         nodeAsText->SubstringData(0, offset, text);
         text.CompressWhitespace();
         if (!text.IsEmpty())
           return NS_OK;
         bResetPromotion = PR_TRUE;
       }
       // else
       rv = GetNodeLocation(aNode, address_of(parent), &offset);
       NS_ENSURE_SUCCESS(rv, rv);
     }
     else
     {
       node = GetChildAt(parent,offset);
     }
     if (!node) node = parent;
   
     // finding the real start for this point.  look up the tree for as long as we are the
     // first node in the container, and as long as we haven't hit the body node.
     if (!IsRoot(node) && (parent != common))
     {
       rv = GetNodeLocation(node, address_of(parent), &offset);
       NS_ENSURE_SUCCESS(rv, rv);
       if (offset == -1) return NS_OK; // we hit generated content; STOP
       nsIParserService *parserService = nsContentUtils::GetParserService();
       if (!parserService)
         return NS_ERROR_OUT_OF_MEMORY;
       while ((IsFirstNode(node)) && (!IsRoot(parent)) && (parent != common))
       {
         if (bResetPromotion)
         {
           nsCOMPtr<nsIContent> content = do_QueryInterface(parent);
           if (content)
           {
             PRBool isBlock = PR_FALSE;
             parserService->IsBlock(parserService->HTMLAtomTagToId(content->Tag()), isBlock);
             if (isBlock)
             {
               bResetPromotion = PR_FALSE;
             }
           }
         }
   
         node = parent;
         rv = GetNodeLocation(node, address_of(parent), &offset);
         NS_ENSURE_SUCCESS(rv, rv);
         if (offset == -1)  // we hit generated content; STOP
         {
           // back up a bit
           parent = node;
           offset = 0;
           break;
         }
       }
       if (bResetPromotion)
       {
         *outNode = aNode;
         *outOffset = aOffset;
       }
       else
       {
         *outNode = parent;
         *outOffset = offset;
       }
       return rv;
     }
   }
   -------------------------------------------------------------------------
   Potentially buggy differences:
1|       nodeAsText->SubstringData(0, offset, text);
>                                  --
2|       nodeAsText->SubstringData(offset, len-offset, text);
>                                  ------- ----

2|     if (offset) offset--; 
>      ^^ ^^^^^^^^ ^^^^^^^^

2|       offset++;  
>        ^^^^^^^^
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\content\base\src\nsdocumentencoder.cpp 1639:2 -> 1721:2
   -------------------------------------------------------------------------
   if (aWhere == kEnd)
   {
     // some special casing for text nodes
     nsCOMPtr<nsINode> n = do_QueryInterface(aNode);
     if (IsTextNode(n))
     {
       // if not at end of text node, we are done
       PRUint32 len;
       GetLengthOfDOMNode(aNode, len);
       if (offset < (PRInt32)len)
       {
         // unless everything after us in just whitespace.  NOTE: we need a more
         // general solution that truly detects all cases of non-significant
         // whitesace with no false alarms.
         nsCOMPtr<nsIDOMCharacterData> nodeAsText = do_QueryInterface(aNode);
         nsAutoString text;
         nodeAsText->SubstringData(offset, len-offset, text);
         text.CompressWhitespace();
         if (!text.IsEmpty())
           return NS_OK;
         bResetPromotion = PR_TRUE;
       }
       rv = GetNodeLocation(aNode, address_of(parent), &offset);
       NS_ENSURE_SUCCESS(rv, rv);
     }
     else
     {
       if (offset) offset--; // we want node _before_ offset
       node = GetChildAt(parent,offset);
     }
     if (!node) node = parent;
   
     // finding the real end for this point.  look up the tree for as long as we are the
     // last node in the container, and as long as we haven't hit the body node.
     if (!IsRoot(node) && (parent != common))
     {
       rv = GetNodeLocation(node, address_of(parent), &offset);
       NS_ENSURE_SUCCESS(rv, rv);
       if (offset == -1) return NS_OK; // we hit generated content; STOP
       nsIParserService *parserService = nsContentUtils::GetParserService();
       if (!parserService)
         return NS_ERROR_OUT_OF_MEMORY;
       while ((IsLastNode(node)) && (!IsRoot(parent)) && (parent != common))
       {
         if (bResetPromotion)
         {
           nsCOMPtr<nsIContent> content = do_QueryInterface(parent);
           if (content)
           {
             PRBool isBlock = PR_FALSE;
             parserService->IsBlock(parserService->HTMLAtomTagToId(content->Tag()), isBlock);
             if (isBlock)
             {
               bResetPromotion = PR_FALSE;
             }
           }
         }
   
         node = parent;
         rv = GetNodeLocation(node, address_of(parent), &offset);
         NS_ENSURE_SUCCESS(rv, rv);
         if (offset == -1)  // we hit generated content; STOP
         {
           // back up a bit
           parent = node;
           offset = 0;
           break;
         }
       }
       if (bResetPromotion)
       {
         *outNode = aNode;
         *outOffset = aOffset;
       }
       else
       {
         *outNode = parent;
         offset++;  // add one since this in an endpoint - want to be AFTER node.
         *outOffset = offset;
       }
       return rv;
     }
   }
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 50: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.857 | CED: 2 | FED: 5 (3.0%) | SZ: 166 | XF: T | XP: F | D: inf
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\extensions\universalchardet\src\base\nseucjpprober.cpp 55:12 -> 89:15
   -------------------------------------------------------------------------
   nsSMState codingState;
   
   for (PRUint32 i = 0; i < aLen; i++)
   {
     codingState = mCodingSM->NextState(aBuf[i]);
     if (codingState == eItsMe)
     {
       mState = eFoundIt;
       break;
     }
     if (codingState == eStart)
     {
       PRUint32 charLen = mCodingSM->GetCurrentCharLen();
   
       if (i == 0)
       {
         mLastChar[1] = aBuf[0];
         mContextAnalyser.HandleOneChar(mLastChar, charLen);
         mDistributionAnalyser.HandleOneChar(mLastChar, charLen);
       }
       else
       {
         mContextAnalyser.HandleOneChar(aBuf+i-1, charLen);
         mDistributionAnalyser.HandleOneChar(aBuf+i-1, charLen);
       }
     }
   }
   
   mLastChar[0] = aBuf[aLen-1];
   
   if (mState == eDetecting)
     if (mContextAnalyser.GotEnoughData() && GetConfidence() > SHORTCUT_THRESHOLD)
       mState = eFoundIt;
   
   return mState;
   -------------------------------------------------------------------------
   Potentially buggy differences:
2|       mContextAnalyser.HandleOneChar(mLastChar+2-charLen, charLen);
>                                                ^^^^^^^^^^

1|       mContextAnalyser.HandleOneChar(aBuf+i-1, charLen);
>                                              -
2|       mContextAnalyser.HandleOneChar(aBuf+i+1-charLen, charLen);
>                                                -------
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\extensions\universalchardet\src\base\nssjisprober.cpp 55:12 -> 88:15
   -------------------------------------------------------------------------
   nsSMState codingState;
   
   for (PRUint32 i = 0; i < aLen; i++)
   {
     codingState = mCodingSM->NextState(aBuf[i]);
     if (codingState == eItsMe)
     {
       mState = eFoundIt;
       break;
     }
     if (codingState == eStart)
     {
       PRUint32 charLen = mCodingSM->GetCurrentCharLen();
       if (i == 0)
       {
         mLastChar[1] = aBuf[0];
         mContextAnalyser.HandleOneChar(mLastChar+2-charLen, charLen);
         mDistributionAnalyser.HandleOneChar(mLastChar, charLen);
       }
       else
       {
         mContextAnalyser.HandleOneChar(aBuf+i+1-charLen, charLen);
         mDistributionAnalyser.HandleOneChar(aBuf+i-1, charLen);
       }
     }
   }
   
   mLastChar[0] = aBuf[aLen-1];
   
   if (mState == eDetecting)
     if (mContextAnalyser.GotEnoughData() && GetConfidence() > SHORTCUT_THRESHOLD)
       mState = eFoundIt;
   
   return mState;
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 51: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.617 | CED: 1 | FED: 5 (5.4%) | SZ: 93 | XF: T | XP: T | D: inf
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\content\base\src\nsdomattributemap.cpp 395:28 -> 417:0
   -------------------------------------------------------------------------
   nsDOMAttributeMap::GetItemAt(PRUint32 aIndex, nsresult *aResult)
   {
     *aResult = NS_OK;
   
     nsDOMAttribute* node = nsnull;
   
     const nsAttrName* name;
     if (mContent && (name = mContent->GetAttrNameAt(aIndex))) {
       // Don't use the nodeinfo even if one exists since it can
       // have the wrong owner document.
       nsCOMPtr<nsINodeInfo> ni;
       ni = mContent->NodeInfo()->NodeInfoManager()->
         GetNodeInfo(name->LocalName(), name->GetPrefix(), name->NamespaceID());
       if (ni) {
         node = GetAttribute(ni);
       }
       else {
         *aResult = NS_ERROR_OUT_OF_MEMORY;
       }
     }
   
     return node;
   }
   -------------------------------------------------------------------------
   Potentially buggy differences:
1|     else {
>      ----
2|   if (!node) {
>    -- -------
   -------------------------------------------------------------------------
   c:\mozilla-central\content\base\src\nsdomattributemap.cpp 406:11 -> 423:2
   -------------------------------------------------------------------------
   *aResult = NS_OK;
   
   nsIDOMNode* node = nsnull;
   
   const nsAttrName* name;
   if (mContent && (name = mContent->GetAttrNameAt(aIndex))) {
     // Don't use the nodeinfo even if one exists since it can
     // have the wrong owner document.
     nsCOMPtr<nsINodeInfo> ni;
     ni = mContent->NodeInfo()->NodeInfoManager()->
       GetNodeInfo(name->LocalName(), name->GetPrefix(), name->NamespaceID());
     if (ni) {
       node = GetAttribute(ni);
     }
     if (!node) {
       *aResult = NS_ERROR_OUT_OF_MEMORY;
     }
   }
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 52: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.571 | CED: 1 | FED: 6 (7.1%) | SZ: 84 | XF: F | XP: F | D: 48
   -------------------------------------------------------------------------
   c:\comm-central\directory\c-sdk\ldap\libraries\libldap\memcache.c 740:8 -> 758:15
   -------------------------------------------------------------------------
   int nRes;
   
   if ( !NSLDAPI_VALID_LDAP_POINTER( ld ) ) {
   return( LDAP_PARAM_ERROR );
   }
   
   LDAP_MUTEX_LOCK( ld, LDAP_MEMCACHE_LOCK );
   
   if (!memcache_exist(ld)) {
       LDAP_MUTEX_UNLOCK( ld, LDAP_MEMCACHE_LOCK );
   return( LDAP_LOCAL_ERROR );
   }
   
   LDAP_MEMCACHE_MUTEX_LOCK( ld->ld_memcache );
   nRes = memcache_add(ld, key, msgid, basedn);
   LDAP_MEMCACHE_MUTEX_UNLOCK( ld->ld_memcache );
   LDAP_MUTEX_UNLOCK( ld, LDAP_MEMCACHE_LOCK );
   
   return nRes;
   -------------------------------------------------------------------------
   Potentially buggy differences:
2| if ( !NSLDAPI_VALID_LDAP_POINTER( ld ) || (msgid < 0) ) {
>                                       ^ ^^ ^^^^^^ ^ ^
   -------------------------------------------------------------------------
   c:\comm-central\directory\c-sdk\ldap\libraries\libldap\memcache.c 806:8 -> 824:15
   -------------------------------------------------------------------------
   int nRes;
   
   if ( !NSLDAPI_VALID_LDAP_POINTER( ld ) || (msgid < 0) ) {
   return( LDAP_PARAM_ERROR );
   }
   
   LDAP_MUTEX_LOCK( ld, LDAP_MEMCACHE_LOCK );
   
   if (!memcache_exist(ld)) {
       LDAP_MUTEX_UNLOCK( ld, LDAP_MEMCACHE_LOCK );
   return( LDAP_LOCAL_ERROR );
   }
   
   LDAP_MEMCACHE_MUTEX_LOCK( ld->ld_memcache );
   nRes = memcache_remove(ld, msgid);
   LDAP_MEMCACHE_MUTEX_UNLOCK( ld->ld_memcache );
   LDAP_MUTEX_UNLOCK( ld, LDAP_MEMCACHE_LOCK );
   
   return nRes;
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 53: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.793 | CED: 2 | FED: 10 (5.5%) | SZ: 182 | XF: F | XP: F | D: 35
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\uriloader\exthandler\win\nsmimeinfowin.cpp 367:29 -> 410:19
   -------------------------------------------------------------------------
   nsCOMPtr<nsIWindowsRegKey> appKey =
     do_CreateInstance("@mozilla.org/windows-registry-key;1");
   if (!appKey)
     return PR_FALSE;
   
   // HKEY_CLASSES_ROOT\Applications\iexplore.exe
   nsAutoString applicationsPath;
   applicationsPath.AppendLiteral("Applications\\");
   applicationsPath.Append(appExeName);
   
   nsresult rv = appKey->Open(nsIWindowsRegKey::ROOT_KEY_CLASSES_ROOT,
                              applicationsPath,
                              nsIWindowsRegKey::ACCESS_QUERY_VALUE);
   if (NS_FAILED(rv))
     return PR_FALSE;
   
   // Check for the NoOpenWith flag, if it exists
   PRUint32 value;
   if (NS_SUCCEEDED(appKey->ReadIntValue(
       NS_LITERAL_STRING("NoOpenWith"), &value)) &&
       value == 1)
     return PR_FALSE;
   
   nsAutoString dummy;
   if (NS_SUCCEEDED(appKey->ReadStringValue(
         NS_LITERAL_STRING("NoOpenWith"), dummy)))
     return PR_FALSE;
   
   appKey->Close();
   
   // HKEY_CLASSES_ROOT\Applications\iexplore.exe\shell\open\command
   applicationsPath.AssignLiteral("Applications\\");
   applicationsPath.Append(appExeName);
   if (!edit)
     applicationsPath.AppendLiteral("\\shell\\open\\command");
   else
     applicationsPath.AppendLiteral("\\shell\\edit\\command");
   
   
   rv = appKey->Open(nsIWindowsRegKey::ROOT_KEY_CLASSES_ROOT,
                     applicationsPath,
                     nsIWindowsRegKey::ACCESS_QUERY_VALUE);
   if (NS_FAILED(rv))
     return PR_FALSE;
   -------------------------------------------------------------------------
   Potentially buggy differences:
1| if (NS_SUCCEEDED(appKey->ReadIntValue(
>  -- --------------
2| rv = appKey->ReadIntValue(NS_LITERAL_STRING("NoOpenWith"), &value);
>  -- -
2| if (NS_SUCCEEDED(rv) && value == 1)
>  ^^ ^^^^^^^^^^^^^^^^
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\uriloader\exthandler\win\nsmimeinfowin.cpp 445:29 -> 486:19
   -------------------------------------------------------------------------
   nsCOMPtr<nsIWindowsRegKey> appKey =
     do_CreateInstance("@mozilla.org/windows-registry-key;1");
   if (!appKey)
     return PR_FALSE;
   
   // HKEY_CLASSES_ROOT\Applications\iexplore.exe
   nsAutoString applicationsPath;
   applicationsPath.AppendLiteral("Applications\\");
   applicationsPath.Append(appExeName);
   
   nsresult rv = appKey->Open(nsIWindowsRegKey::ROOT_KEY_CLASSES_ROOT,
                              applicationsPath,
                              nsIWindowsRegKey::ACCESS_QUERY_VALUE);
   if (NS_FAILED(rv))
     return PR_FALSE;
   
   // Check for the NoOpenWith flag, if it exists
   PRUint32 value;
   rv = appKey->ReadIntValue(NS_LITERAL_STRING("NoOpenWith"), &value);
   if (NS_SUCCEEDED(rv) && value == 1)
     return PR_FALSE;
   
   nsAutoString dummy;
   if (NS_SUCCEEDED(appKey->ReadStringValue(NS_LITERAL_STRING("NoOpenWith"),
                                            dummy)))
     return PR_FALSE;
   
   appKey->Close();
   
   // HKEY_CLASSES_ROOT\Applications\iexplore.exe\shell\open\command
   applicationsPath.AssignLiteral("Applications\\");
   applicationsPath.Append(appExeName);
   if (!edit)
     applicationsPath.AppendLiteral("\\shell\\open\\command");
   else
     applicationsPath.AppendLiteral("\\shell\\edit\\command");
   
   rv = appKey->Open(nsIWindowsRegKey::ROOT_KEY_CLASSES_ROOT,
                     applicationsPath,
                     nsIWindowsRegKey::ACCESS_QUERY_VALUE);
   if (NS_FAILED(rv))
     return PR_FALSE;
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 54: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.683 | CED: 1 | FED: 1 (0.6%) | SZ: 162 | XF: F | XP: F | D: 3
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\js\src\jsmath.cpp 328:0 -> 354:0
   -------------------------------------------------------------------------
   js_math_max(JSContext *cx, uintN argc, jsval *vp)
   {
       jsdouble x, z = js_NegativeInfinity;
       jsval *argv;
       uintN i;
   
       if (argc == 0) {
           *vp = cx->runtime->negativeInfinityValue;
           return JS_TRUE;
       }
       argv = vp + 2;
       for (i = 0; i < argc; i++) {
           if (!ValueToNumber(cx, argv[i], &x))
               return JS_FALSE;
           if (JSDOUBLE_IS_NaN(x)) {
               *vp = cx->runtime->NaNValue;
               return JS_TRUE;
           }
           if (x == 0 && x == z) {
               if (js_copysign(1.0, z) == -1)
                   z = x;
           } else {
               z = (x > z) ? x : z;
           }
       }
       return js_NewNumberInRootedValue(cx, z, vp);
   }
   -------------------------------------------------------------------------
   Potentially buggy differences:
1|             if (js_copysign(1.0, z) == -1)
>                                   -
2|             if (js_copysign(1.0, x) == -1)
>                                   -
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\js\src\jsmath.cpp 357:0 -> 383:0
   -------------------------------------------------------------------------
   js_math_min(JSContext *cx, uintN argc, jsval *vp)
   {
       jsdouble x, z = js_PositiveInfinity;
       jsval *argv;
       uintN i;
   
       if (argc == 0) {
           *vp = cx->runtime->positiveInfinityValue;
           return JS_TRUE;
       }
       argv = vp + 2;
       for (i = 0; i < argc; i++) {
           if (!ValueToNumber(cx, argv[i], &x))
               return JS_FALSE;
           if (JSDOUBLE_IS_NaN(x)) {
               *vp = cx->runtime->NaNValue;
               return JS_TRUE;
           }
           if (x == 0 && x == z) {
               if (js_copysign(1.0, x) == -1)
                   z = x;
           } else {
               z = (x < z) ? x : z;
           }
       }
       return js_NewNumberInRootedValue(cx, z, vp);
   }
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 55: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.669 | CED: 1 | FED: 1 (0.8%) | SZ: 123 | XF: T | XP: F | D: inf
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\storage\src\mozstorageasyncstatement.cpp 218:25 -> 249:0
   -------------------------------------------------------------------------
   AsyncStatement::getParams()
   {
     nsresult rv;
   
     // If we do not have an array object yet, make it.
     if (!mParamsArray) {
       nsCOMPtr<mozIStorageBindingParamsArray> array;
       rv = NewBindingParamsArray(getter_AddRefs(array));
       NS_ENSURE_SUCCESS(rv, nsnull);
   
       mParamsArray = static_cast<BindingParamsArray *>(array.get());
     }
   
     // If there isn't already any rows added, we'll have to add one to use.
     if (mParamsArray->length() == 0) {
       nsRefPtr<AsyncBindingParams> params(new AsyncBindingParams(mParamsArray));
       NS_ENSURE_TRUE(params, nsnull);
   
       rv = mParamsArray->AddParams(params);
       NS_ENSURE_SUCCESS(rv, nsnull);
   
       // We have to unlock our params because AddParams locks them.  This is safe
       // because no reference to the params object was, or ever will be given out.
       params->unlock(nsnull);
   
       // We also want to lock our array at this point - we don't want anything to
       // be added to it.
       mParamsArray->lock();
     }
   
     return *mParamsArray->begin();
   }
   -------------------------------------------------------------------------
   Potentially buggy differences:
1|     params->unlock(nsnull);
>                     ------
2|     params->unlock(this);
>                     ----
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\storage\src\mozstoragestatement.cpp 245:20 -> 277:0
   -------------------------------------------------------------------------
   Statement::getParams()
   {
     nsresult rv;
   
     // If we do not have an array object yet, make it.
     if (!mParamsArray) {
       nsCOMPtr<mozIStorageBindingParamsArray> array;
       rv = NewBindingParamsArray(getter_AddRefs(array));
       NS_ENSURE_SUCCESS(rv, nsnull);
   
       mParamsArray = static_cast<BindingParamsArray *>(array.get());
     }
   
     // If there isn't already any rows added, we'll have to add one to use.
     if (mParamsArray->length() == 0) {
       nsRefPtr<BindingParams> params(new BindingParams(mParamsArray, this));
       NS_ENSURE_TRUE(params, nsnull);
   
       rv = mParamsArray->AddParams(params);
       NS_ENSURE_SUCCESS(rv, nsnull);
   
       // We have to unlock our params because AddParams locks them.  This is safe
       // because no reference to the params object was, or ever will be given out.
       params->unlock(this);
   
       // We also want to lock our array at this point - we don't want anything to
       // be added to it.  Nothing has, or will ever get a reference to it, but we
       // will get additional safety checks via assertions by doing this.
       mParamsArray->lock();
     }
   
     return *mParamsArray->begin();
   }
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 56: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.744 | CED: 1 | FED: 8 (11.8%) | SZ: 68 | XF: T | XP: F | D: inf
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\jpeg\jdhuff.c 476:30 -> 497:13
   -------------------------------------------------------------------------
   entropy->bitstate.bits_left = 0;
   
   /* Advance past the RSTn marker */
   if (! (*cinfo->marker->read_restart_marker) (cinfo))
     return FALSE;
   
   /* Re-initialize DC predictions to 0 */
   for (ci = 0; ci < cinfo->comps_in_scan; ci++)
     entropy->saved.last_dc_val[ci] = 0;
   
   /* Reset restart counter */
   entropy->restarts_to_go = cinfo->restart_interval;
   
   /* Reset out-of-data flag, unless read_restart_marker left us smack up
    * against a marker.  In that case we will end up treating the next data
    * segment as empty, and we can avoid producing bogus output pixels by
    * leaving the flag set.
    */
   if (cinfo->unread_marker == 0)
     entropy->pub.insufficient_data = FALSE;
   
   return TRUE;
   -------------------------------------------------------------------------
   Potentially buggy differences:
2| entropy->saved.EOBRUN = 0;
>           ^^^^^^^^^^^^ ^ ^
2| entropy->restarts_to_go = cinfo->restart_interval;
>  ^^^^^^^^^
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\jpeg\jdphuff.c 239:2 -> 257:42
   -------------------------------------------------------------------------
   if (! (*cinfo->marker->read_restart_marker) (cinfo))
     return FALSE;
   
   /* Re-initialize DC predictions to 0 */
   for (ci = 0; ci < cinfo->comps_in_scan; ci++)
     entropy->saved.last_dc_val[ci] = 0;
   /* Re-init EOB run count, too */
   entropy->saved.EOBRUN = 0;
   
   /* Reset restart counter */
   entropy->restarts_to_go = cinfo->restart_interval;
   
   /* Reset out-of-data flag, unless read_restart_marker left us smack up
    * against a marker.  In that case we will end up treating the next data
    * segment as empty, and we can avoid producing bogus output pixels by
    * leaving the flag set.
    */
   if (cinfo->unread_marker == 0)
     entropy->pub.insufficient_data = FALSE;
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 57: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.607 | CED: 1 | FED: 7 (8.0%) | SZ: 88 | XF: T | XP: T | D: inf
   -------------------------------------------------------------------------
   c:\comm-central\mailnews\imap\src\nsimapmailfolder.cpp 3517:38 -> 3529:81
   -------------------------------------------------------------------------
   nsCOMPtr<nsIMutableArray> messageArray(do_CreateInstance(NS_ARRAY_CONTRACTID, &rv));
   NS_ENSURE_TRUE(messageArray, rv);
   messageArray->AppendElement(msgHdr, PR_FALSE);
   
   nsCOMPtr<nsIMsgFolder> dstFolder;
   rv = GetExistingFolder(actionTargetFolderUri, getter_AddRefs(dstFolder));
   NS_ENSURE_SUCCESS(rv, rv);
   
   nsCOMPtr<nsIMsgCopyService> copyService =
     do_GetService(NS_MSGCOPYSERVICE_CONTRACTID, &rv);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = copyService->CopyMessages(this, messageArray, dstFolder,
                                  PR_FALSE, nsnull, msgWindow, PR_FALSE);
   -------------------------------------------------------------------------
   Potentially buggy differences:
1| nsCOMPtr<nsIMutableArray> messageArray(do_CreateInstance(NS_ARRAY_CONTRACTID, &rv));
>                                                                                    ^
1| NS_ENSURE_TRUE(messageArray, rv);
>  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ^^
   -------------------------------------------------------------------------
   c:\comm-central\mailnews\local\src\nsparsemailbox.cpp 2076:38 -> 2089:12
   -------------------------------------------------------------------------
   nsCOMPtr<nsIMutableArray> messageArray(do_CreateInstance(NS_ARRAY_CONTRACTID));
   messageArray->AppendElement(msgHdr, PR_FALSE);
   
   nsCOMPtr<nsIMsgFolder> dstFolder;
   rv = GetExistingFolder(actionTargetFolderUri,
                          getter_AddRefs(dstFolder));
   NS_ENSURE_SUCCESS(rv, rv);
   
   nsCOMPtr<nsIMsgCopyService> copyService =
     do_GetService(NS_MSGCOPYSERVICE_CONTRACTID, &rv);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = copyService->CopyMessages(m_downloadFolder, messageArray, dstFolder,
                                  PR_FALSE, nsnull, msgWindow, PR_FALSE);
   NS_ENSURE_SUCCESS(rv, rv);
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 58: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.502 | CED: 2 | FED: 6 (2.9%) | SZ: 210 | XF: T | XP: T | D: inf
   -------------------------------------------------------------------------
   c:\comm-central\mailnews\base\util\nsmsgdbfolder.cpp 3808:25 -> 3857:49
   -------------------------------------------------------------------------
   nsCOMPtr<nsILocalFile> oldPathFile;
   nsCOMPtr<nsIAtom> folderRenameAtom;
   nsresult rv = GetFilePath(getter_AddRefs(oldPathFile));
   if (NS_FAILED(rv))
     return rv;
   nsCOMPtr<nsIMsgFolder> parentFolder;
   rv = GetParent(getter_AddRefs(parentFolder));
   if (!parentFolder)
     return NS_ERROR_FAILURE;
   nsCOMPtr<nsISupports> parentSupport = do_QueryInterface(parentFolder);
   nsCOMPtr<nsILocalFile> oldSummaryFile;
   rv = GetSummaryFileLocation(oldPathFile, getter_AddRefs(oldSummaryFile));
   NS_ENSURE_SUCCESS(rv, rv);
   
   nsCOMPtr<nsILocalFile> dirFile;
   PRInt32 count = mSubFolders.Count();
   
   if (count > 0)
     rv = CreateDirectoryForFolder(getter_AddRefs(dirFile));
   
   nsAutoString newDiskName(aNewName);
   NS_MsgHashIfNecessary(newDiskName);
   
   if (mName.Equals(aNewName, nsCaseInsensitiveStringComparator()))
   {
     rv = ThrowAlertMsg("folderExists", msgWindow);
     return NS_MSG_FOLDER_EXISTS;
   }
   else
   {
     nsCOMPtr <nsILocalFile> parentPathFile;
     parentFolder->GetFilePath(getter_AddRefs(parentPathFile));
     NS_ENSURE_SUCCESS(rv,rv);
     PRBool isDirectory = PR_FALSE;
     parentPathFile->IsDirectory(&isDirectory);
     if (!isDirectory)
       AddDirectorySeparator(parentPathFile);
   
     rv = CheckIfFolderExists(aNewName, parentFolder, msgWindow);
     if (NS_FAILED(rv))
       return rv;
   }
   
   ForceDBClosed();
   
   // Save of dir name before appending .msf
   nsAutoString newNameDirStr(newDiskName);
   
   if (! (mFlags & nsMsgFolderFlags::Virtual))
     rv = oldPathFile->MoveTo(nsnull, newDiskName);
   -------------------------------------------------------------------------
   Potentially buggy differences:
2|   if (msgWindow)
>    ^^ ^^^^^^^^^^^

1| else
>  ^^^^
1| {
>  ^
   -------------------------------------------------------------------------
   c:\comm-central\mailnews\local\src\nslocalmailfolder.cpp 1121:2 -> 1174:61
   -------------------------------------------------------------------------
   if (mName.Equals(aNewName))
     return NS_OK;
   
   nsCOMPtr<nsILocalFile> oldPathFile;
   nsresult rv = GetFilePath(getter_AddRefs(oldPathFile));
   if (NS_FAILED(rv))
     return rv;
   
   nsCOMPtr<nsIMsgFolder> parentFolder;
   rv = GetParent(getter_AddRefs(parentFolder));
   if (!parentFolder)
     return NS_ERROR_NULL_POINTER;
   
   nsCOMPtr<nsISupports> parentSupport = do_QueryInterface(parentFolder);
   
   nsCOMPtr <nsILocalFile> oldSummaryFile;
   rv = GetSummaryFileLocation(oldPathFile, getter_AddRefs(oldSummaryFile));
   NS_ENSURE_SUCCESS(rv, rv);
   
   nsCOMPtr <nsILocalFile> dirFile;
   PRInt32 count = mSubFolders.Count();
   
   if (count > 0)
     rv = CreateDirectoryForFolder(getter_AddRefs(dirFile));
   
   // Convert from nsAString to nsCAutoString, as we will call moveToNative(),
   // not moveTo().
   
   nsAutoString safeName(aNewName);
   NS_MsgHashIfNecessary(safeName);
   nsCAutoString newDiskName;
   if (NS_FAILED(NS_CopyUnicodeToNative(safeName, newDiskName)))
     return NS_ERROR_FAILURE;
   
   nsCAutoString oldLeafName;
   oldPathFile->GetNativeLeafName(oldLeafName);
   
   if (mName.Equals(aNewName, nsCaseInsensitiveStringComparator()))
   {
     if (msgWindow)
       rv = ThrowAlertMsg("folderExists", msgWindow);
     return NS_MSG_FOLDER_EXISTS;
   }
   
   nsCOMPtr<nsILocalFile> parentPathFile;
   parentFolder->GetFilePath(getter_AddRefs(parentPathFile));
   NS_ENSURE_SUCCESS(rv,rv);
   
   PRBool isDirectory = PR_FALSE;
   parentPathFile->IsDirectory(&isDirectory);
   if (!isDirectory)
     AddDirectorySeparator(parentPathFile);
   
   rv = CheckIfFolderExists(aNewName, parentFolder, msgWindow);
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 59: 4 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.718 | CED: 1 | FED: 5 (3.3%) | SZ: 152 | XF: F | XP: F | D: 4
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\xpcom\base\nstracerefcntimpl.cpp 1091:0 -> 1124:0
   -------------------------------------------------------------------------
   NS_LogCtor(void* aPtr, const char* aType, PRUint32 aInstanceSize)
   {
   #ifdef NS_IMPL_REFCNT_LOGGING
     ASSERT_ACTIVITY_IS_LEGAL;
     if (!gInitialized)
       InitTraceLog();
   
     if (gLogging) {
       LOCK_TRACELOG();
   
       if (gBloatLog) {
         BloatEntry* entry = GetBloatEntry(aType, aInstanceSize);
         if (entry) {
           entry->Ctor();
         }
       }
   
       PRBool loggingThisType = (!gTypesToLog || LogThisType(aType));
       PRInt32 serialno = 0;
       if (gSerialNumbers && loggingThisType) {
         serialno = GetSerialNumber(aPtr, PR_TRUE);
       }
   
       PRBool loggingThisObject = (!gObjectsToLog || LogThisObj(serialno));
       if (gAllocLog && loggingThisType && loggingThisObject) {
         fprintf(gAllocLog, "\n<%s> 0x%08X %d Ctor (%d)\n",
                aType, NS_PTR_TO_INT32(aPtr), serialno, aInstanceSize);
         nsTraceRefcntImpl::WalkTheStack(gAllocLog);
       }
   
       UNLOCK_TRACELOG();
     }
   #endif
   }
   -------------------------------------------------------------------------
   Potentially buggy differences:
2|       RecycleSerialNumberPtr(aPtr);
>        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\xpcom\base\nstracerefcntimpl.cpp 1128:0 -> 1165:0
   -------------------------------------------------------------------------
   NS_LogDtor(void* aPtr, const char* aType, PRUint32 aInstanceSize)
   {
   #ifdef NS_IMPL_REFCNT_LOGGING
     ASSERT_ACTIVITY_IS_LEGAL;
     if (!gInitialized)
       InitTraceLog();
   
     if (gLogging) {
       LOCK_TRACELOG();
   
       if (gBloatLog) {
         BloatEntry* entry = GetBloatEntry(aType, aInstanceSize);
         if (entry) {
           entry->Dtor();
         }
       }
   
       PRBool loggingThisType = (!gTypesToLog || LogThisType(aType));
       PRInt32 serialno = 0;
       if (gSerialNumbers && loggingThisType) {
         serialno = GetSerialNumber(aPtr, PR_FALSE);
         RecycleSerialNumberPtr(aPtr);
       }
   
       PRBool loggingThisObject = (!gObjectsToLog || LogThisObj(serialno));
   
       // (If we're on a losing architecture, don't do this because we'll be
       // using LogDeleteXPCOM instead to get file and line numbers.)
       if (gAllocLog && loggingThisType && loggingThisObject) {
         fprintf(gAllocLog, "\n<%s> 0x%08X %d Dtor (%d)\n",
                aType, NS_PTR_TO_INT32(aPtr), serialno, aInstanceSize);
         nsTraceRefcntImpl::WalkTheStack(gAllocLog);
       }
   
       UNLOCK_TRACELOG();
     }
   #endif
   }
   -------------------------------------------------------------------------

 Pair b.) TxtSim: 0.718 | CED: 1 | FED: 5 (3.3%) | SZ: 152 | XF: T | XP: T | D: inf
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\xpcom\base\nstracerefcntimpl.cpp 1091:0 -> 1124:0
   -------------------------------------------------------------------------
   NS_LogCtor(void* aPtr, const char* aType, PRUint32 aInstanceSize)
   {
   #ifdef NS_IMPL_REFCNT_LOGGING
     ASSERT_ACTIVITY_IS_LEGAL;
     if (!gInitialized)
       InitTraceLog();
   
     if (gLogging) {
       LOCK_TRACELOG();
   
       if (gBloatLog) {
         BloatEntry* entry = GetBloatEntry(aType, aInstanceSize);
         if (entry) {
           entry->Ctor();
         }
       }
   
       PRBool loggingThisType = (!gTypesToLog || LogThisType(aType));
       PRInt32 serialno = 0;
       if (gSerialNumbers && loggingThisType) {
         serialno = GetSerialNumber(aPtr, PR_TRUE);
       }
   
       PRBool loggingThisObject = (!gObjectsToLog || LogThisObj(serialno));
       if (gAllocLog && loggingThisType && loggingThisObject) {
         fprintf(gAllocLog, "\n<%s> 0x%08X %d Ctor (%d)\n",
                aType, NS_PTR_TO_INT32(aPtr), serialno, aInstanceSize);
         nsTraceRefcntImpl::WalkTheStack(gAllocLog);
       }
   
       UNLOCK_TRACELOG();
     }
   #endif
   }
   -------------------------------------------------------------------------
   Potentially buggy differences:
2|       RecycleSerialNumberPtr(aPtr);
>        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   -------------------------------------------------------------------------
   c:\mozilla-central\xpcom\base\nstracerefcntimpl.cpp 1128:0 -> 1165:0
   -------------------------------------------------------------------------
   NS_LogDtor(void* aPtr, const char* aType, PRUint32 aInstanceSize)
   {
   #ifdef NS_IMPL_REFCNT_LOGGING
     ASSERT_ACTIVITY_IS_LEGAL;
     if (!gInitialized)
       InitTraceLog();
   
     if (gLogging) {
       LOCK_TRACELOG();
   
       if (gBloatLog) {
         BloatEntry* entry = GetBloatEntry(aType, aInstanceSize);
         if (entry) {
           entry->Dtor();
         }
       }
   
       PRBool loggingThisType = (!gTypesToLog || LogThisType(aType));
       PRInt32 serialno = 0;
       if (gSerialNumbers && loggingThisType) {
         serialno = GetSerialNumber(aPtr, PR_FALSE);
         RecycleSerialNumberPtr(aPtr);
       }
   
       PRBool loggingThisObject = (!gObjectsToLog || LogThisObj(serialno));
   
       // (If we're on a losing architecture, don't do this because we'll be
       // using LogDeleteXPCOM instead to get file and line numbers.)
       if (gAllocLog && loggingThisType && loggingThisObject) {
         fprintf(gAllocLog, "\n<%s> 0x%08X %d Dtor (%d)\n",
                aType, NS_PTR_TO_INT32(aPtr), serialno, aInstanceSize);
         nsTraceRefcntImpl::WalkTheStack(gAllocLog);
       }
   
       UNLOCK_TRACELOG();
     }
   #endif
   }
   -------------------------------------------------------------------------

 Pair c.) TxtSim: 0.718 | CED: 1 | FED: 5 (3.3%) | SZ: 152 | XF: T | XP: T | D: inf
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\xpcom\base\nstracerefcntimpl.cpp 1128:0 -> 1165:0
   -------------------------------------------------------------------------
   NS_LogDtor(void* aPtr, const char* aType, PRUint32 aInstanceSize)
   {
   #ifdef NS_IMPL_REFCNT_LOGGING
     ASSERT_ACTIVITY_IS_LEGAL;
     if (!gInitialized)
       InitTraceLog();
   
     if (gLogging) {
       LOCK_TRACELOG();
   
       if (gBloatLog) {
         BloatEntry* entry = GetBloatEntry(aType, aInstanceSize);
         if (entry) {
           entry->Dtor();
         }
       }
   
       PRBool loggingThisType = (!gTypesToLog || LogThisType(aType));
       PRInt32 serialno = 0;
       if (gSerialNumbers && loggingThisType) {
         serialno = GetSerialNumber(aPtr, PR_FALSE);
         RecycleSerialNumberPtr(aPtr);
       }
   
       PRBool loggingThisObject = (!gObjectsToLog || LogThisObj(serialno));
   
       // (If we're on a losing architecture, don't do this because we'll be
       // using LogDeleteXPCOM instead to get file and line numbers.)
       if (gAllocLog && loggingThisType && loggingThisObject) {
         fprintf(gAllocLog, "\n<%s> 0x%08X %d Dtor (%d)\n",
                aType, NS_PTR_TO_INT32(aPtr), serialno, aInstanceSize);
         nsTraceRefcntImpl::WalkTheStack(gAllocLog);
       }
   
       UNLOCK_TRACELOG();
     }
   #endif
   }
   -------------------------------------------------------------------------
   Potentially buggy differences:
1|       RecycleSerialNumberPtr(aPtr);
>        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   -------------------------------------------------------------------------
   c:\mozilla-central\xpcom\base\nstracerefcntimpl.cpp 1091:0 -> 1124:0
   -------------------------------------------------------------------------
   NS_LogCtor(void* aPtr, const char* aType, PRUint32 aInstanceSize)
   {
   #ifdef NS_IMPL_REFCNT_LOGGING
     ASSERT_ACTIVITY_IS_LEGAL;
     if (!gInitialized)
       InitTraceLog();
   
     if (gLogging) {
       LOCK_TRACELOG();
   
       if (gBloatLog) {
         BloatEntry* entry = GetBloatEntry(aType, aInstanceSize);
         if (entry) {
           entry->Ctor();
         }
       }
   
       PRBool loggingThisType = (!gTypesToLog || LogThisType(aType));
       PRInt32 serialno = 0;
       if (gSerialNumbers && loggingThisType) {
         serialno = GetSerialNumber(aPtr, PR_TRUE);
       }
   
       PRBool loggingThisObject = (!gObjectsToLog || LogThisObj(serialno));
       if (gAllocLog && loggingThisType && loggingThisObject) {
         fprintf(gAllocLog, "\n<%s> 0x%08X %d Ctor (%d)\n",
                aType, NS_PTR_TO_INT32(aPtr), serialno, aInstanceSize);
         nsTraceRefcntImpl::WalkTheStack(gAllocLog);
       }
   
       UNLOCK_TRACELOG();
     }
   #endif
   }
   -------------------------------------------------------------------------

 Pair d.) TxtSim: 0.718 | CED: 1 | FED: 5 (3.3%) | SZ: 152 | XF: F | XP: F | D: 4
   -------------------------------------------------------------------------
   c:\mozilla-central\xpcom\base\nstracerefcntimpl.cpp 1091:0 -> 1124:0
   -------------------------------------------------------------------------
   NS_LogCtor(void* aPtr, const char* aType, PRUint32 aInstanceSize)
   {
   #ifdef NS_IMPL_REFCNT_LOGGING
     ASSERT_ACTIVITY_IS_LEGAL;
     if (!gInitialized)
       InitTraceLog();
   
     if (gLogging) {
       LOCK_TRACELOG();
   
       if (gBloatLog) {
         BloatEntry* entry = GetBloatEntry(aType, aInstanceSize);
         if (entry) {
           entry->Ctor();
         }
       }
   
       PRBool loggingThisType = (!gTypesToLog || LogThisType(aType));
       PRInt32 serialno = 0;
       if (gSerialNumbers && loggingThisType) {
         serialno = GetSerialNumber(aPtr, PR_TRUE);
       }
   
       PRBool loggingThisObject = (!gObjectsToLog || LogThisObj(serialno));
       if (gAllocLog && loggingThisType && loggingThisObject) {
         fprintf(gAllocLog, "\n<%s> 0x%08X %d Ctor (%d)\n",
                aType, NS_PTR_TO_INT32(aPtr), serialno, aInstanceSize);
         nsTraceRefcntImpl::WalkTheStack(gAllocLog);
       }
   
       UNLOCK_TRACELOG();
     }
   #endif
   }
   -------------------------------------------------------------------------
   Potentially buggy differences:
2|       RecycleSerialNumberPtr(aPtr);
>        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   -------------------------------------------------------------------------
   c:\mozilla-central\xpcom\base\nstracerefcntimpl.cpp 1128:0 -> 1165:0
   -------------------------------------------------------------------------
   NS_LogDtor(void* aPtr, const char* aType, PRUint32 aInstanceSize)
   {
   #ifdef NS_IMPL_REFCNT_LOGGING
     ASSERT_ACTIVITY_IS_LEGAL;
     if (!gInitialized)
       InitTraceLog();
   
     if (gLogging) {
       LOCK_TRACELOG();
   
       if (gBloatLog) {
         BloatEntry* entry = GetBloatEntry(aType, aInstanceSize);
         if (entry) {
           entry->Dtor();
         }
       }
   
       PRBool loggingThisType = (!gTypesToLog || LogThisType(aType));
       PRInt32 serialno = 0;
       if (gSerialNumbers && loggingThisType) {
         serialno = GetSerialNumber(aPtr, PR_FALSE);
         RecycleSerialNumberPtr(aPtr);
       }
   
       PRBool loggingThisObject = (!gObjectsToLog || LogThisObj(serialno));
   
       // (If we're on a losing architecture, don't do this because we'll be
       // using LogDeleteXPCOM instead to get file and line numbers.)
       if (gAllocLog && loggingThisType && loggingThisObject) {
         fprintf(gAllocLog, "\n<%s> 0x%08X %d Dtor (%d)\n",
                aType, NS_PTR_TO_INT32(aPtr), serialno, aInstanceSize);
         nsTraceRefcntImpl::WalkTheStack(gAllocLog);
       }
   
       UNLOCK_TRACELOG();
     }
   #endif
   }
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 60: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.591 | CED: 1 | FED: 9 (4.4%) | SZ: 204 | XF: F | XP: F | D: 209
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\js\src\xpconnect\src\xpcwrappedjsclass.cpp 1622:21 -> 1668:4
   -------------------------------------------------------------------------
   readyToDoTheCall = JS_TRUE;
   
   pre_call_clean_up:
       // clean up any 'out' params handed in
       for(i = 0; i < paramCount; i++)
       {
           const nsXPTParamInfo& param = info->params[i];
           if(!param.IsOut())
               continue;
   
           const nsXPTType& type = param.GetType();
           if(!type.IsPointer())
               continue;
           void* p;
           if(!(p = nativeParams[i].val.p))
               continue;
   
           if(param.IsIn())
           {
               if(type.IsArray())
               {
                   void** pp;
                   if(nsnull != (pp = *((void***)p)))
                   {
   
                       // we need to get the array length and iterate the items
                       JSUint32 array_count;
                       nsXPTType datum_type;
   
                       if(NS_SUCCEEDED(mInfo->GetTypeForParam(methodIndex, &param,
                                                              1, &datum_type)) &&
                          datum_type.IsPointer() &&
                          GetArraySizeFromParam(cx, info, param, methodIndex,
                                                i, GET_LENGTH, nativeParams,
                                                &array_count) && array_count)
                       {
                           CleanupPointerArray(datum_type, array_count, pp);
                       }
                       // always release the array if it is inout
                       nsMemory::Free(pp);
                   }
               }
               else
                   CleanupPointerTypeObject(type, (void**)p);
           }
           *((void**)p) = nsnull;
       }
   -------------------------------------------------------------------------
   Potentially buggy differences:
1|         if(param.IsIn())
>             ^^^^^^^^^^^^^
1|         {
>          ^
1|             if(type.IsArray())
>              ^^^
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\js\src\xpconnect\src\xpcwrappedjsclass.cpp 1877:4 -> 1924:4
   -------------------------------------------------------------------------
   if(i != paramCount)
   {
       // We didn't manage all the result conversions!
       // We have to cleanup any junk that *did* get converted.
   
       for(uint8 k = 0; k < i; k++)
       {
           const nsXPTParamInfo& param = info->params[k];
           if(!param.IsOut())
               continue;
           const nsXPTType& type = param.GetType();
           if(!type.IsPointer())
               continue;
           void* p;
           if(!(p = nativeParams[k].val.p))
               continue;
   
           if(type.IsArray())
           {
               void** pp;
               if(nsnull != (pp = *((void***)p)))
               {
                   // we need to get the array length and iterate the items
                   JSUint32 array_count;
                   nsXPTType datum_type;
   
                   if(NS_SUCCEEDED(mInfo->GetTypeForParam(methodIndex, &param,
                                                          1, &datum_type)) &&
                      datum_type.IsPointer() &&
                      GetArraySizeFromParam(cx, info, param, methodIndex,
                                            k, GET_LENGTH, nativeParams,
                                            &array_count) && array_count)
                   {
                       CleanupPointerArray(datum_type, array_count, pp);
                   }
                   nsMemory::Free(pp);
               }
           }
           else
               CleanupPointerTypeObject(type, (void**)p);
           *((void**)p) = nsnull;
       }
   }
   else
   {
       // set to whatever the JS code might have set as the result
       retval = pending_result;
   }
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 61: 4 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.849 | CED: 2 | FED: 4 (3.1%) | SZ: 127 | XF: F | XP: F | D: 3
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\modules\libpref\src\nsprefbranch.cpp 297:16 -> 322:4
   -------------------------------------------------------------------------
   const char *pref = getPrefName(aPrefName);
   PRBool  bNeedDefault = PR_FALSE;
   
   if (mIsDefault) {
     bNeedDefault = PR_TRUE;
   } else {
     // if there is no user (or locked) value
     if (!PREF_HasUserPref(pref) && !PREF_PrefIsLocked(pref)) {
       bNeedDefault = PR_TRUE;
     }
   }
   
   // if we need to fetch the default value, do that instead, otherwise use the
   // value we pulled in at the top of this function
   if (bNeedDefault) {
     nsXPIDLString utf16String;
     rv = GetDefaultFromPropertiesFile(pref, getter_Copies(utf16String));
     if (NS_SUCCEEDED(rv)) {
       theString->SetData(utf16String.get());
     }
   } else {
     rv = GetCharPref(aPrefName, getter_Copies(utf8String));
     if (NS_SUCCEEDED(rv)) {
       theString->SetData(NS_ConvertUTF8toUTF16(utf8String).get());
     }
   }
   -------------------------------------------------------------------------
   Potentially buggy differences:
2|     rv = theString->SetData(utf16String.get());
>      ^^ ^

2|     rv = theString->SetData(NS_ConvertUTF8toUTF16(utf8String).get());
>      ^^ ^
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\modules\libpref\src\nsprefbranch.cpp 325:18 -> 350:6
   -------------------------------------------------------------------------
   const char *pref = getPrefName(aPrefName);
   PRBool  bNeedDefault = PR_FALSE;
   
   if (mIsDefault) {
     bNeedDefault = PR_TRUE;
   } else {
     // if there is no user (or locked) value
     if (!PREF_HasUserPref(pref) && !PREF_PrefIsLocked(pref)) {
       bNeedDefault = PR_TRUE;
     }
   }
   
   // if we need to fetch the default value, do that instead, otherwise use the
   // value we pulled in at the top of this function
   if (bNeedDefault) {
     nsXPIDLString utf16String;
     rv = GetDefaultFromPropertiesFile(pref, getter_Copies(utf16String));
     if (NS_SUCCEEDED(rv)) {
       rv = theString->SetData(utf16String.get());
     }
   } else {
     rv = GetCharPref(aPrefName, getter_Copies(utf8String));
     if (NS_SUCCEEDED(rv)) {
       rv = theString->SetData(NS_ConvertUTF8toUTF16(utf8String).get());
     }
   }
   -------------------------------------------------------------------------

 Pair b.) TxtSim: 0.849 | CED: 2 | FED: 4 (3.1%) | SZ: 127 | XF: T | XP: T | D: inf
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\modules\libpref\src\nsprefbranch.cpp 297:16 -> 322:4
   -------------------------------------------------------------------------
   const char *pref = getPrefName(aPrefName);
   PRBool  bNeedDefault = PR_FALSE;
   
   if (mIsDefault) {
     bNeedDefault = PR_TRUE;
   } else {
     // if there is no user (or locked) value
     if (!PREF_HasUserPref(pref) && !PREF_PrefIsLocked(pref)) {
       bNeedDefault = PR_TRUE;
     }
   }
   
   // if we need to fetch the default value, do that instead, otherwise use the
   // value we pulled in at the top of this function
   if (bNeedDefault) {
     nsXPIDLString utf16String;
     rv = GetDefaultFromPropertiesFile(pref, getter_Copies(utf16String));
     if (NS_SUCCEEDED(rv)) {
       theString->SetData(utf16String.get());
     }
   } else {
     rv = GetCharPref(aPrefName, getter_Copies(utf8String));
     if (NS_SUCCEEDED(rv)) {
       theString->SetData(NS_ConvertUTF8toUTF16(utf8String).get());
     }
   }
   -------------------------------------------------------------------------
   Potentially buggy differences:
2|     rv = theString->SetData(utf16String.get());
>      ^^ ^

2|     rv = theString->SetData(NS_ConvertUTF8toUTF16(utf8String).get());
>      ^^ ^
   -------------------------------------------------------------------------
   c:\mozilla-central\modules\libpref\src\nsprefbranch.cpp 325:18 -> 350:6
   -------------------------------------------------------------------------
   const char *pref = getPrefName(aPrefName);
   PRBool  bNeedDefault = PR_FALSE;
   
   if (mIsDefault) {
     bNeedDefault = PR_TRUE;
   } else {
     // if there is no user (or locked) value
     if (!PREF_HasUserPref(pref) && !PREF_PrefIsLocked(pref)) {
       bNeedDefault = PR_TRUE;
     }
   }
   
   // if we need to fetch the default value, do that instead, otherwise use the
   // value we pulled in at the top of this function
   if (bNeedDefault) {
     nsXPIDLString utf16String;
     rv = GetDefaultFromPropertiesFile(pref, getter_Copies(utf16String));
     if (NS_SUCCEEDED(rv)) {
       rv = theString->SetData(utf16String.get());
     }
   } else {
     rv = GetCharPref(aPrefName, getter_Copies(utf8String));
     if (NS_SUCCEEDED(rv)) {
       rv = theString->SetData(NS_ConvertUTF8toUTF16(utf8String).get());
     }
   }
   -------------------------------------------------------------------------

 Pair c.) TxtSim: 0.849 | CED: 2 | FED: 4 (3.1%) | SZ: 127 | XF: T | XP: T | D: inf
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\modules\libpref\src\nsprefbranch.cpp 325:18 -> 350:6
   -------------------------------------------------------------------------
   const char *pref = getPrefName(aPrefName);
   PRBool  bNeedDefault = PR_FALSE;
   
   if (mIsDefault) {
     bNeedDefault = PR_TRUE;
   } else {
     // if there is no user (or locked) value
     if (!PREF_HasUserPref(pref) && !PREF_PrefIsLocked(pref)) {
       bNeedDefault = PR_TRUE;
     }
   }
   
   // if we need to fetch the default value, do that instead, otherwise use the
   // value we pulled in at the top of this function
   if (bNeedDefault) {
     nsXPIDLString utf16String;
     rv = GetDefaultFromPropertiesFile(pref, getter_Copies(utf16String));
     if (NS_SUCCEEDED(rv)) {
       rv = theString->SetData(utf16String.get());
     }
   } else {
     rv = GetCharPref(aPrefName, getter_Copies(utf8String));
     if (NS_SUCCEEDED(rv)) {
       rv = theString->SetData(NS_ConvertUTF8toUTF16(utf8String).get());
     }
   }
   -------------------------------------------------------------------------
   Potentially buggy differences:
1|     rv = theString->SetData(utf16String.get());
>      ^^ ^

1|     rv = theString->SetData(NS_ConvertUTF8toUTF16(utf8String).get());
>      ^^ ^
   -------------------------------------------------------------------------
   c:\mozilla-central\modules\libpref\src\nsprefbranch.cpp 297:16 -> 322:4
   -------------------------------------------------------------------------
   const char *pref = getPrefName(aPrefName);
   PRBool  bNeedDefault = PR_FALSE;
   
   if (mIsDefault) {
     bNeedDefault = PR_TRUE;
   } else {
     // if there is no user (or locked) value
     if (!PREF_HasUserPref(pref) && !PREF_PrefIsLocked(pref)) {
       bNeedDefault = PR_TRUE;
     }
   }
   
   // if we need to fetch the default value, do that instead, otherwise use the
   // value we pulled in at the top of this function
   if (bNeedDefault) {
     nsXPIDLString utf16String;
     rv = GetDefaultFromPropertiesFile(pref, getter_Copies(utf16String));
     if (NS_SUCCEEDED(rv)) {
       theString->SetData(utf16String.get());
     }
   } else {
     rv = GetCharPref(aPrefName, getter_Copies(utf8String));
     if (NS_SUCCEEDED(rv)) {
       theString->SetData(NS_ConvertUTF8toUTF16(utf8String).get());
     }
   }
   -------------------------------------------------------------------------

 Pair d.) TxtSim: 0.849 | CED: 2 | FED: 4 (3.1%) | SZ: 127 | XF: F | XP: F | D: 3
   -------------------------------------------------------------------------
   c:\mozilla-central\modules\libpref\src\nsprefbranch.cpp 297:16 -> 322:4
   -------------------------------------------------------------------------
   const char *pref = getPrefName(aPrefName);
   PRBool  bNeedDefault = PR_FALSE;
   
   if (mIsDefault) {
     bNeedDefault = PR_TRUE;
   } else {
     // if there is no user (or locked) value
     if (!PREF_HasUserPref(pref) && !PREF_PrefIsLocked(pref)) {
       bNeedDefault = PR_TRUE;
     }
   }
   
   // if we need to fetch the default value, do that instead, otherwise use the
   // value we pulled in at the top of this function
   if (bNeedDefault) {
     nsXPIDLString utf16String;
     rv = GetDefaultFromPropertiesFile(pref, getter_Copies(utf16String));
     if (NS_SUCCEEDED(rv)) {
       theString->SetData(utf16String.get());
     }
   } else {
     rv = GetCharPref(aPrefName, getter_Copies(utf8String));
     if (NS_SUCCEEDED(rv)) {
       theString->SetData(NS_ConvertUTF8toUTF16(utf8String).get());
     }
   }
   -------------------------------------------------------------------------
   Potentially buggy differences:
2|     rv = theString->SetData(utf16String.get());
>      ^^ ^

2|     rv = theString->SetData(NS_ConvertUTF8toUTF16(utf8String).get());
>      ^^ ^
   -------------------------------------------------------------------------
   c:\mozilla-central\modules\libpref\src\nsprefbranch.cpp 325:18 -> 350:6
   -------------------------------------------------------------------------
   const char *pref = getPrefName(aPrefName);
   PRBool  bNeedDefault = PR_FALSE;
   
   if (mIsDefault) {
     bNeedDefault = PR_TRUE;
   } else {
     // if there is no user (or locked) value
     if (!PREF_HasUserPref(pref) && !PREF_PrefIsLocked(pref)) {
       bNeedDefault = PR_TRUE;
     }
   }
   
   // if we need to fetch the default value, do that instead, otherwise use the
   // value we pulled in at the top of this function
   if (bNeedDefault) {
     nsXPIDLString utf16String;
     rv = GetDefaultFromPropertiesFile(pref, getter_Copies(utf16String));
     if (NS_SUCCEEDED(rv)) {
       rv = theString->SetData(utf16String.get());
     }
   } else {
     rv = GetCharPref(aPrefName, getter_Copies(utf8String));
     if (NS_SUCCEEDED(rv)) {
       rv = theString->SetData(NS_ConvertUTF8toUTF16(utf8String).get());
     }
   }
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 62: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.545 | CED: 1 | FED: 9 (10.8%) | SZ: 83 | XF: T | XP: F | D: inf
   -------------------------------------------------------------------------
   c:\mozilla-central\browser\components\migration\src\nsdogbertprofilemigrator.cpp 141:11 -> 159:2
   -------------------------------------------------------------------------
   nsresult rv = NS_OK;
   PRBool aReplace = aStartup ? PR_TRUE : PR_FALSE;
   
   if (!mTargetProfile) {
     GetProfilePath(aStartup, mTargetProfile);
     if (!mTargetProfile) return NS_ERROR_FAILURE;
   }
   
   if (!mSourceProfile) {
     GetSourceProfile(aProfile);
     if (!mSourceProfile)
       return NS_ERROR_FAILURE;
   }
   
   NOTIFY_OBSERVERS(MIGRATION_STARTED, nsnull);
   
   COPY_DATA(CopyPreferences,  aReplace, nsIBrowserProfileMigrator::SETTINGS);
   COPY_DATA(CopyCookies,      aReplace, nsIBrowserProfileMigrator::COOKIES);
   COPY_DATA(CopyBookmarks,    aReplace, nsIBrowserProfileMigrator::BOOKMARKS);
   -------------------------------------------------------------------------
   Potentially buggy differences:
1|   if (!mSourceProfile)
>    ^^ ^^^^^^^^^^^^^^^^^
1|     return NS_ERROR_FAILURE;
>      ^^^^^^ ^^^^^^^^^^^^^^^^
1| }
>  ^
   -------------------------------------------------------------------------
   c:\mozilla-central\browser\components\migration\src\nsseamonkeyprofilemigrator.cpp 89:11 -> 103:2
   -------------------------------------------------------------------------
   nsresult rv = NS_OK;
   PRBool aReplace = aStartup ? PR_TRUE : PR_FALSE;
   
   if (!mTargetProfile) {
     GetProfilePath(aStartup, mTargetProfile);
     if (!mTargetProfile) return NS_ERROR_FAILURE;
   }
   if (!mSourceProfile)
     GetSourceProfile(aProfile);
   
   NOTIFY_OBSERVERS(MIGRATION_STARTED, nsnull);
   
   COPY_DATA(CopyPreferences,  aReplace, nsIBrowserProfileMigrator::SETTINGS);
   COPY_DATA(CopyCookies,      aReplace, nsIBrowserProfileMigrator::COOKIES);
   COPY_DATA(CopyHistory,      aReplace, nsIBrowserProfileMigrator::HISTORY);
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 63: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.576 | CED: 2 | FED: 17 (17.0%) | SZ: 100 | XF: F | XP: F | D: 5
   -------------------------------------------------------------------------
   c:\comm-central\mailnews\local\src\nsparsemailbox.cpp 2163:19 -> 2183:10
   -------------------------------------------------------------------------
   PRUint32 flags = 0;
   nsCOMPtr <nsIMsgFolder> downloadFolder;
   msgHdr->GetFolder(getter_AddRefs(downloadFolder));
   nsCOMPtr <nsIMsgLocalMailFolder> localFolder = do_QueryInterface(downloadFolder);
   msgHdr->GetFlags(&flags);
   if (localFolder)
   {
     nsCOMPtr<nsIMutableArray> messages = do_CreateInstance(NS_ARRAY_CONTRACTID, &rv);
     NS_ENSURE_SUCCESS(rv, rv);
     messages->AppendElement(msgHdr, PR_FALSE);
     // This action ignores the deleteMailLeftOnServer preference
     localFolder->MarkMsgsOnPop3Server(messages, POP3_FORCE_DEL);
   
     // If this is just a header, throw it away. It's useless now
     // that the server copy is being deleted.
     if (flags & nsMsgMessageFlags::Partial)
     {
       m_msgMovedByFilter = PR_TRUE;
       msgIsNew = PR_FALSE;
     }
   }
   -------------------------------------------------------------------------
   Potentially buggy differences:
2| if (localFolder && (flags & nsMsgMessageFlags::Partial))
>                  ^^ ^^^^^^ ^ ^^^^^^^^^^^^^^^^^^^^^^^^^^^

1|   if (flags & nsMsgMessageFlags::Partial)
>    ^^ ^^^^^^ ^ ^^^^^^^^^^^^^^^^^^^^^^^^^^^
1|   {
>    ^
   -------------------------------------------------------------------------
   c:\comm-central\mailnews\local\src\nsparsemailbox.cpp 2188:19 -> 2206:10
   -------------------------------------------------------------------------
   PRUint32 flags = 0;
   nsCOMPtr <nsIMsgFolder> downloadFolder;
   msgHdr->GetFolder(getter_AddRefs(downloadFolder));
   nsCOMPtr <nsIMsgLocalMailFolder> localFolder = do_QueryInterface(downloadFolder);
   msgHdr->GetFlags(&flags);
   if (localFolder && (flags & nsMsgMessageFlags::Partial))
   {
     nsCOMPtr<nsIMutableArray> messages = do_CreateInstance(NS_ARRAY_CONTRACTID, &rv);
     NS_ENSURE_SUCCESS(rv, rv);
     messages->AppendElement(msgHdr, PR_FALSE);
     localFolder->MarkMsgsOnPop3Server(messages, POP3_FETCH_BODY);
     // Don't add this header to the DB, we're going to replace it
     // with the full message.
     m_msgMovedByFilter = PR_TRUE;
     msgIsNew = PR_FALSE;
     // Don't do anything else in this filter, wait until we
     // have the full message.
     *applyMore = PR_FALSE;
   }
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 64: 4 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.584 | CED: 1 | FED: 3 (4.7%) | SZ: 64 | XF: T | XP: F | D: inf
   -------------------------------------------------------------------------
   c:\mozilla-central\dom\plugins\pluginscriptableobjectchild.cpp 189:2 -> 203:2
   -------------------------------------------------------------------------
   NS_ASSERTION(actor->Type() == Proxy, "Bad type!");
   
   ProtectedVariantArray args(aArgs, aArgCount, actor->GetInstance());
   if (!args.IsOk()) {
     NS_ERROR("Failed to convert arguments!");
     return false;
   }
   
   Variant remoteResult;
   bool success;
   actor->CallInvokeDefault(args, &remoteResult, &success);
   
   if (!success) {
     return false;
   }
   -------------------------------------------------------------------------
   Potentially buggy differences:
2| if (!actor->CallInvokeDefault(args, &remoteResult, &success)) {
>  ^^ ^^
   -------------------------------------------------------------------------
   c:\mozilla-central\dom\plugins\pluginscriptableobjectparent.cpp 257:2 -> 270:2
   -------------------------------------------------------------------------
   NS_ASSERTION(actor->Type() == Proxy, "Bad type!");
   
   ProtectedVariantArray args(aArgs, aArgCount, actor->GetInstance());
   if (!args.IsOk()) {
     NS_ERROR("Failed to convert arguments!");
     return false;
   }
   
   Variant remoteResult;
   bool success;
   if (!actor->CallInvokeDefault(args, &remoteResult, &success)) {
     NS_WARNING("Failed to send message!");
     return false;
   }
   -------------------------------------------------------------------------

 Pair b.) TxtSim: 0.533 | CED: 1 | FED: 3 (4.7%) | SZ: 64 | XF: T | XP: F | D: inf
   -------------------------------------------------------------------------
   c:\mozilla-central\dom\plugins\pluginscriptableobjectchild.cpp 189:2 -> 203:2
   -------------------------------------------------------------------------
   NS_ASSERTION(actor->Type() == Proxy, "Bad type!");
   
   ProtectedVariantArray args(aArgs, aArgCount, actor->GetInstance());
   if (!args.IsOk()) {
     NS_ERROR("Failed to convert arguments!");
     return false;
   }
   
   Variant remoteResult;
   bool success;
   actor->CallInvokeDefault(args, &remoteResult, &success);
   
   if (!success) {
     return false;
   }
   -------------------------------------------------------------------------
   Potentially buggy differences:
2| if (!actor->CallConstruct(args, &remoteResult, &success)) {
>  ^^ ^^
   -------------------------------------------------------------------------
   c:\mozilla-central\dom\plugins\pluginscriptableobjectparent.cpp 496:2 -> 509:2
   -------------------------------------------------------------------------
   NS_ASSERTION(actor->Type() == Proxy, "Bad type!");
   
   ProtectedVariantArray args(aArgs, aArgCount, actor->GetInstance());
   if (!args.IsOk()) {
     NS_ERROR("Failed to convert arguments!");
     return false;
   }
   
   Variant remoteResult;
   bool success;
   if (!actor->CallConstruct(args, &remoteResult, &success)) {
     NS_WARNING("Failed to send message!");
     return false;
   }
   -------------------------------------------------------------------------

 Pair c.) TxtSim: 0.533 | CED: 1 | FED: 3 (4.7%) | SZ: 64 | XF: T | XP: F | D: inf
   -------------------------------------------------------------------------
   c:\mozilla-central\dom\plugins\pluginscriptableobjectchild.cpp 405:2 -> 419:2
   -------------------------------------------------------------------------
   NS_ASSERTION(actor->Type() == Proxy, "Bad type!");
   
   ProtectedVariantArray args(aArgs, aArgCount, actor->GetInstance());
   if (!args.IsOk()) {
     NS_ERROR("Failed to convert arguments!");
     return false;
   }
   
   Variant remoteResult;
   bool success;
   actor->CallConstruct(args, &remoteResult, &success);
   
   if (!success) {
     return false;
   }
   -------------------------------------------------------------------------
   Potentially buggy differences:
2| if (!actor->CallInvokeDefault(args, &remoteResult, &success)) {
>  ^^ ^^
   -------------------------------------------------------------------------
   c:\mozilla-central\dom\plugins\pluginscriptableobjectparent.cpp 257:2 -> 270:2
   -------------------------------------------------------------------------
   NS_ASSERTION(actor->Type() == Proxy, "Bad type!");
   
   ProtectedVariantArray args(aArgs, aArgCount, actor->GetInstance());
   if (!args.IsOk()) {
     NS_ERROR("Failed to convert arguments!");
     return false;
   }
   
   Variant remoteResult;
   bool success;
   if (!actor->CallInvokeDefault(args, &remoteResult, &success)) {
     NS_WARNING("Failed to send message!");
     return false;
   }
   -------------------------------------------------------------------------

 Pair d.) TxtSim: 0.584 | CED: 1 | FED: 3 (4.7%) | SZ: 64 | XF: T | XP: F | D: inf
   -------------------------------------------------------------------------
   c:\mozilla-central\dom\plugins\pluginscriptableobjectchild.cpp 405:2 -> 419:2
   -------------------------------------------------------------------------
   NS_ASSERTION(actor->Type() == Proxy, "Bad type!");
   
   ProtectedVariantArray args(aArgs, aArgCount, actor->GetInstance());
   if (!args.IsOk()) {
     NS_ERROR("Failed to convert arguments!");
     return false;
   }
   
   Variant remoteResult;
   bool success;
   actor->CallConstruct(args, &remoteResult, &success);
   
   if (!success) {
     return false;
   }
   -------------------------------------------------------------------------
   Potentially buggy differences:
2| if (!actor->CallConstruct(args, &remoteResult, &success)) {
>  ^^ ^^
   -------------------------------------------------------------------------
   c:\mozilla-central\dom\plugins\pluginscriptableobjectparent.cpp 496:2 -> 509:2
   -------------------------------------------------------------------------
   NS_ASSERTION(actor->Type() == Proxy, "Bad type!");
   
   ProtectedVariantArray args(aArgs, aArgCount, actor->GetInstance());
   if (!args.IsOk()) {
     NS_ERROR("Failed to convert arguments!");
     return false;
   }
   
   Variant remoteResult;
   bool success;
   if (!actor->CallConstruct(args, &remoteResult, &success)) {
     NS_WARNING("Failed to send message!");
     return false;
   }
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 65: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.512 | CED: 1 | FED: 2 (2.1%) | SZ: 96 | XF: F | XP: F | D: 3
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\layout\base\nsbidipresutils.cpp 1136:34 -> 1157:0
   -------------------------------------------------------------------------
   nsBidiPresUtils::GetFrameToRightOf(const nsIFrame*  aFrame,
                                      nsIFrame*        aFirstFrameOnLine,
                                      PRInt32          aNumFramesOnLine)
   {
     InitLogicalArrayFromLine(aFirstFrameOnLine, aNumFramesOnLine);
   
     PRBool isReordered;
     PRBool hasRTLFrames;
     Reorder(isReordered, hasRTLFrames);
     PRInt32 count = mVisualFrames.Length();
   
     if (aFrame == nsnull)
       return mVisualFrames[0];
   
     for (PRInt32 i = 0; i < count - 1; i++) {
       if (mVisualFrames[i] == aFrame) {
         return mVisualFrames[i+1];
       }
     }
   
     return nsnull;
   }
   -------------------------------------------------------------------------
   Potentially buggy differences:
2|     return mVisualFrames[count-1];
>                           ^^^^^^
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\layout\base\nsbidipresutils.cpp 1160:33 -> 1181:0
   -------------------------------------------------------------------------
   nsBidiPresUtils::GetFrameToLeftOf(const nsIFrame*  aFrame,
                                     nsIFrame*        aFirstFrameOnLine,
                                     PRInt32          aNumFramesOnLine)
   {
     InitLogicalArrayFromLine(aFirstFrameOnLine, aNumFramesOnLine);
   
     PRBool isReordered;
     PRBool hasRTLFrames;
     Reorder(isReordered, hasRTLFrames);
     PRInt32 count = mVisualFrames.Length();
   
     if (aFrame == nsnull)
       return mVisualFrames[count-1];
   
     for (PRInt32 i = 1; i < count; i++) {
       if (mVisualFrames[i] == aFrame) {
         return mVisualFrames[i-1];
       }
     }
   
     return nsnull;
   }
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 66: 2 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.531 | CED: 1 | FED: 6 (8.5%) | SZ: 71 | XF: F | XP: F | D: 67
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\layout\xul\base\src\grid\nsgridlayout2.cpp 156:4 -> 168:34
   -------------------------------------------------------------------------
   if (!columnsBox) {
     // max height is the sum of our rows
     PRInt32 columns = mGrid.GetColumnCount();
     for (PRInt32 i=0; i < columns; i++)
     {
       nscoord width = mGrid.GetMinRowHeight(aState, i, PR_FALSE);
       AddWidth(total, width, PR_TRUE); // AddWidth
     }
   }
   
   AddMargin(aBox, total);
   AddOffset(aState, aBox, total);
   AddLargestSize(minSize, total);
   -------------------------------------------------------------------------
   Potentially buggy differences:
2|   total.width = 0;
>    ^^^^^^^^^^^ ^ ^
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\layout\xul\base\src\grid\nsgridlayout2.cpp 235:4 -> 248:35
   -------------------------------------------------------------------------
   if (!columnsBox) {
     total.width = 0;
     // max height is the sum of our rows
     PRInt32 columns = mGrid.GetColumnCount();
     for (PRInt32 i=0; i < columns; i++)
     {
       nscoord width = mGrid.GetMaxRowHeight(aState, i, PR_FALSE);
       AddWidth(total, width, PR_TRUE); // AddWidth
     }
   }
   
   AddMargin(aBox, total);
   AddOffset(aState, aBox, total);
   AddSmallestSize(maxSize, total);
   -------------------------------------------------------------------------

 Pair b.) TxtSim: 0.531 | CED: 1 | FED: 6 (8.5%) | SZ: 71 | XF: F | XP: F | D: 28
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\layout\xul\base\src\grid\nsgridlayout2.cpp 195:4 -> 207:31
   -------------------------------------------------------------------------
   if (!columnsBox) {
     // max height is the sum of our rows
     PRInt32 columns = mGrid.GetColumnCount();
     for (PRInt32 i=0; i < columns; i++)
     {
       nscoord width = mGrid.GetPrefRowHeight(aState, i, PR_FALSE);
       AddWidth(total, width, PR_TRUE); // AddWidth
     }
   }
   
   AddMargin(aBox, total);
   AddOffset(aState, aBox, total);
   AddLargestSize(pref, total);
   -------------------------------------------------------------------------
   Potentially buggy differences:
2|   total.width = 0;
>    ^^^^^^^^^^^ ^ ^
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\layout\xul\base\src\grid\nsgridlayout2.cpp 235:4 -> 248:35
   -------------------------------------------------------------------------
   if (!columnsBox) {
     total.width = 0;
     // max height is the sum of our rows
     PRInt32 columns = mGrid.GetColumnCount();
     for (PRInt32 i=0; i < columns; i++)
     {
       nscoord width = mGrid.GetMaxRowHeight(aState, i, PR_FALSE);
       AddWidth(total, width, PR_TRUE); // AddWidth
     }
   }
   
   AddMargin(aBox, total);
   AddOffset(aState, aBox, total);
   AddSmallestSize(maxSize, total);
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 67: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.868 | CED: 1 | FED: 9 (4.5%) | SZ: 198 | XF: T | XP: T | D: inf
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\content\canvas\src\webglcontextgl.cpp 889:4 -> 931:4
   -------------------------------------------------------------------------
   if (!ValidateDrawModeEnum(mode, "drawElements: mode"))
       return NS_OK;
   
   if (count < 0 || byteOffset < 0)
       return ErrorInvalidValue("DrawElements: negative count or offset");
   
   CheckedUint32 checked_byteCount;
   
   if (type == LOCAL_GL_UNSIGNED_SHORT) {
       checked_byteCount = 2 * CheckedUint32(count);
       if (byteOffset % 2 != 0)
           return ErrorInvalidValue("DrawElements: invalid byteOffset for UNSIGNED_SHORT (must be a multiple of 2)");
   } else if (type == LOCAL_GL_UNSIGNED_BYTE) {
       checked_byteCount = count;
   } else {
       return ErrorInvalidEnum("DrawElements: type must be UNSIGNED_SHORT or UNSIGNED_BYTE");
   }
   
   if (!checked_byteCount.valid())
       return ErrorInvalidValue("DrawElements: overflow in byteCount");
   
   // If there is no current program, this is silently ignored.
   // Any checks below this depend on a program being available.
   if (!mCurrentProgram)
       return NS_OK;
   
   if (!mBoundElementArrayBuffer)
       return ErrorInvalidOperation("DrawElements: must have element array buffer binding");
   
   CheckedUint32 checked_neededByteCount = checked_byteCount + byteOffset;
   
   if (!checked_neededByteCount.valid())
       return ErrorInvalidOperation("DrawElements: overflow in byteOffset+byteCount");
   
   if (checked_neededByteCount.value() > mBoundElementArrayBuffer->ByteLength())
       return ErrorInvalidOperation("DrawElements: bound element array buffer is too small for given count and offset");
   
   WebGLuint maxIndex = 0;
   if (type == LOCAL_GL_UNSIGNED_SHORT) {
       maxIndex = mBoundElementArrayBuffer->FindMaximum<GLushort>(count, byteOffset);
   } else if (type == LOCAL_GL_UNSIGNED_BYTE) {
       maxIndex = mBoundElementArrayBuffer->FindMaximum<GLubyte>(count, byteOffset);
   }
   -------------------------------------------------------------------------
   Potentially buggy differences:
2| if (count == 0)
>  ^^ ^^^^^^ ^^ ^^
2|     return NS_OK;
>      ^^^^^^ ^^^^^
   -------------------------------------------------------------------------
   c:\mozilla-central\content\canvas\src\webglcontextgl.cpp 916:4 -> 959:4
   -------------------------------------------------------------------------
   if (count < 0 || byteOffset < 0)
       return ErrorInvalidValue("DrawElements: negative count or offset");
   
   CheckedUint32 checked_byteCount;
   
   if (type == LOCAL_GL_UNSIGNED_SHORT) {
       checked_byteCount = 2 * CheckedUint32(count);
       if (byteOffset % 2 != 0)
           return ErrorInvalidValue("DrawElements: invalid byteOffset for UNSIGNED_SHORT (must be a multiple of 2)");
   } else if (type == LOCAL_GL_UNSIGNED_BYTE) {
       checked_byteCount = count;
   } else {
       return ErrorInvalidEnum("DrawElements: type must be UNSIGNED_SHORT or UNSIGNED_BYTE");
   }
   
   if (!checked_byteCount.valid())
       return ErrorInvalidValue("DrawElements: overflow in byteCount");
   
   // If count is 0, there's nothing to do.
   if (count == 0)
       return NS_OK;
   
   // If there is no current program, this is silently ignored.
   // Any checks below this depend on a program being available.
   if (!mCurrentProgram)
       return NS_OK;
   
   if (!mBoundElementArrayBuffer)
       return ErrorInvalidOperation("DrawElements: must have element array buffer binding");
   
   CheckedUint32 checked_neededByteCount = checked_byteCount + byteOffset;
   
   if (!checked_neededByteCount.valid())
       return ErrorInvalidOperation("DrawElements: overflow in byteOffset+byteCount");
   
   if (checked_neededByteCount.value() > mBoundElementArrayBuffer->ByteLength())
       return ErrorInvalidOperation("DrawElements: bound element array buffer is too small for given count and offset");
   
   WebGLuint maxIndex = 0;
   if (type == LOCAL_GL_UNSIGNED_SHORT) {
       maxIndex = mBoundElementArrayBuffer->FindMaximum<GLushort>(count, byteOffset);
   } else if (type == LOCAL_GL_UNSIGNED_BYTE) {
       maxIndex = mBoundElementArrayBuffer->FindMaximum<GLubyte>(count, byteOffset);
   }
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 68: 2 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.679 | CED: 1 | FED: 3 (0.8%) | SZ: 358 | XF: F | XP: F | D: 301
   -------------------------------------------------------------------------
   c:\mozilla-central\dom\plugins\pluginscriptableobjectparent.cpp 737:2 -> 812:13
   -------------------------------------------------------------------------
   if (!mObject) {
     NS_WARNING("Calling AnswerInvoke with an invalidated object!");
     *aResult = void_t();
     *aSuccess = false;
     return true;
   }
   
   NS_ASSERTION(mObject->_class != GetClass(), "Bad object type!");
   NS_ASSERTION(mType == LocalObject, "Bad type!");
   
   PluginInstanceParent* instance = GetInstance();
   if (!instance) {
     NS_ERROR("No instance?!");
     *aResult = void_t();
     *aSuccess = false;
     return true;
   }
   
   const NPNetscapeFuncs* npn = GetNetscapeFuncs(instance);
   if (!npn) {
     NS_ERROR("No netscape funcs?!");
     *aResult = void_t();
     *aSuccess = false;
     return true;
   }
   
   nsAutoTArray<NPVariant, 10> convertedArgs;
   PRUint32 argCount = aArgs.Length();
   
   if (!convertedArgs.SetLength(argCount)) {
     *aResult = void_t();
     *aSuccess = false;
     return true;
   }
   
   for (PRUint32 index = 0; index < argCount; index++) {
     if (!ConvertToVariant(aArgs[index], convertedArgs[index], instance)) {
       // Don't leak things we've already converted!
       while (index-- > 0) {
         ReleaseVariant(convertedArgs[index], instance);
       }
       *aResult = void_t();
       *aSuccess = false;
       return true;
     }
   }
   
   PluginIdentifierParent* id = static_cast<PluginIdentifierParent*>(aId);
   NPVariant result;
   bool success = npn->invoke(instance->GetNPP(), mObject, id->ToNPIdentifier(),
                              convertedArgs.Elements(), argCount, &result);
   
   for (PRUint32 index = 0; index < argCount; index++) {
     ReleaseVariant(convertedArgs[index], instance);
   }
   
   if (!success) {
     *aResult = void_t();
     *aSuccess = false;
     return true;
   }
   
   Variant convertedResult;
   success = ConvertToRemoteVariant(result, convertedResult, GetInstance());
   
   DeferNPVariantLastRelease(npn, &result);
   
   if (!success) {
     *aResult = void_t();
     *aSuccess = false;
     return true;
   }
   
   *aResult = convertedResult;
   *aSuccess = true;
   return true;
   -------------------------------------------------------------------------
   Potentially buggy differences:
1| success = ConvertToRemoteVariant(result, convertedResult, GetInstance());
>                                                            -------------
2| success = ConvertToRemoteVariant(result, convertedResult, instance);
>                                                            --------
   -------------------------------------------------------------------------
   c:\mozilla-central\dom\plugins\pluginscriptableobjectparent.cpp 1113:2 -> 1187:13
   -------------------------------------------------------------------------
   if (!mObject) {
     NS_WARNING("Calling AnswerConstruct with an invalidated object!");
     *aResult = void_t();
     *aSuccess = false;
     return true;
   }
   
   NS_ASSERTION(mObject->_class != GetClass(), "Bad object type!");
   NS_ASSERTION(mType == LocalObject, "Bad type!");
   
   PluginInstanceParent* instance = GetInstance();
   if (!instance) {
     NS_ERROR("No instance?!");
     *aResult = void_t();
     *aSuccess = false;
     return true;
   }
   
   const NPNetscapeFuncs* npn = GetNetscapeFuncs(instance);
   if (!npn) {
     NS_ERROR("No netscape funcs?!");
     *aResult = void_t();
     *aSuccess = false;
     return true;
   }
   
   nsAutoTArray<NPVariant, 10> convertedArgs;
   PRUint32 argCount = aArgs.Length();
   
   if (!convertedArgs.SetLength(argCount)) {
     *aResult = void_t();
     *aSuccess = false;
     return true;
   }
   
   for (PRUint32 index = 0; index < argCount; index++) {
     if (!ConvertToVariant(aArgs[index], convertedArgs[index], instance)) {
       // Don't leak things we've already converted!
       while (index-- > 0) {
         ReleaseVariant(convertedArgs[index], instance);
       }
       *aResult = void_t();
       *aSuccess = false;
       return true;
     }
   }
   
   NPVariant result;
   bool success = npn->construct(instance->GetNPP(), mObject,
                                 convertedArgs.Elements(), argCount, &result);
   
   for (PRUint32 index = 0; index < argCount; index++) {
     ReleaseVariant(convertedArgs[index], instance);
   }
   
   if (!success) {
     *aResult = void_t();
     *aSuccess = false;
     return true;
   }
   
   Variant convertedResult;
   success = ConvertToRemoteVariant(result, convertedResult, instance);
   
   DeferNPVariantLastRelease(npn, &result);
   
   if (!success) {
     *aResult = void_t();
     *aSuccess = false;
     return true;
   }
   
   *aSuccess = true;
   *aResult = convertedResult;
   return true;
   -------------------------------------------------------------------------

 Pair b.) TxtSim: 0.781 | CED: 1 | FED: 3 (0.8%) | SZ: 358 | XF: F | XP: F | D: 218
   -------------------------------------------------------------------------
   c:\mozilla-central\dom\plugins\pluginscriptableobjectparent.cpp 820:2 -> 895:13
   -------------------------------------------------------------------------
   if (!mObject) {
     NS_WARNING("Calling AnswerInvoke with an invalidated object!");
     *aResult = void_t();
     *aSuccess = false;
     return true;
   }
   
   NS_ASSERTION(mObject->_class != GetClass(), "Bad object type!");
   NS_ASSERTION(mType == LocalObject, "Bad type!");
   
   PluginInstanceParent* instance = GetInstance();
   if (!instance) {
     NS_ERROR("No instance?!");
     *aResult = void_t();
     *aSuccess = false;
     return true;
   }
   
   const NPNetscapeFuncs* npn = GetNetscapeFuncs(instance);
   if (!npn) {
     NS_ERROR("No netscape funcs?!");
     *aResult = void_t();
     *aSuccess = false;
     return true;
   }
   
   nsAutoTArray<NPVariant, 10> convertedArgs;
   PRUint32 argCount = aArgs.Length();
   
   if (!convertedArgs.SetLength(argCount)) {
     *aResult = void_t();
     *aSuccess = false;
     return true;
   }
   
   for (PRUint32 index = 0; index < argCount; index++) {
     if (!ConvertToVariant(aArgs[index], convertedArgs[index], instance)) {
       // Don't leak things we've already converted!
       while (index-- > 0) {
         ReleaseVariant(convertedArgs[index], instance);
       }
       *aResult = void_t();
       *aSuccess = false;
       return true;
     }
   }
   
   NPVariant result;
   bool success = npn->invokeDefault(instance->GetNPP(), mObject,
                                     convertedArgs.Elements(), argCount,
                                     &result);
   
   for (PRUint32 index = 0; index < argCount; index++) {
     ReleaseVariant(convertedArgs[index], instance);
   }
   
   if (!success) {
     *aResult = void_t();
     *aSuccess = false;
     return true;
   }
   
   Variant convertedResult;
   success = ConvertToRemoteVariant(result, convertedResult, GetInstance());
   
   DeferNPVariantLastRelease(npn, &result);
   
   if (!success) {
     *aResult = void_t();
     *aSuccess = false;
     return true;
   }
   
   *aResult = convertedResult;
   *aSuccess = true;
   return true;
   -------------------------------------------------------------------------
   Potentially buggy differences:
1| success = ConvertToRemoteVariant(result, convertedResult, GetInstance());
>                                                            -------------
2| success = ConvertToRemoteVariant(result, convertedResult, instance);
>                                                            --------
   -------------------------------------------------------------------------
   c:\mozilla-central\dom\plugins\pluginscriptableobjectparent.cpp 1113:2 -> 1187:13
   -------------------------------------------------------------------------
   if (!mObject) {
     NS_WARNING("Calling AnswerConstruct with an invalidated object!");
     *aResult = void_t();
     *aSuccess = false;
     return true;
   }
   
   NS_ASSERTION(mObject->_class != GetClass(), "Bad object type!");
   NS_ASSERTION(mType == LocalObject, "Bad type!");
   
   PluginInstanceParent* instance = GetInstance();
   if (!instance) {
     NS_ERROR("No instance?!");
     *aResult = void_t();
     *aSuccess = false;
     return true;
   }
   
   const NPNetscapeFuncs* npn = GetNetscapeFuncs(instance);
   if (!npn) {
     NS_ERROR("No netscape funcs?!");
     *aResult = void_t();
     *aSuccess = false;
     return true;
   }
   
   nsAutoTArray<NPVariant, 10> convertedArgs;
   PRUint32 argCount = aArgs.Length();
   
   if (!convertedArgs.SetLength(argCount)) {
     *aResult = void_t();
     *aSuccess = false;
     return true;
   }
   
   for (PRUint32 index = 0; index < argCount; index++) {
     if (!ConvertToVariant(aArgs[index], convertedArgs[index], instance)) {
       // Don't leak things we've already converted!
       while (index-- > 0) {
         ReleaseVariant(convertedArgs[index], instance);
       }
       *aResult = void_t();
       *aSuccess = false;
       return true;
     }
   }
   
   NPVariant result;
   bool success = npn->construct(instance->GetNPP(), mObject,
                                 convertedArgs.Elements(), argCount, &result);
   
   for (PRUint32 index = 0; index < argCount; index++) {
     ReleaseVariant(convertedArgs[index], instance);
   }
   
   if (!success) {
     *aResult = void_t();
     *aSuccess = false;
     return true;
   }
   
   Variant convertedResult;
   success = ConvertToRemoteVariant(result, convertedResult, instance);
   
   DeferNPVariantLastRelease(npn, &result);
   
   if (!success) {
     *aResult = void_t();
     *aSuccess = false;
     return true;
   }
   
   *aSuccess = true;
   *aResult = convertedResult;
   return true;
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 69: 4 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.696 | CED: 1 | FED: 29 (15.3%) | SZ: 190 | XF: F | XP: F | D: 3
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\content\base\src\nscspservice.cpp 82:22 -> 145:0
   -------------------------------------------------------------------------
   CSPService::ShouldLoad(PRUint32 aContentType,
                          nsIURI *aContentLocation,
                          nsIURI *aRequestOrigin,
                          nsISupports *aRequestContext,
                          const nsACString &aMimeTypeGuess,
                          nsISupports *aExtra,
                          PRInt16 *aDecision)
   {
       if (!aContentLocation)
           return NS_ERROR_FAILURE;
   
   #ifdef PR_LOGGING
       {
           nsCAutoString location;
           aContentLocation->GetSpec(location);
           PR_LOG(gCspPRLog, PR_LOG_DEBUG,
               ("CSPService::ShouldLoad called for %s", location.get()));
       }
   #endif
       // default decision, CSP can revise it if there's a policy to enforce
       *aDecision = nsIContentPolicy::ACCEPT;
   
       // No need to continue processing if CSP is disabled
       if (!sCSPEnabled)
           return NS_OK;
   
       // find the principal of the document that initiated this request and see
       // if it has a CSP policy object
       nsCOMPtr<nsINode> node(do_QueryInterface(aRequestContext));
       nsCOMPtr<nsIPrincipal> principal;
       nsCOMPtr<nsIContentSecurityPolicy> csp;
       if (node) {
           principal = node->NodePrincipal();
           principal->GetCsp(getter_AddRefs(csp));
   
           if (csp) {
   #ifdef PR_LOGGING
               nsAutoString policy;
               csp->GetPolicy(policy);
               PR_LOG(gCspPRLog, PR_LOG_DEBUG,
                       ("Document has CSP: %s",
                        NS_ConvertUTF16toUTF8(policy).get()));
   #endif
               // obtain the enforcement decision
               csp->ShouldLoad(aContentType,
                               aContentLocation,
                               aRequestOrigin,
                               aRequestContext,
                               aMimeTypeGuess,
                               aExtra,
                               aDecision);
           }
       }
   #ifdef PR_LOGGING
       else {
           nsCAutoString uriSpec;
           aContentLocation->GetSpec(uriSpec);
           PR_LOG(gCspPRLog, PR_LOG_DEBUG,
               ("COULD NOT get nsINode for location: %s", uriSpec.get()));
       }
   #endif
   
       return NS_OK;
   }
   -------------------------------------------------------------------------
   Potentially buggy differences:
1|     {
>      ^
1|         nsCAutoString location;
>          ^^^^^^^^^^^^^ ^^^^^^^^
1|         aContentLocation->GetSpec(location);
>          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
1|         PR_LOG(gCspPRLog, PR_LOG_DEBUG,
>          ^^^^^^^^^^^^^^^^^ ^^^^^^^^^^^^^
1|             ("CSPService::ShouldLoad called for %s", location.get()));
>              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ^^^^^^^^^^^^^^^^
1|     }
>      ^
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\content\base\src\nscspservice.cpp 148:25 -> 202:0
   -------------------------------------------------------------------------
   CSPService::ShouldProcess(PRUint32         aContentType,
                             nsIURI           *aContentLocation,
                             nsIURI           *aRequestOrigin,
                             nsISupports      *aRequestContext,
                             const nsACString &aMimeTypeGuess,
                             nsISupports      *aExtra,
                             PRInt16          *aDecision)
   {
       if (!aContentLocation)
           return NS_ERROR_FAILURE;
   
       // default decision is to accept the item
       *aDecision = nsIContentPolicy::ACCEPT;
   
       // No need to continue processing if CSP is disabled
       if (!sCSPEnabled)
           return NS_OK;
   
       // find the nsDocument that initiated this request and see if it has a
       // CSP policy object
       nsCOMPtr<nsINode> node(do_QueryInterface(aRequestContext));
       nsCOMPtr<nsIPrincipal> principal;
       nsCOMPtr<nsIContentSecurityPolicy> csp;
       if (node) {
           principal = node->NodePrincipal();
           principal->GetCsp(getter_AddRefs(csp));
   
           if (csp) {
   #ifdef PR_LOGGING
               nsAutoString policy;
               csp->GetPolicy(policy);
               PR_LOG(gCspPRLog, PR_LOG_DEBUG,
                     ("shouldProcess - document has policy: %s",
                       NS_ConvertUTF16toUTF8(policy).get()));
   #endif
               // obtain the enforcement decision
               csp->ShouldProcess(aContentType,
                                  aContentLocation,
                                  aRequestOrigin,
                                  aRequestContext,
                                  aMimeTypeGuess,
                                  aExtra,
                                  aDecision);
           }
       }
   #ifdef PR_LOGGING
       else {
           nsCAutoString uriSpec;
           aContentLocation->GetSpec(uriSpec);
           PR_LOG(gCspPRLog, PR_LOG_DEBUG,
               ("COULD NOT get nsINode for location: %s", uriSpec.get()));
       }
   #endif
       return NS_OK;
   }
   -------------------------------------------------------------------------

 Pair b.) TxtSim: 0.696 | CED: 1 | FED: 29 (15.3%) | SZ: 190 | XF: T | XP: T | D: inf
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\content\base\src\nscspservice.cpp 82:22 -> 145:0
   -------------------------------------------------------------------------
   CSPService::ShouldLoad(PRUint32 aContentType,
                          nsIURI *aContentLocation,
                          nsIURI *aRequestOrigin,
                          nsISupports *aRequestContext,
                          const nsACString &aMimeTypeGuess,
                          nsISupports *aExtra,
                          PRInt16 *aDecision)
   {
       if (!aContentLocation)
           return NS_ERROR_FAILURE;
   
   #ifdef PR_LOGGING
       {
           nsCAutoString location;
           aContentLocation->GetSpec(location);
           PR_LOG(gCspPRLog, PR_LOG_DEBUG,
               ("CSPService::ShouldLoad called for %s", location.get()));
       }
   #endif
       // default decision, CSP can revise it if there's a policy to enforce
       *aDecision = nsIContentPolicy::ACCEPT;
   
       // No need to continue processing if CSP is disabled
       if (!sCSPEnabled)
           return NS_OK;
   
       // find the principal of the document that initiated this request and see
       // if it has a CSP policy object
       nsCOMPtr<nsINode> node(do_QueryInterface(aRequestContext));
       nsCOMPtr<nsIPrincipal> principal;
       nsCOMPtr<nsIContentSecurityPolicy> csp;
       if (node) {
           principal = node->NodePrincipal();
           principal->GetCsp(getter_AddRefs(csp));
   
           if (csp) {
   #ifdef PR_LOGGING
               nsAutoString policy;
               csp->GetPolicy(policy);
               PR_LOG(gCspPRLog, PR_LOG_DEBUG,
                       ("Document has CSP: %s",
                        NS_ConvertUTF16toUTF8(policy).get()));
   #endif
               // obtain the enforcement decision
               csp->ShouldLoad(aContentType,
                               aContentLocation,
                               aRequestOrigin,
                               aRequestContext,
                               aMimeTypeGuess,
                               aExtra,
                               aDecision);
           }
       }
   #ifdef PR_LOGGING
       else {
           nsCAutoString uriSpec;
           aContentLocation->GetSpec(uriSpec);
           PR_LOG(gCspPRLog, PR_LOG_DEBUG,
               ("COULD NOT get nsINode for location: %s", uriSpec.get()));
       }
   #endif
   
       return NS_OK;
   }
   -------------------------------------------------------------------------
   Potentially buggy differences:
1|     {
>      ^
1|         nsCAutoString location;
>          ^^^^^^^^^^^^^ ^^^^^^^^
1|         aContentLocation->GetSpec(location);
>          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
1|         PR_LOG(gCspPRLog, PR_LOG_DEBUG,
>          ^^^^^^^^^^^^^^^^^ ^^^^^^^^^^^^^
1|             ("CSPService::ShouldLoad called for %s", location.get()));
>              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ^^^^^^^^^^^^^^^^
1|     }
>      ^
   -------------------------------------------------------------------------
   c:\mozilla-central\content\base\src\nscspservice.cpp 148:25 -> 202:0
   -------------------------------------------------------------------------
   CSPService::ShouldProcess(PRUint32         aContentType,
                             nsIURI           *aContentLocation,
                             nsIURI           *aRequestOrigin,
                             nsISupports      *aRequestContext,
                             const nsACString &aMimeTypeGuess,
                             nsISupports      *aExtra,
                             PRInt16          *aDecision)
   {
       if (!aContentLocation)
           return NS_ERROR_FAILURE;
   
       // default decision is to accept the item
       *aDecision = nsIContentPolicy::ACCEPT;
   
       // No need to continue processing if CSP is disabled
       if (!sCSPEnabled)
           return NS_OK;
   
       // find the nsDocument that initiated this request and see if it has a
       // CSP policy object
       nsCOMPtr<nsINode> node(do_QueryInterface(aRequestContext));
       nsCOMPtr<nsIPrincipal> principal;
       nsCOMPtr<nsIContentSecurityPolicy> csp;
       if (node) {
           principal = node->NodePrincipal();
           principal->GetCsp(getter_AddRefs(csp));
   
           if (csp) {
   #ifdef PR_LOGGING
               nsAutoString policy;
               csp->GetPolicy(policy);
               PR_LOG(gCspPRLog, PR_LOG_DEBUG,
                     ("shouldProcess - document has policy: %s",
                       NS_ConvertUTF16toUTF8(policy).get()));
   #endif
               // obtain the enforcement decision
               csp->ShouldProcess(aContentType,
                                  aContentLocation,
                                  aRequestOrigin,
                                  aRequestContext,
                                  aMimeTypeGuess,
                                  aExtra,
                                  aDecision);
           }
       }
   #ifdef PR_LOGGING
       else {
           nsCAutoString uriSpec;
           aContentLocation->GetSpec(uriSpec);
           PR_LOG(gCspPRLog, PR_LOG_DEBUG,
               ("COULD NOT get nsINode for location: %s", uriSpec.get()));
       }
   #endif
       return NS_OK;
   }
   -------------------------------------------------------------------------

 Pair c.) TxtSim: 0.696 | CED: 1 | FED: 29 (15.3%) | SZ: 190 | XF: T | XP: T | D: inf
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\content\base\src\nscspservice.cpp 148:25 -> 202:0
   -------------------------------------------------------------------------
   CSPService::ShouldProcess(PRUint32         aContentType,
                             nsIURI           *aContentLocation,
                             nsIURI           *aRequestOrigin,
                             nsISupports      *aRequestContext,
                             const nsACString &aMimeTypeGuess,
                             nsISupports      *aExtra,
                             PRInt16          *aDecision)
   {
       if (!aContentLocation)
           return NS_ERROR_FAILURE;
   
       // default decision is to accept the item
       *aDecision = nsIContentPolicy::ACCEPT;
   
       // No need to continue processing if CSP is disabled
       if (!sCSPEnabled)
           return NS_OK;
   
       // find the nsDocument that initiated this request and see if it has a
       // CSP policy object
       nsCOMPtr<nsINode> node(do_QueryInterface(aRequestContext));
       nsCOMPtr<nsIPrincipal> principal;
       nsCOMPtr<nsIContentSecurityPolicy> csp;
       if (node) {
           principal = node->NodePrincipal();
           principal->GetCsp(getter_AddRefs(csp));
   
           if (csp) {
   #ifdef PR_LOGGING
               nsAutoString policy;
               csp->GetPolicy(policy);
               PR_LOG(gCspPRLog, PR_LOG_DEBUG,
                     ("shouldProcess - document has policy: %s",
                       NS_ConvertUTF16toUTF8(policy).get()));
   #endif
               // obtain the enforcement decision
               csp->ShouldProcess(aContentType,
                                  aContentLocation,
                                  aRequestOrigin,
                                  aRequestContext,
                                  aMimeTypeGuess,
                                  aExtra,
                                  aDecision);
           }
       }
   #ifdef PR_LOGGING
       else {
           nsCAutoString uriSpec;
           aContentLocation->GetSpec(uriSpec);
           PR_LOG(gCspPRLog, PR_LOG_DEBUG,
               ("COULD NOT get nsINode for location: %s", uriSpec.get()));
       }
   #endif
       return NS_OK;
   }
   -------------------------------------------------------------------------
   Potentially buggy differences:
2|     {
>      ^
2|         nsCAutoString location;
>          ^^^^^^^^^^^^^ ^^^^^^^^
2|         aContentLocation->GetSpec(location);
>          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
2|         PR_LOG(gCspPRLog, PR_LOG_DEBUG,
>          ^^^^^^^^^^^^^^^^^ ^^^^^^^^^^^^^
2|             ("CSPService::ShouldLoad called for %s", location.get()));
>              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ^^^^^^^^^^^^^^^^
2|     }
>      ^
   -------------------------------------------------------------------------
   c:\mozilla-central\content\base\src\nscspservice.cpp 82:22 -> 145:0
   -------------------------------------------------------------------------
   CSPService::ShouldLoad(PRUint32 aContentType,
                          nsIURI *aContentLocation,
                          nsIURI *aRequestOrigin,
                          nsISupports *aRequestContext,
                          const nsACString &aMimeTypeGuess,
                          nsISupports *aExtra,
                          PRInt16 *aDecision)
   {
       if (!aContentLocation)
           return NS_ERROR_FAILURE;
   
   #ifdef PR_LOGGING
       {
           nsCAutoString location;
           aContentLocation->GetSpec(location);
           PR_LOG(gCspPRLog, PR_LOG_DEBUG,
               ("CSPService::ShouldLoad called for %s", location.get()));
       }
   #endif
       // default decision, CSP can revise it if there's a policy to enforce
       *aDecision = nsIContentPolicy::ACCEPT;
   
       // No need to continue processing if CSP is disabled
       if (!sCSPEnabled)
           return NS_OK;
   
       // find the principal of the document that initiated this request and see
       // if it has a CSP policy object
       nsCOMPtr<nsINode> node(do_QueryInterface(aRequestContext));
       nsCOMPtr<nsIPrincipal> principal;
       nsCOMPtr<nsIContentSecurityPolicy> csp;
       if (node) {
           principal = node->NodePrincipal();
           principal->GetCsp(getter_AddRefs(csp));
   
           if (csp) {
   #ifdef PR_LOGGING
               nsAutoString policy;
               csp->GetPolicy(policy);
               PR_LOG(gCspPRLog, PR_LOG_DEBUG,
                       ("Document has CSP: %s",
                        NS_ConvertUTF16toUTF8(policy).get()));
   #endif
               // obtain the enforcement decision
               csp->ShouldLoad(aContentType,
                               aContentLocation,
                               aRequestOrigin,
                               aRequestContext,
                               aMimeTypeGuess,
                               aExtra,
                               aDecision);
           }
       }
   #ifdef PR_LOGGING
       else {
           nsCAutoString uriSpec;
           aContentLocation->GetSpec(uriSpec);
           PR_LOG(gCspPRLog, PR_LOG_DEBUG,
               ("COULD NOT get nsINode for location: %s", uriSpec.get()));
       }
   #endif
   
       return NS_OK;
   }
   -------------------------------------------------------------------------

 Pair d.) TxtSim: 0.696 | CED: 1 | FED: 29 (15.3%) | SZ: 190 | XF: F | XP: F | D: 3
   -------------------------------------------------------------------------
   c:\mozilla-central\content\base\src\nscspservice.cpp 82:22 -> 145:0
   -------------------------------------------------------------------------
   CSPService::ShouldLoad(PRUint32 aContentType,
                          nsIURI *aContentLocation,
                          nsIURI *aRequestOrigin,
                          nsISupports *aRequestContext,
                          const nsACString &aMimeTypeGuess,
                          nsISupports *aExtra,
                          PRInt16 *aDecision)
   {
       if (!aContentLocation)
           return NS_ERROR_FAILURE;
   
   #ifdef PR_LOGGING
       {
           nsCAutoString location;
           aContentLocation->GetSpec(location);
           PR_LOG(gCspPRLog, PR_LOG_DEBUG,
               ("CSPService::ShouldLoad called for %s", location.get()));
       }
   #endif
       // default decision, CSP can revise it if there's a policy to enforce
       *aDecision = nsIContentPolicy::ACCEPT;
   
       // No need to continue processing if CSP is disabled
       if (!sCSPEnabled)
           return NS_OK;
   
       // find the principal of the document that initiated this request and see
       // if it has a CSP policy object
       nsCOMPtr<nsINode> node(do_QueryInterface(aRequestContext));
       nsCOMPtr<nsIPrincipal> principal;
       nsCOMPtr<nsIContentSecurityPolicy> csp;
       if (node) {
           principal = node->NodePrincipal();
           principal->GetCsp(getter_AddRefs(csp));
   
           if (csp) {
   #ifdef PR_LOGGING
               nsAutoString policy;
               csp->GetPolicy(policy);
               PR_LOG(gCspPRLog, PR_LOG_DEBUG,
                       ("Document has CSP: %s",
                        NS_ConvertUTF16toUTF8(policy).get()));
   #endif
               // obtain the enforcement decision
               csp->ShouldLoad(aContentType,
                               aContentLocation,
                               aRequestOrigin,
                               aRequestContext,
                               aMimeTypeGuess,
                               aExtra,
                               aDecision);
           }
       }
   #ifdef PR_LOGGING
       else {
           nsCAutoString uriSpec;
           aContentLocation->GetSpec(uriSpec);
           PR_LOG(gCspPRLog, PR_LOG_DEBUG,
               ("COULD NOT get nsINode for location: %s", uriSpec.get()));
       }
   #endif
   
       return NS_OK;
   }
   -------------------------------------------------------------------------
   Potentially buggy differences:
1|     {
>      ^
1|         nsCAutoString location;
>          ^^^^^^^^^^^^^ ^^^^^^^^
1|         aContentLocation->GetSpec(location);
>          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
1|         PR_LOG(gCspPRLog, PR_LOG_DEBUG,
>          ^^^^^^^^^^^^^^^^^ ^^^^^^^^^^^^^
1|             ("CSPService::ShouldLoad called for %s", location.get()));
>              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ^^^^^^^^^^^^^^^^
1|     }
>      ^
   -------------------------------------------------------------------------
   c:\mozilla-central\content\base\src\nscspservice.cpp 148:25 -> 202:0
   -------------------------------------------------------------------------
   CSPService::ShouldProcess(PRUint32         aContentType,
                             nsIURI           *aContentLocation,
                             nsIURI           *aRequestOrigin,
                             nsISupports      *aRequestContext,
                             const nsACString &aMimeTypeGuess,
                             nsISupports      *aExtra,
                             PRInt16          *aDecision)
   {
       if (!aContentLocation)
           return NS_ERROR_FAILURE;
   
       // default decision is to accept the item
       *aDecision = nsIContentPolicy::ACCEPT;
   
       // No need to continue processing if CSP is disabled
       if (!sCSPEnabled)
           return NS_OK;
   
       // find the nsDocument that initiated this request and see if it has a
       // CSP policy object
       nsCOMPtr<nsINode> node(do_QueryInterface(aRequestContext));
       nsCOMPtr<nsIPrincipal> principal;
       nsCOMPtr<nsIContentSecurityPolicy> csp;
       if (node) {
           principal = node->NodePrincipal();
           principal->GetCsp(getter_AddRefs(csp));
   
           if (csp) {
   #ifdef PR_LOGGING
               nsAutoString policy;
               csp->GetPolicy(policy);
               PR_LOG(gCspPRLog, PR_LOG_DEBUG,
                     ("shouldProcess - document has policy: %s",
                       NS_ConvertUTF16toUTF8(policy).get()));
   #endif
               // obtain the enforcement decision
               csp->ShouldProcess(aContentType,
                                  aContentLocation,
                                  aRequestOrigin,
                                  aRequestContext,
                                  aMimeTypeGuess,
                                  aExtra,
                                  aDecision);
           }
       }
   #ifdef PR_LOGGING
       else {
           nsCAutoString uriSpec;
           aContentLocation->GetSpec(uriSpec);
           PR_LOG(gCspPRLog, PR_LOG_DEBUG,
               ("COULD NOT get nsINode for location: %s", uriSpec.get()));
       }
   #endif
       return NS_OK;
   }
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 70: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.652 | CED: 1 | FED: 1 (0.7%) | SZ: 136 | XF: F | XP: F | D: 124
   -------------------------------------------------------------------------
   c:\mozilla-central\dom\plugins\pluginscriptableobjectparent.cpp 186:2 -> 213:2
   -------------------------------------------------------------------------
   if (aObject->_class != GetClass()) {
     NS_ERROR("Don't know what kind of object this is!");
     return false;
   }
   
   ParentNPObject* object = reinterpret_cast<ParentNPObject*>(aObject);
   if (object->invalidated) {
     NS_WARNING("Calling method on an invalidated object!");
     return false;
   }
   
   PPluginIdentifierParent* identifier = GetIdentifier(aObject, aName);
   if (!identifier) {
     return false;
   }
   
   ProtectedActor<PluginScriptableObjectParent> actor(object->parent);
   if (!actor) {
     return false;
   }
   
   NS_ASSERTION(actor->Type() == Proxy, "Bad type!");
   
   ProtectedVariantArray args(aArgs, aArgCount, actor->GetInstance());
   if (!args.IsOk()) {
     NS_ERROR("Failed to convert arguments!");
     return false;
   }
   -------------------------------------------------------------------------
   Potentially buggy differences:
1|   NS_ERROR("Failed to convert arguments!");
>    --------
2|   NS_WARNING("Failed to convert variant!");
>    ----------
   -------------------------------------------------------------------------
   c:\mozilla-central\dom\plugins\pluginscriptableobjectparent.cpp 337:2 -> 364:2
   -------------------------------------------------------------------------
   if (aObject->_class != GetClass()) {
     NS_ERROR("Don't know what kind of object this is!");
     return false;
   }
   
   ParentNPObject* object = reinterpret_cast<ParentNPObject*>(aObject);
   if (object->invalidated) {
     NS_WARNING("Calling method on an invalidated object!");
     return false;
   }
   
   PPluginIdentifierParent* identifier = GetIdentifier(aObject, aName);
   if (!identifier) {
     return false;
   }
   
   ProtectedActor<PluginScriptableObjectParent> actor(object->parent);
   if (!actor) {
     return false;
   }
   
   NS_ASSERTION(actor->Type() == Proxy, "Bad type!");
   
   ProtectedVariant value(*aValue, actor->GetInstance());
   if (!value.IsOk()) {
     NS_WARNING("Failed to convert variant!");
     return false;
   }
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 71: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.695 | CED: 1 | FED: 15 (4.3%) | SZ: 349 | XF: T | XP: F | D: inf
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\nsprpub\pr\src\misc\prcountr.c 153:13 -> 232:32
   -------------------------------------------------------------------------
   QName   *qnp;
   RName   *rnp;
   PRBool  matchQname = PR_FALSE;
   
   /* Self initialize, if necessary */
   if ( counterLock == NULL )
       _PR_CounterInitialize();
   
   /* Validate input arguments */
   PR_ASSERT( strlen(qName) <= PRCOUNTER_NAME_MAX );
   PR_ASSERT( strlen(rName) <= PRCOUNTER_NAME_MAX );
   PR_ASSERT( strlen(description) <= PRCOUNTER_DESC_MAX );
   
   /* Lock the Facility */
   PR_Lock( counterLock );
   
   /* Do we already have a matching QName? */
   if (!PR_CLIST_IS_EMPTY( &qNameList ))
   {
       qnp = (QName *) PR_LIST_HEAD( &qNameList );
       do {
           if ( strcmp(qnp->name, qName) == 0)
           {
               matchQname = PR_TRUE;
               break;
           }
           qnp = (QName *)PR_NEXT_LINK( &qnp->link );
       } while( qnp != (QName *)PR_LIST_HEAD( &qNameList ));
   }
   /*
   ** If we did not find a matching QName,
   **    allocate one and initialize it.
   **    link it onto the qNameList.
   **
   */
   if ( matchQname != PR_TRUE )
   {
       qnp = PR_NEWZAP( QName );
       PR_ASSERT( qnp != NULL );
       PR_INIT_CLIST( &qnp->link );
       PR_INIT_CLIST( &qnp->rNameList );
       strcpy( qnp->name, qName );
       PR_APPEND_LINK( &qnp->link, &qNameList );
   }
   
   /* Do we already have a matching RName? */
   if (!PR_CLIST_IS_EMPTY( &qnp->rNameList ))
   {
       rnp = (RName *) PR_LIST_HEAD( &qnp->rNameList );
       do {
           /*
           ** No duplicate RNames are allowed within a QName
           **
           */
           PR_ASSERT( strcmp(rnp->name, rName));
           rnp = (RName *)PR_NEXT_LINK( &rnp->link );
       } while( rnp != (RName *)PR_LIST_HEAD( &qnp->rNameList ));
   }
   
   /* Get a new RName structure; initialize its members */
   rnp = PR_NEWZAP( RName );
   PR_ASSERT( rnp != NULL );
   PR_INIT_CLIST( &rnp->link );
   strcpy( rnp->name, rName );
   strcpy( rnp->desc, description );
   rnp->lock = PR_NewLock();
   if ( rnp->lock == NULL )
   {
       PR_ASSERT(0);
   }
   
   PR_APPEND_LINK( &rnp->link, &qnp->rNameList ); /* add RName to QName's rnList */
   rnp->qName = qnp;                       /* point the RName to the QName */
   
   /* Unlock the Facility */
   PR_Unlock( counterLock );
   PR_LOG( lm, PR_LOG_DEBUG, ("PR_Counter: Create: QName: %s %p, RName: %s %p\n\t",
       qName, qnp, rName, rnp ));
   
   return((PRCounterHandle)rnp);
   -------------------------------------------------------------------------
   Potentially buggy differences:
2| PR_LOG( lm, PR_LOG_DEBUG,
>  ^^^^^^^ ^^^ ^^^^^^^^^^^^^
2|         ("PRTRACE: CreateTrace: Qname: %s, RName: %s", qName, rName));
>          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ^^^^^^ ^^^^^^^
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\nsprpub\pr\src\misc\prtrace.c 227:13 -> 306:26
   -------------------------------------------------------------------------
   QName   *qnp;
   RName   *rnp;
   PRBool  matchQname = PR_FALSE;
   
   /* Self initialize, if necessary */
   if ( traceLock == NULL )
       _PR_InitializeTrace();
   
   /* Validate input arguments */
   PR_ASSERT( strlen(qName) <= PRTRACE_NAME_MAX );
   PR_ASSERT( strlen(rName) <= PRTRACE_NAME_MAX );
   PR_ASSERT( strlen(description) <= PRTRACE_DESC_MAX );
   
   PR_LOG( lm, PR_LOG_DEBUG,
           ("PRTRACE: CreateTrace: Qname: %s, RName: %s", qName, rName));
   
   /* Lock the Facility */
   PR_Lock( traceLock );
   
   /* Do we already have a matching QName? */
   if (!PR_CLIST_IS_EMPTY( &qNameList ))
   {
       qnp = (QName *) PR_LIST_HEAD( &qNameList );
       do {
           if ( strcmp(qnp->name, qName) == 0)
           {
               matchQname = PR_TRUE;
               break;
           }
           qnp = (QName *)PR_NEXT_LINK( &qnp->link );
       } while( qnp != (QName *)PR_LIST_HEAD( &qNameList ));
   }
   /*
   ** If we did not find a matching QName,
   **    allocate one and initialize it.
   **    link it onto the qNameList.
   **
   */
   if ( matchQname != PR_TRUE )
   {
       qnp = PR_NEWZAP( QName );
       PR_ASSERT( qnp != NULL );
       PR_INIT_CLIST( &qnp->link );
       PR_INIT_CLIST( &qnp->rNameList );
       strcpy( qnp->name, qName );
       PR_APPEND_LINK( &qnp->link, &qNameList );
   }
   
   /* Do we already have a matching RName? */
   if (!PR_CLIST_IS_EMPTY( &qnp->rNameList ))
   {
       rnp = (RName *) PR_LIST_HEAD( &qnp->rNameList );
       do {
           /*
           ** No duplicate RNames are allowed within a QName
           **
           */
           PR_ASSERT( strcmp(rnp->name, rName));
           rnp = (RName *)PR_NEXT_LINK( &rnp->link );
       } while( rnp != (RName *)PR_LIST_HEAD( &qnp->rNameList ));
   }
   
   /* Get a new RName structure; initialize its members */
   rnp = PR_NEWZAP( RName );
   PR_ASSERT( rnp != NULL );
   PR_INIT_CLIST( &rnp->link );
   strcpy( rnp->name, rName );
   strcpy( rnp->desc, description );
   rnp->lock = PR_NewLock();
   rnp->state = Running;
   if ( rnp->lock == NULL )
   {
       PR_ASSERT(0);
   }
   
   PR_APPEND_LINK( &rnp->link, &qnp->rNameList ); /* add RName to QName's rnList */
   rnp->qName = qnp;                       /* point the RName to the QName */
   
   /* Unlock the Facility */
   PR_Unlock( traceLock );
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 72: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.956 | CED: 1 | FED: 1 (0.3%) | SZ: 359 | XF: T | XP: T | D: inf
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\xpfe\appshell\src\nsxulwindow.cpp 1105:35 -> 1178:0
   -------------------------------------------------------------------------
   PRBool nsXULWindow::LoadSizeFromXUL()
   {
     nsresult rv;
     PRBool   gotSize = PR_FALSE;
   
     // if we're the hidden window, don't try to validate our size/position. We're
     // special.
     if (mIsHiddenWindow)
       return PR_FALSE;
   
     nsCOMPtr<nsIDOMElement> windowElement;
     GetWindowDOMElement(getter_AddRefs(windowElement));
     NS_ASSERTION(windowElement, "no xul:window");
     if (!windowElement)
       return PR_FALSE;
   
     PRInt32 currWidth = 0;
     PRInt32 currHeight = 0;
     PRInt32 errorCode;
     PRInt32 temp;
   
     GetSize(&currWidth, &currHeight);
   
     // Obtain the position and sizing information from the <xul:window> element.
     PRInt32 specWidth = currWidth;
     PRInt32 specHeight = currHeight;
     nsAutoString sizeString;
     PRInt32 appPerDev = AppUnitsPerDevPixel();
   
     rv = windowElement->GetAttribute(NS_LITERAL_STRING("width"), sizeString);
     if (NS_SUCCEEDED(rv)) {
       temp = sizeString.ToInteger(&errorCode);
       if (NS_SUCCEEDED(errorCode) && temp > 0) {
         specWidth = CSSToDevPixels(NS_MAX(temp, 100), appPerDev);
         gotSize = PR_TRUE;
       }
     }
     rv = windowElement->GetAttribute(NS_LITERAL_STRING("height"), sizeString);
     if (NS_SUCCEEDED(rv)) {
       temp = sizeString.ToInteger(&errorCode);
       if (NS_SUCCEEDED(errorCode) && temp > 0) {
         specHeight = CSSToDevPixels(NS_MAX(temp, 100), appPerDev);
         gotSize = PR_TRUE;
       }
     }
   
     if (gotSize) {
       // constrain to screen size
       nsCOMPtr<nsIDOMWindowInternal> domWindow;
       GetWindowDOMWindow(getter_AddRefs(domWindow));
       if (domWindow) {
         nsCOMPtr<nsIDOMScreen> screen;
         domWindow->GetScreen(getter_AddRefs(screen));
         if (screen) {
           PRInt32 screenWidth;
           PRInt32 screenHeight;
           screen->GetAvailWidth(&screenWidth);
           screen->GetAvailHeight(&screenHeight);
           screenWidth = CSSToDevPixels(screenWidth, appPerDev);
           screenHeight = CSSToDevPixels(screenHeight, appPerDev);
           if (specWidth > screenWidth)
             specWidth = screenWidth;
           if (specHeight > screenHeight)
             specHeight = screenHeight;
         }
       }
   
       mIntrinsicallySized = PR_FALSE;
       if (specWidth != currWidth || specHeight != currHeight)
         SetSize(specWidth, specHeight, PR_TRUE);
     }
   
     return gotSize;
   }
   -------------------------------------------------------------------------
   Potentially buggy differences:
1|       SetSize(specWidth, specHeight, PR_TRUE);
>                                       -------
2|       SetSize(specWidth, specHeight, PR_FALSE);
>                                       --------
   -------------------------------------------------------------------------
   c:\mozilla-central\xpfe\appshell\src\nsxulwindow.cpp 1102:35 -> 1175:0
   -------------------------------------------------------------------------
   PRBool nsXULWindow::LoadSizeFromXUL()
   {
     nsresult rv;
     PRBool   gotSize = PR_FALSE;
   
     // if we're the hidden window, don't try to validate our size/position. We're
     // special.
     if (mIsHiddenWindow)
       return PR_FALSE;
   
     nsCOMPtr<nsIDOMElement> windowElement;
     GetWindowDOMElement(getter_AddRefs(windowElement));
     NS_ASSERTION(windowElement, "no xul:window");
     if (!windowElement)
       return PR_FALSE;
   
     PRInt32 currWidth = 0;
     PRInt32 currHeight = 0;
     PRInt32 errorCode;
     PRInt32 temp;
   
     GetSize(&currWidth, &currHeight);
   
     // Obtain the position and sizing information from the <xul:window> element.
     PRInt32 specWidth = currWidth;
     PRInt32 specHeight = currHeight;
     nsAutoString sizeString;
     PRInt32 appPerDev = AppUnitsPerDevPixel();
   
     rv = windowElement->GetAttribute(NS_LITERAL_STRING("width"), sizeString);
     if (NS_SUCCEEDED(rv)) {
       temp = sizeString.ToInteger(&errorCode);
       if (NS_SUCCEEDED(errorCode) && temp > 0) {
         specWidth = CSSToDevPixels(NS_MAX(temp, 100), appPerDev);
         gotSize = PR_TRUE;
       }
     }
     rv = windowElement->GetAttribute(NS_LITERAL_STRING("height"), sizeString);
     if (NS_SUCCEEDED(rv)) {
       temp = sizeString.ToInteger(&errorCode);
       if (NS_SUCCEEDED(errorCode) && temp > 0) {
         specHeight = CSSToDevPixels(NS_MAX(temp, 100), appPerDev);
         gotSize = PR_TRUE;
       }
     }
   
     if (gotSize) {
       // constrain to screen size
       nsCOMPtr<nsIDOMWindowInternal> domWindow;
       GetWindowDOMWindow(getter_AddRefs(domWindow));
       if (domWindow) {
         nsCOMPtr<nsIDOMScreen> screen;
         domWindow->GetScreen(getter_AddRefs(screen));
         if (screen) {
           PRInt32 screenWidth;
           PRInt32 screenHeight;
           screen->GetAvailWidth(&screenWidth);
           screen->GetAvailHeight(&screenHeight);
           screenWidth = CSSToDevPixels(screenWidth, appPerDev);
           screenHeight = CSSToDevPixels(screenHeight, appPerDev);
           if (specWidth > screenWidth)
             specWidth = screenWidth;
           if (specHeight > screenHeight)
             specHeight = screenHeight;
         }
       }
   
       mIntrinsicallySized = PR_FALSE;
       if (specWidth != currWidth || specHeight != currHeight)
         SetSize(specWidth, specHeight, PR_FALSE);
     }
   
     return gotSize;
   }
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 73: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.593 | CED: 1 | FED: 8 (4.4%) | SZ: 181 | XF: F | XP: F | D: 83
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\media\libvpx\vp8\common\loopfilter.c 468:8 -> 493:37
   -------------------------------------------------------------------------
   for (mb_col = 0; mb_col < cm->mb_cols; mb_col++)
   {
       int Segment = (alt_flt_enabled) ? mbd->mode_info_context->mbmi.segment_id : 0;
       filter_level = baseline_filter_level[Segment];
   
       // Apply any context driven MB level adjustment
       vp8_adjust_mb_lf_value(mbd, &filter_level);
   
       if (filter_level)
       {
           if (mb_col > 0)
               cm->lf_mbv(y_ptr, 0, 0, post->y_stride, 0, &lfi[filter_level], 0);
   
           if (mbd->mode_info_context->mbmi.dc_diff > 0)
               cm->lf_bv(y_ptr, 0, 0, post->y_stride, 0, &lfi[filter_level], 0);
   
           // don't apply across umv border
           if (mb_row > 0)
               cm->lf_mbh(y_ptr, 0, 0, post->y_stride, 0, &lfi[filter_level], 0);
   
           if (mbd->mode_info_context->mbmi.dc_diff > 0)
               cm->lf_bh(y_ptr, 0, 0, post->y_stride, 0, &lfi[filter_level], 0);
       }
   
       y_ptr += 16;
       mbd->mode_info_context ++;        // step to next MB
   -------------------------------------------------------------------------
   Potentially buggy differences:
1|     vp8_adjust_mb_lf_value(mbd, &filter_level);
>      ^^^^^^^^^^^^^^^^^^^^^^^^^^^ ^^^^^^^^^^^^^^
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\media\libvpx\vp8\common\loopfilter.c 576:8 -> 599:53
   -------------------------------------------------------------------------
   for (mb_col = 0; mb_col < mb_cols; mb_col++)
   {
       int Segment = (alt_flt_enabled) ? mbd->mode_info_context->mbmi.segment_id : 0;
       filter_level = baseline_filter_level[Segment];
   
       if (filter_level)
       {
           if (mb_col > 0)
               cm->lf_mbv(y_ptr, 0, 0, post->y_stride, 0, &lfi[filter_level], 0);
   
           if (mbd->mode_info_context->mbmi.dc_diff > 0)
               cm->lf_bv(y_ptr, 0, 0, post->y_stride, 0, &lfi[filter_level], 0);
   
           cm->lf_mbh(y_ptr, 0, 0, post->y_stride, 0, &lfi[filter_level], 0);
   
           if (mbd->mode_info_context->mbmi.dc_diff > 0)
               cm->lf_bh(y_ptr, 0, 0, post->y_stride, 0, &lfi[filter_level], 0);
       }
   
       y_ptr += 16;
       mbd->mode_info_context += 1;      // step to next MB
   }
   
   y_ptr += post->y_stride  * 16 - post->y_width;
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 74: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.733 | CED: 1 | FED: 2 (1.5%) | SZ: 133 | XF: T | XP: T | D: inf
   -------------------------------------------------------------------------
   c:\comm-central\mailnews\base\util\nsmsgincomingserver.cpp 876:22 -> 908:36
   -------------------------------------------------------------------------
   currServerUri.Append(temp);
   
   PRUint32 count;
   nsILoginInfo** logins;
   
   NS_ConvertUTF8toUTF16 currServer(currServerUri);
   
   nsCString serverCUsername;
   rv = GetUsername(serverCUsername);
   NS_ENSURE_SUCCESS(rv, rv);
   
   NS_ConvertUTF8toUTF16 serverUsername(serverCUsername);
   
   rv = loginMgr->FindLogins(&count, currServer, EmptyString(),
                             currServer, &logins);
   NS_ENSURE_SUCCESS(rv, rv);
   
   // There should only be one-login stored for this url, however just in case
   // there isn't.
   nsString username;
   for (PRUint32 i = 0; i < count; ++i)
   {
     if (NS_SUCCEEDED(logins[i]->GetUsername(username)) &&
         username.Equals(serverUsername))
     {
       // If this fails, just continue, we'll still want to remove the password
       // from our local cache.
       loginMgr->RemoveLogin(logins[i]);
     }
   }
   NS_FREE_XPCOM_ISUPPORTS_POINTER_ARRAY(count, logins);
   
   return SetPassword(EmptyCString());
   -------------------------------------------------------------------------
   Potentially buggy differences:
1| return SetPassword(EmptyCString());
>  ------
2| rv = SetPassword(EmptyCString());
>  -- -
   -------------------------------------------------------------------------
   c:\comm-central\mailnews\compose\src\nssmtpserver.cpp 519:11 -> 550:25
   -------------------------------------------------------------------------
   PRUint32 count;
   nsILoginInfo** logins;
   
   NS_ConvertUTF8toUTF16 currServer(serverUri);
   
   nsCString serverCUsername;
   rv = GetUsername(serverCUsername);
   NS_ENSURE_SUCCESS(rv, rv);
   
   NS_ConvertUTF8toUTF16 serverUsername(serverCUsername);
   
   rv = loginMgr->FindLogins(&count, currServer, EmptyString(),
                             currServer, &logins);
   NS_ENSURE_SUCCESS(rv, rv);
   
   // There should only be one-login stored for this url, however just in case
   // there isn't.
   nsString username;
   for (PRUint32 i = 0; i < count; ++i)
   {
     if (NS_SUCCEEDED(logins[i]->GetUsername(username)) &&
         username.Equals(serverUsername))
     {
       // If this fails, just continue, we'll still want to remove the password
       // from our local cache.
       loginMgr->RemoveLogin(logins[i]);
     }
   }
   NS_FREE_XPCOM_ISUPPORTS_POINTER_ARRAY(count, logins);
   
   rv = SetPassword(EmptyCString());
   m_logonFailed = PR_TRUE;
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 75: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.740 | CED: 1 | FED: 4 (3.3%) | SZ: 122 | XF: T | XP: T | D: inf
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\toolkit\components\feeds\src\nsscriptableunescapehtml.cpp 82:34 -> 109:0
   -------------------------------------------------------------------------
   nsScriptableUnescapeHTML::Unescape(const nsAString & aFromStr,
                                      nsAString & aToStr)
   {
     // create the parser to do the conversion.
     aToStr.SetLength(0);
     nsresult rv;
     nsCOMPtr<nsIParser> parser = do_CreateInstance(kCParserCID, &rv);
     if (NS_FAILED(rv)) return rv;
   
     // convert it!
     nsCOMPtr<nsIContentSink> sink;
   
     sink = do_CreateInstance(NS_PLAINTEXTSINK_CONTRACTID);
     NS_ENSURE_TRUE(sink, NS_ERROR_FAILURE);
   
     nsCOMPtr<nsIHTMLToTextSink> textSink(do_QueryInterface(sink));
     NS_ENSURE_TRUE(textSink, NS_ERROR_FAILURE);
   
     textSink->Initialize(&aToStr, nsIDocumentEncoder::OutputSelectionOnly
                          | nsIDocumentEncoder::OutputAbsoluteLinks, 0);
   
     parser->SetContentSink(sink);
   
     parser->Parse(aFromStr, 0, NS_LITERAL_CSTRING("text/html"),
                   PR_TRUE, eDTDMode_fragment);
   
     return NS_OK;
   }
   -------------------------------------------------------------------------
   Potentially buggy differences:
1|   if (NS_FAILED(rv)) return rv;
>        -------------
2|   if ( !parser )
>         -------
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\widget\src\xpwidgets\nshtmlformatconverter.cpp 276:47 -> 302:0
   -------------------------------------------------------------------------
   nsHTMLFormatConverter::ConvertFromHTMLToUnicode(const nsAutoString & aFromStr, nsAutoString & aToStr)
   {
     // create the parser to do the conversion.
     aToStr.SetLength(0);
     nsresult rv;
     nsCOMPtr<nsIParser> parser = do_CreateInstance(kCParserCID, &rv);
     if ( !parser )
       return rv;
   
     // convert it!
     nsCOMPtr<nsIContentSink> sink;
   
     sink = do_CreateInstance(NS_PLAINTEXTSINK_CONTRACTID);
     NS_ENSURE_TRUE(sink, NS_ERROR_FAILURE);
   
     nsCOMPtr<nsIHTMLToTextSink> textSink(do_QueryInterface(sink));
     NS_ENSURE_TRUE(textSink, NS_ERROR_FAILURE);
   
     textSink->Initialize(&aToStr, nsIDocumentEncoder::OutputSelectionOnly
                          | nsIDocumentEncoder::OutputAbsoluteLinks, 0);
   
     parser->SetContentSink(sink);
   
     parser->Parse(aFromStr, 0, NS_LITERAL_CSTRING("text/html"), PR_TRUE, eDTDMode_fragment);
   
     return NS_OK;
   } // ConvertFromHTMLToUnicode
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 76: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.637 | CED: 1 | FED: 5 (4.1%) | SZ: 122 | XF: F | XP: F | D: 81
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\editor\libeditor\base\nseditor.cpp 3139:11 -> 3169:15
   -------------------------------------------------------------------------
   nsresult result;
   if (!aCurrentNode || !aResultNode) { return NS_ERROR_NULL_POINTER; }
   
   *aResultNode = nsnull;  // init out-param
   
   if (IsRootNode(aCurrentNode))
   {
     // Don't allow traversal above the root node! This helps
     // prevent us from accidentally editing browser content
     // when the editor is in a text widget.
   
     return NS_OK;
   }
   
   nsCOMPtr<nsIDOMNode> candidate;
   result = GetPriorNodeImpl(aCurrentNode, aEditableNode, address_of(candidate), bNoBlockCrossing);
   NS_ENSURE_SUCCESS(result, result);
   
   if (!candidate)
   {
     // we could not find a prior node.  return null.
     return NS_OK;
   }
   else if (!aEditableNode) *aResultNode = candidate;
   else if (IsEditable(candidate)) *aResultNode = candidate;
   else
   { // restart the search from the non-editable node we just found
     nsCOMPtr<nsIDOMNode> notEditableNode = do_QueryInterface(candidate);
     return GetPriorNode(notEditableNode, aEditableNode, aResultNode, bNoBlockCrossing);
   }
   return result;
   -------------------------------------------------------------------------
   Potentially buggy differences:
2|   *aResultNode = nsnull;
>    ^^^^^^^^^^^^ ^ ^^^^^^
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\editor\libeditor\base\nseditor.cpp 3250:2 -> 3281:15
   -------------------------------------------------------------------------
   if (!aCurrentNode || !aResultNode) { return NS_ERROR_NULL_POINTER; }
   
   *aResultNode = nsnull;  // init out-param
   
   if (IsRootNode(aCurrentNode))
   {
     // Don't allow traversal above the root node! This helps
     // prevent us from accidentally editing browser content
     // when the editor is in a text widget.
   
     return NS_OK;
   }
   
   nsCOMPtr<nsIDOMNode> candidate;
   nsresult result = GetNextNodeImpl(aCurrentNode, aEditableNode,
                                     address_of(candidate), bNoBlockCrossing);
   NS_ENSURE_SUCCESS(result, result);
   
   if (!candidate)
   {
     // we could not find a next node.  return null.
     *aResultNode = nsnull;
     return NS_OK;
   }
   else if (!aEditableNode) *aResultNode = candidate;
   else if (IsEditable(candidate)) *aResultNode = candidate;
   else
   { // restart the search from the non-editable node we just found
     nsCOMPtr<nsIDOMNode> notEditableNode = do_QueryInterface(candidate);
     return GetNextNode(notEditableNode, aEditableNode, aResultNode, bNoBlockCrossing);
   }
   return result;
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 77: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.534 | CED: 1 | FED: 3 (4.1%) | SZ: 73 | XF: T | XP: F | D: inf
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\editor\libeditor\html\nshtmldatatransfer.cpp 2093:24 -> 2112:4
   -------------------------------------------------------------------------
   trans->AddDataFlavor(kUnicodeMime);
   
   // Get the Data from the clipboard
   clipboard->GetData(trans, aSelectionType);
   
   // Now we ask the transferable for the data
   // it still owns the data, we just have a pointer to it.
   // If it can't support a "text" output of the data the call will fail
   nsCOMPtr<nsISupports> genericDataObj;
   PRUint32 len = 0;
   char* flav = 0;
   rv = trans->GetAnyTransferData(&flav, getter_AddRefs(genericDataObj),
                                  &len);
   if (NS_FAILED(rv))
   {
   ef DEBUG_akkana
     printf("PasteAsPlaintextQuotation: GetAnyTransferData failed, %d\n", rv);
   if
     return rv;
   }
   -------------------------------------------------------------------------
   Potentially buggy differences:
2| if (NS_FAILED(rv) || !flav)
>                    ^^ ^^^^^
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\editor\libeditor\text\nsplaintexteditor.cpp 1471:24 -> 1490:4
   -------------------------------------------------------------------------
   trans->AddDataFlavor(kUnicodeMime);
   
   // Get the Data from the clipboard
   clipboard->GetData(trans, aSelectionType);
   
   // Now we ask the transferable for the data
   // it still owns the data, we just have a pointer to it.
   // If it can't support a "text" output of the data the call will fail
   nsCOMPtr<nsISupports> genericDataObj;
   PRUint32 len;
   char* flav = nsnull;
   rv = trans->GetAnyTransferData(&flav, getter_AddRefs(genericDataObj),
                                  &len);
   if (NS_FAILED(rv) || !flav)
   {
   ef DEBUG_akkana
     printf("PasteAsPlaintextQuotation: GetAnyTransferData failed, %d\n", rv);
   if
     return rv;
   }
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 78: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.529 | CED: 6 | FED: 15 (16.9%) | SZ: 89 | XF: F | XP: F | D: 26
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\layout\generic\nsselection.cpp 5195:4 -> 5213:46
   -------------------------------------------------------------------------
   if (focusNode != anchorNode || focusOffset != anchorOffset) {//if collapsed diff dont do anything
     res = difRange->SetStart(focusNode, focusOffset);
     res |= difRange->SetEnd(anchorNode, anchorOffset);
     if (NS_FAILED(res))
       return res;
     res = CopyRangeToAnchorFocus(range);
     if (NS_FAILED(res))
       return res;
     //deselect from 1 to a
     selectFrames(presContext, difRange , PR_FALSE);
   }
   else
   {
     res = CopyRangeToAnchorFocus(range);
     if (NS_FAILED(res))
       return res;
   }
   //select from a to 2
   selectFrames(presContext, range , PR_TRUE);
   -------------------------------------------------------------------------
   Potentially buggy differences:
1|   res = difRange->SetStart(focusNode, focusOffset);
>                             ---------  -----------
2|   res = difRange->SetStart(anchorNode, anchorOffset);
>                             ----------  ------------

1|   res |= difRange->SetEnd(anchorNode, anchorOffset);
>                            ----------  ------------
2|   res |= difRange->SetEnd(focusNode, focusOffset);
>                            ---------  -----------

1|   if (NS_FAILED(res))
>    ^^ ^^^^^^^^^^^   --
1|     return res;
>      ------ ---
1|   res = CopyRangeToAnchorFocus(range);
>    --- -
2|   res |= CopyRangeToAnchorFocus(range);
>        --
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\layout\generic\nsselection.cpp 5239:4 -> 5257:46
   -------------------------------------------------------------------------
   if (NS_FAILED(res))
     return res;
   //deselect from a to 1
   if (focusNode != anchorNode || focusOffset!= anchorOffset) {//if collapsed diff dont do anything
     res = difRange->SetStart(anchorNode, anchorOffset);
     res |= difRange->SetEnd(focusNode, focusOffset);
     res |= CopyRangeToAnchorFocus(range);
     if (NS_FAILED(res))
       return res;
     selectFrames(presContext, difRange, PR_FALSE);
   }
   else
   {
     res = CopyRangeToAnchorFocus(range);
     if (NS_FAILED(res))
       return res;
   }
   //select from 2 to a
   selectFrames(presContext, range , PR_TRUE);
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 79: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.621 | CED: 2 | FED: 14 (11.0%) | SZ: 127 | XF: F | XP: F | D: 150
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\editor\libeditor\html\nstableeditor.cpp 1060:2 -> 1088:2
   -------------------------------------------------------------------------
   NS_ENSURE_SUCCESS(res, res);
   
   // Shortcut the case of deleting all columns in table
   if(startColIndex == 0 && aNumber >= colCount)
     return DeleteTable2(table, selection);
   
   // Check for counts too high
   aNumber = NS_MIN(aNumber,(colCount-startColIndex));
   
   nsAutoEditBatch beginBatching(this);
   // Prevent rules testing until we're done
   nsAutoRules beginRulesSniffing(this, kOpDeleteNode, nsIEditor::eNext);
   
   // Test if deletion is controlled by selected cells
   nsCOMPtr<nsIDOMElement> firstCell;
   nsCOMPtr<nsIDOMRange> range;
   res = GetFirstSelectedCell(getter_AddRefs(range), getter_AddRefs(firstCell));
   NS_ENSURE_SUCCESS(res, res);
   
   PRInt32 rangeCount;
   res = selection->GetRangeCount(&rangeCount);
   NS_ENSURE_SUCCESS(res, res);
   
   if (firstCell && rangeCount > 1)
   {
     // Fetch indexes again - may be different for selected cells
     res = GetCellIndexes(firstCell, &startRowIndex, &startColIndex);
     NS_ENSURE_SUCCESS(res, res);
   }
   -------------------------------------------------------------------------
   Potentially buggy differences:
1| if(startColIndex == 0 && aNumber >= colCount)
>     -------------
2| if(startRowIndex == 0 && aNumber >= rowCount)
>     -------------

1|   return DeleteTable2(table, selection);
>                                        ^
1| aNumber = NS_MIN(aNumber,(colCount-startColIndex));
>  ^^^^^^^ ^ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\editor\libeditor\html\nstableeditor.cpp 1238:6 -> 1263:2
   -------------------------------------------------------------------------
   res = GetTableSize(table, &rowCount, &colCount);
   NS_ENSURE_SUCCESS(res, res);
   
   // Shortcut the case of deleting all rows in table
   if(startRowIndex == 0 && aNumber >= rowCount)
     return DeleteTable2(table, selection);
   
   nsAutoEditBatch beginBatching(this);
   // Prevent rules testing until we're done
   nsAutoRules beginRulesSniffing(this, kOpDeleteNode, nsIEditor::eNext);
   
   nsCOMPtr<nsIDOMElement> firstCell;
   nsCOMPtr<nsIDOMRange> range;
   res = GetFirstSelectedCell(getter_AddRefs(range), getter_AddRefs(firstCell));
   NS_ENSURE_SUCCESS(res, res);
   
   PRInt32 rangeCount;
   res = selection->GetRangeCount(&rangeCount);
   NS_ENSURE_SUCCESS(res, res);
   
   if (firstCell && rangeCount > 1)
   {
     // Fetch indexes again - may be different for selected cells
     res = GetCellIndexes(firstCell, &startRowIndex, &startColIndex);
     NS_ENSURE_SUCCESS(res, res);
   }
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 80: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.500 | CED: 1 | FED: 6 (9.2%) | SZ: 65 | XF: F | XP: F | D: 12
   -------------------------------------------------------------------------
   c:\comm-central\mailnews\base\src\nsmsgdbview.cpp 2262:49 -> 2275:0
   -------------------------------------------------------------------------
   NS_IMETHODIMP nsMsgDBView::GetMsgHdrsForSelection(nsIMutableArray **aResult)
   {
     nsMsgViewIndexArray selection;
     GetSelectedIndices(selection);
     PRUint32 numIndices = selection.Length();
   
     nsresult rv;
     nsCOMPtr<nsIMutableArray> messages(do_CreateInstance(NS_ARRAY_CONTRACTID, &rv));
     NS_ENSURE_SUCCESS(rv, rv);
     rv = GetHeadersFromSelection(selection.Elements(), numIndices, messages);
     NS_ENSURE_SUCCESS(rv, rv);
     messages.forget(aResult);
     return rv;
   }
   -------------------------------------------------------------------------
   Potentially buggy differences:
2| if (!numIndices) return NS_OK;
>  ^^ ^^^^^^^^^^^^^ ^^^^^^
   -------------------------------------------------------------------------
   c:\comm-central\mailnews\base\src\nsmsgdbview.cpp 2287:22 -> 2296:29
   -------------------------------------------------------------------------
   nsMsgViewIndexArray selection;
   GetSelectedIndices(selection);
   PRUint32 numIndices = selection.Length();
   if (!numIndices) return NS_OK;
   
   nsCOMPtr<nsIMutableArray> messages(do_CreateInstance(NS_ARRAY_CONTRACTID, &rv));
   NS_ENSURE_SUCCESS(rv, rv);
   rv = GetHeadersFromSelection(selection.Elements(), numIndices, messages);
   NS_ENSURE_SUCCESS(rv, rv);
   messages->GetLength(length);
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 81: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.623 | CED: 1 | FED: 18 (13.8%) | SZ: 130 | XF: F | XP: F | D: 54
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\content\html\document\src\nshtmlfragmentcontentsink.cpp 359:13 -> 393:67
   -------------------------------------------------------------------------
   FlushText();
   
   nsIContent *content = nsnull;
   
   nsCOMPtr<nsINodeInfo> nodeInfo;
   
   if (nodeType == eHTMLTag_userdefined) {
     nsAutoString lower;
     nsContentUtils::ASCIIToLower(aNode.GetText(), lower);
     nsCOMPtr<nsIAtom> name = do_GetAtom(lower);
     nodeInfo = mNodeInfoManager->GetNodeInfo(name,
                                              nsnull,
                                              kNameSpaceID_XHTML);
     NS_ENSURE_TRUE(nodeInfo, NS_ERROR_OUT_OF_MEMORY);
   }
   else if (mNodeInfoCache[nodeType]) {
     nodeInfo = mNodeInfoCache[nodeType];
   }
   else {
     nsIParserService* parserService = nsContentUtils::GetParserService();
     if (!parserService)
       return NS_ERROR_OUT_OF_MEMORY;
   
     nsIAtom *name = parserService->HTMLIdToAtomTag(nodeType);
     NS_ASSERTION(name, "This should not happen!");
   
     nodeInfo = mNodeInfoManager->GetNodeInfo(name,
                                              nsnull,
                                              kNameSpaceID_XHTML);
     NS_ENSURE_TRUE(nodeInfo, NS_ERROR_OUT_OF_MEMORY);
   
     NS_ADDREF(mNodeInfoCache[nodeType] = nodeInfo);
   }
   
   content = CreateHTMLElement(nodeType, nodeInfo, PR_FALSE).get();
   -------------------------------------------------------------------------
   Potentially buggy differences:
1|   nsIParserService* parserService = nsContentUtils::GetParserService();
>    ^^^^^^^^^^^^^^^^^ ^^^^^^^^^^^^^ ^ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
1|   if (!parserService)
>    ^^ ^^^^^^^^^^^^^^^^
1|     return NS_ERROR_OUT_OF_MEMORY;
>      ^^^^^^ ^^^^^^^^^^^^^^^^^^^^^^
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\content\html\document\src\nshtmlfragmentcontentsink.cpp 447:17 -> 478:8
   -------------------------------------------------------------------------
   FlushText();
   
   // Create new leaf content object
   nsRefPtr<nsGenericHTMLElement> content;
   nsHTMLTag nodeType = nsHTMLTag(aNode.GetNodeType());
   
   nsIParserService* parserService = nsContentUtils::GetParserService();
   if (!parserService)
     return NS_ERROR_OUT_OF_MEMORY;
   
   nsCOMPtr<nsINodeInfo> nodeInfo;
   
   if (nodeType == eHTMLTag_userdefined) {
     nsAutoString lower;
     nsContentUtils::ASCIIToLower(aNode.GetText(), lower);
     nsCOMPtr<nsIAtom> name = do_GetAtom(lower);
     nodeInfo = mNodeInfoManager->GetNodeInfo(name, nsnull,
                                              kNameSpaceID_XHTML);
     NS_ENSURE_TRUE(nodeInfo, NS_ERROR_OUT_OF_MEMORY);
   }
   else if (mNodeInfoCache[nodeType]) {
     nodeInfo = mNodeInfoCache[nodeType];
   }
   else {
     nsIAtom *name = parserService->HTMLIdToAtomTag(nodeType);
     NS_ASSERTION(name, "This should not happen!");
   
     nodeInfo = mNodeInfoManager->GetNodeInfo(name, nsnull,
                                              kNameSpaceID_XHTML);
     NS_ENSURE_TRUE(nodeInfo, NS_ERROR_OUT_OF_MEMORY);
     NS_ADDREF(mNodeInfoCache[nodeType] = nodeInfo);
   }
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 82: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.613 | CED: 1 | FED: 5 (8.5%) | SZ: 59 | XF: F | XP: F | D: 23
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\js\jsd\jsd_scpt.c 596:4 -> 613:48
   -------------------------------------------------------------------------
   if( ! jsdscript )
       return;
   
   ef JSD_DUMP
   JSD_LOCK_SCRIPTS(jsdc);
   _dumpJSDScript(jsdc, jsdscript, "***NEW Script: ");
   _dumpJSDScriptList( jsdc );
   JSD_UNLOCK_SCRIPTS(jsdc);
   if /* JSD_DUMP */
   
   /* local in case jsdc->scriptHook gets cleared on another thread */
   JSD_LOCK();
   hook = jsdc->scriptHook;
   hookData = jsdc->scriptHookData;
   JSD_UNLOCK();
   
   if( hook )
       hook(jsdc, jsdscript, JS_TRUE, hookData);
   -------------------------------------------------------------------------
   Potentially buggy differences:
1| _dumpJSDScript(jsdc, jsdscript, "***NEW Script: ");
>                                                   ^
1| _dumpJSDScriptList( jsdc );
>  ^^^^^^^^^^^^^^^^^^^ ^^^^
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\js\jsd\jsd_scpt.c 636:4 -> 652:49
   -------------------------------------------------------------------------
   if( ! jsdscript )
       return;
   
   ef JSD_DUMP
   JSD_LOCK_SCRIPTS(jsdc);
   _dumpJSDScript(jsdc, jsdscript, "***DESTROY Script: ");
   JSD_UNLOCK_SCRIPTS(jsdc);
   if /* JSD_DUMP */
   
   /* local in case hook gets cleared on another thread */
   JSD_LOCK();
   hook = jsdc->scriptHook;
   hookData = jsdc->scriptHookData;
   JSD_UNLOCK();
   
   if( hook )
       hook(jsdc, jsdscript, JS_FALSE, hookData);
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 83: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.839 | CED: 1 | FED: 2 (2.2%) | SZ: 90 | XF: T | XP: T | D: inf
   -------------------------------------------------------------------------
   c:\comm-central\mailnews\compose\src\nsmsgcompose.cpp 278:0 -> 292:0
   -------------------------------------------------------------------------
   GetNodeLocation(nsIDOMNode *inChild, nsCOMPtr<nsIDOMNode> *outParent, PRInt32 *outOffset)
   {
     NS_ASSERTION((outParent && outOffset), "bad args");
     nsresult result = NS_ERROR_NULL_POINTER;
     if (inChild && outParent && outOffset)
     {
       result = inChild->GetParentNode(getter_AddRefs(*outParent));
       if ( (NS_SUCCEEDED(result)) && (*outParent) )
       {
         result = GetChildOffset(inChild, *outParent, *outOffset);
       }
     }
   
     return result;
   }
   -------------------------------------------------------------------------
   Potentially buggy differences:
2|   NS_ASSERTION((inChild && outParent && outOffset), "bad args");
>                  ^^^^^^^ ^^
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\editor\libeditor\base\nseditor.cpp 2988:25 -> 3001:0
   -------------------------------------------------------------------------
   nsEditor::GetNodeLocation(nsIDOMNode *inChild, nsCOMPtr<nsIDOMNode> *outParent, PRInt32 *outOffset)
   {
     NS_ASSERTION((inChild && outParent && outOffset), "bad args");
     nsresult result = NS_ERROR_NULL_POINTER;
     if (inChild && outParent && outOffset)
     {
       result = inChild->GetParentNode(getter_AddRefs(*outParent));
       if ((NS_SUCCEEDED(result)) && (*outParent))
       {
         result = GetChildOffset(inChild, *outParent, *outOffset);
       }
     }
     return result;
   }
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 84: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.705 | CED: 1 | FED: 4 (4.2%) | SZ: 95 | XF: T | XP: T | D: inf
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\content\canvas\src\webglcontextgl.cpp 2767:24 -> 2788:0
   -------------------------------------------------------------------------
   WebGLContext::UseProgram(nsIWebGLProgram *pobj)
   {
       WebGLProgram *prog;
       WebGLuint progname;
       PRBool isNull;
       if (!GetConcreteObjectAndGLName("useProgram", pobj, &prog, &progname, &isNull))
           return NS_OK;
   
       MakeContextCurrent();
   
       if (isNull) {
           gl->fUseProgram(0);
           mCurrentProgram = nsnull;
       } else {
           if (!prog->LinkStatus())
               return ErrorInvalidOperation("UseProgram: program was not linked successfully");
           gl->fUseProgram(progname);
           mCurrentProgram = prog;
       }
   
       return NS_OK;
   }
   -------------------------------------------------------------------------
   Potentially buggy differences:
1|         return NS_OK;
>                 -----
2|         return ErrorInvalidOperation("UseProgram: invalid program object");
>                 -----------------------------------------------------------
   -------------------------------------------------------------------------
   c:\mozilla-central\content\canvas\src\webglcontextgl.cpp 2746:24 -> 2767:0
   -------------------------------------------------------------------------
   WebGLContext::UseProgram(nsIWebGLProgram *pobj)
   {
       WebGLProgram *prog;
       WebGLuint progname;
       PRBool isNull;
       if (!GetConcreteObjectAndGLName(pobj, &prog, &progname, &isNull))
           return ErrorInvalidOperation("UseProgram: invalid program object");
   
       MakeContextCurrent();
   
       if (isNull) {
           gl->fUseProgram(0);
           mCurrentProgram = nsnull;
       } else {
           if (!prog->LinkStatus())
               return ErrorInvalidOperation("UseProgram: program was not linked successfully");
           gl->fUseProgram(progname);
           mCurrentProgram = prog;
       }
   
       return NS_OK;
   }
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 85: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.561 | CED: 1 | FED: 8 (8.5%) | SZ: 94 | XF: F | XP: F | D: 17
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\embedding\browser\webbrowser\nsdocshelltreeowner.cpp 881:31 -> 898:11
   -------------------------------------------------------------------------
   nsCOMPtr<nsPIDOMEventTarget> piTarget;
   GetPIDOMEventTarget(mWebBrowser, getter_AddRefs(piTarget));
   
   nsCOMPtr<nsIDOMEventGroup> sysGroup;
   piTarget->GetSystemEventGroup(getter_AddRefs(sysGroup));
   nsIEventListenerManager* elmP = piTarget->GetListenerManager(PR_TRUE);
   if (sysGroup && elmP)
   {
     rv = elmP->AddEventListenerByType(this, NS_LITERAL_STRING("dragover"),
                                       NS_EVENT_FLAG_BUBBLE,
                                       sysGroup);
     NS_ENSURE_SUCCESS(rv, rv);
     rv = elmP->AddEventListenerByType(this, NS_LITERAL_STRING("drop"),
                                       NS_EVENT_FLAG_BUBBLE,
                                       sysGroup);
   }
   
   return rv;
   -------------------------------------------------------------------------
   Potentially buggy differences:
2| if (!piTarget)
>  ^^ ^^^^^^^^^^^
2|   return NS_OK;
>    ^^^^^^ ^^^^^
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\embedding\browser\webbrowser\nsdocshelltreeowner.cpp 915:31 -> 933:2
   -------------------------------------------------------------------------
   nsCOMPtr<nsPIDOMEventTarget> piTarget;
   GetPIDOMEventTarget(mWebBrowser, getter_AddRefs(piTarget));
   if (!piTarget)
     return NS_OK;
   
   nsCOMPtr<nsIDOMEventGroup> sysGroup;
   piTarget->GetSystemEventGroup(getter_AddRefs(sysGroup));
   nsIEventListenerManager* elmP = piTarget->GetListenerManager(PR_TRUE);
   if (sysGroup && elmP)
   {
     nsresult rv =
       elmP->RemoveEventListenerByType(this, NS_LITERAL_STRING("dragover"),
                                       NS_EVENT_FLAG_BUBBLE,
                                       sysGroup);
     NS_ENSURE_SUCCESS(rv, rv);
     rv = elmP->RemoveEventListenerByType(this, NS_LITERAL_STRING("drop"),
                                          NS_EVENT_FLAG_BUBBLE,
                                          sysGroup);
   }
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 86: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.622 | CED: 1 | FED: 7 (3.8%) | SZ: 185 | XF: F | XP: F | D: 2
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\modules\zlib\src\deflate.c 681:8 -> 709:37
   -------------------------------------------------------------------------
   if (s->gzhead->name != NULL) {
       uInt beg = s->pending;  /* start of bytes to update crc */
       int val;
   
       do {
           if (s->pending == s->pending_buf_size) {
               if (s->gzhead->hcrc && s->pending > beg)
                   strm->adler = crc32(strm->adler, s->pending_buf + beg,
                                       s->pending - beg);
               flush_pending(strm);
               beg = s->pending;
               if (s->pending == s->pending_buf_size) {
                   val = 1;
                   break;
               }
           }
           val = s->gzhead->name[s->gzindex++];
           put_byte(s, val);
       } while (val != 0);
       if (s->gzhead->hcrc && s->pending > beg)
           strm->adler = crc32(strm->adler, s->pending_buf + beg,
                               s->pending - beg);
       if (val == 0) {
           s->gzindex = 0;
           s->status = COMMENT_STATE;
       }
   }
   else
       s->status = COMMENT_STATE;
   -------------------------------------------------------------------------
   Potentially buggy differences:
1|     if (val == 0) {
>                    ^
1|         s->gzindex = 0;
>          ^^^^^^^^^^ ^ ^
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\modules\zlib\src\deflate.c 711:4 -> 738:34
   -------------------------------------------------------------------------
   if (s->status == COMMENT_STATE) {
       if (s->gzhead->comment != NULL) {
           uInt beg = s->pending;  /* start of bytes to update crc */
           int val;
   
           do {
               if (s->pending == s->pending_buf_size) {
                   if (s->gzhead->hcrc && s->pending > beg)
                       strm->adler = crc32(strm->adler, s->pending_buf + beg,
                                           s->pending - beg);
                   flush_pending(strm);
                   beg = s->pending;
                   if (s->pending == s->pending_buf_size) {
                       val = 1;
                       break;
                   }
               }
               val = s->gzhead->comment[s->gzindex++];
               put_byte(s, val);
           } while (val != 0);
           if (s->gzhead->hcrc && s->pending > beg)
               strm->adler = crc32(strm->adler, s->pending_buf + beg,
                                   s->pending - beg);
           if (val == 0)
               s->status = HCRC_STATE;
       }
       else
           s->status = HCRC_STATE;
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 87: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.790 | CED: 1 | FED: 2 (2.4%) | SZ: 84 | XF: F | XP: F | D: 49
   -------------------------------------------------------------------------
   c:\comm-central\mailnews\imap\src\nsautosyncstate.cpp 132:28 -> 144:60
   -------------------------------------------------------------------------
   nsCOMPtr <nsIMsgFolder> folder = do_QueryReferent(mOwnerFolder, &rv);
   NS_ENSURE_SUCCESS(rv, rv);
   
   nsCOMPtr<nsIMsgDatabase> database;
   rv = folder->GetMsgDatabase(getter_AddRefs(database));
   if (!database)
     return NS_ERROR_FAILURE;
   
   nsCOMPtr<nsIAutoSyncManager> autoSyncMgr = do_GetService(NS_AUTOSYNCMANAGER_CONTRACTID, &rv);
   NS_ENSURE_SUCCESS(rv,rv);
   
   nsCOMPtr<nsIAutoSyncMsgStrategy> msgStrategy;
   autoSyncMgr->GetMsgStrategy(getter_AddRefs(msgStrategy));
   -------------------------------------------------------------------------
   Potentially buggy differences:
2| rv = autoSyncMgr->GetMsgStrategy(getter_AddRefs(msgStrategy));
>  ^^ ^
   -------------------------------------------------------------------------
   c:\comm-central\mailnews\imap\src\nsautosyncstate.cpp 193:11 -> 206:63
   -------------------------------------------------------------------------
   nsresult rv;
   nsCOMPtr <nsIMsgFolder> folder = do_QueryReferent(mOwnerFolder, &rv);
   NS_ENSURE_SUCCESS(rv, rv);
   
   nsCOMPtr<nsIMsgDatabase> database;
   rv = folder->GetMsgDatabase(getter_AddRefs(database));
   if (!database)
     return NS_ERROR_FAILURE;
   
   nsCOMPtr<nsIAutoSyncManager> autoSyncMgr = do_GetService(NS_AUTOSYNCMANAGER_CONTRACTID, &rv);
   NS_ENSURE_SUCCESS(rv, rv);
   
   nsCOMPtr<nsIAutoSyncMsgStrategy> msgStrategy;
   rv = autoSyncMgr->GetMsgStrategy(getter_AddRefs(msgStrategy));
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 88: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.532 | CED: 1 | FED: 5 (4.5%) | SZ: 110 | XF: F | XP: F | D: 6
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\content\xul\templates\src\nsxultreebuilder.cpp 972:4 -> 990:16
   -------------------------------------------------------------------------
   NS_PRECONDITION(aRow >= 0 && aRow < mRows.Count(), "bad index");
   if (aRow < 0 || aRow >= mRows.Count())
       return NS_ERROR_INVALID_ARG;
   
   // Find the <cell> that corresponds to the column we want.
   nsCOMPtr<nsIContent> cell;
   GetTemplateActionCellFor(aRow, aCol, getter_AddRefs(cell));
   if (cell) {
       nsAutoString raw;
       cell->GetAttr(kNameSpaceID_None, nsGkAtoms::editable, raw);
   
       nsAutoString editable;
       SubstituteText(mRows[aRow]->mMatch->mResult, raw, editable);
   
       if (editable.EqualsLiteral("false"))
           *_retval = PR_FALSE;
   }
   
   return NS_OK;
   -------------------------------------------------------------------------
   Potentially buggy differences:
2| *_retval = PR_TRUE;
>  ^^^^^^^^ ^ ^^^^^^^
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\content\xul\templates\src\nsxultreebuilder.cpp 996:4 -> 1016:16
   -------------------------------------------------------------------------
   NS_PRECONDITION(aRow >= 0 && aRow < mRows.Count(), "bad index");
   if (aRow < 0 || aRow >= mRows.Count())
       return NS_ERROR_INVALID_ARG;
   
   *_retval = PR_TRUE;
   
   // Find the <cell> that corresponds to the column we want.
   nsCOMPtr<nsIContent> cell;
   GetTemplateActionCellFor(aRow, aCol, getter_AddRefs(cell));
   if (cell) {
       nsAutoString raw;
       cell->GetAttr(kNameSpaceID_None, nsGkAtoms::selectable, raw);
   
       nsAutoString selectable;
       SubstituteText(mRows[aRow]->mMatch->mResult, raw, selectable);
   
       if (selectable.EqualsLiteral("false"))
           *_retval = PR_FALSE;
   }
   
   return NS_OK;
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 89: 2 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.756 | CED: 1 | FED: 4 (2.2%) | SZ: 179 | XF: T | XP: F | D: inf
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\js\src\shell\js.cpp 4487:4 -> 4523:4
   -------------------------------------------------------------------------
   if (JSREPORT_IS_WARNING(report->flags) && !reportWarnings)
       return;
   
   prefix = NULL;
   if (report->filename)
       prefix = JS_smprintf("%s:", report->filename);
   if (report->lineno) {
       tmp = prefix;
       prefix = JS_smprintf("%s%u: ", tmp ? tmp : "", report->lineno);
       JS_free(cx, tmp);
   }
   if (JSREPORT_IS_WARNING(report->flags)) {
       tmp = prefix;
       prefix = JS_smprintf("%s%swarning: ",
                            tmp ? tmp : "",
                            JSREPORT_IS_STRICT(report->flags) ? "strict " : "");
       JS_free(cx, tmp);
   }
   
   /* embedded newlines -- argh! */
   while ((ctmp = strchr(message, '\n')) != 0) {
       ctmp++;
       if (prefix)
           fputs(prefix, gErrFile);
       fwrite(message, 1, ctmp - message, gErrFile);
       message = ctmp;
   }
   
   /* If there were no filename or lineno, the prefix might be empty */
   if (prefix)
       fputs(prefix, gErrFile);
   fputs(message, gErrFile);
   
   if (!report->linebuf) {
       fputc('\n', gErrFile);
       goto out;
   }
   -------------------------------------------------------------------------
   Potentially buggy differences:
1| prefix = NULL;
>  ^^^^^^ ^ ^^^^
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\js\src\xpconnect\shell\xpcshell.cpp 313:4 -> 347:28
   -------------------------------------------------------------------------
   if (!report) {
       fprintf(gErrFile, "%s\n", message);
       return;
   }
   
   /* Conditionally ignore reported warnings. */
   if (JSREPORT_IS_WARNING(report->flags) && !reportWarnings)
       return;
   
   if (report->filename)
       prefix = JS_smprintf("%s:", report->filename);
   if (report->lineno) {
       tmp = prefix;
       prefix = JS_smprintf("%s%u: ", tmp ? tmp : "", report->lineno);
       JS_free(cx, tmp);
   }
   if (JSREPORT_IS_WARNING(report->flags)) {
       tmp = prefix;
       prefix = JS_smprintf("%s%swarning: ",
                            tmp ? tmp : "",
                            JSREPORT_IS_STRICT(report->flags) ? "strict " : "");
       JS_free(cx, tmp);
   }
   
   /* embedded newlines -- argh! */
   while ((ctmp = strchr(message, '\n')) != 0) {
       ctmp++;
       if (prefix) fputs(prefix, gErrFile);
       fwrite(message, 1, ctmp - message, gErrFile);
       message = ctmp;
   }
   /* If there were no filename or lineno, the prefix might be empty */
   if (prefix)
       fputs(prefix, gErrFile);
   fputs(message, gErrFile);
   -------------------------------------------------------------------------

 Pair b.) TxtSim: 0.756 | CED: 1 | FED: 4 (2.2%) | SZ: 179 | XF: T | XP: T | D: inf
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\js\src\shell\js.cpp 4487:4 -> 4523:4
   -------------------------------------------------------------------------
   if (JSREPORT_IS_WARNING(report->flags) && !reportWarnings)
       return;
   
   prefix = NULL;
   if (report->filename)
       prefix = JS_smprintf("%s:", report->filename);
   if (report->lineno) {
       tmp = prefix;
       prefix = JS_smprintf("%s%u: ", tmp ? tmp : "", report->lineno);
       JS_free(cx, tmp);
   }
   if (JSREPORT_IS_WARNING(report->flags)) {
       tmp = prefix;
       prefix = JS_smprintf("%s%swarning: ",
                            tmp ? tmp : "",
                            JSREPORT_IS_STRICT(report->flags) ? "strict " : "");
       JS_free(cx, tmp);
   }
   
   /* embedded newlines -- argh! */
   while ((ctmp = strchr(message, '\n')) != 0) {
       ctmp++;
       if (prefix)
           fputs(prefix, gErrFile);
       fwrite(message, 1, ctmp - message, gErrFile);
       message = ctmp;
   }
   
   /* If there were no filename or lineno, the prefix might be empty */
   if (prefix)
       fputs(prefix, gErrFile);
   fputs(message, gErrFile);
   
   if (!report->linebuf) {
       fputc('\n', gErrFile);
       goto out;
   }
   -------------------------------------------------------------------------
   Potentially buggy differences:
1| prefix = NULL;
>  ^^^^^^ ^ ^^^^
   -------------------------------------------------------------------------
   c:\mozilla-central\js\src\xpconnect\shell\xpcshell.cpp 313:4 -> 347:28
   -------------------------------------------------------------------------
   if (!report) {
       fprintf(gErrFile, "%s\n", message);
       return;
   }
   
   /* Conditionally ignore reported warnings. */
   if (JSREPORT_IS_WARNING(report->flags) && !reportWarnings)
       return;
   
   if (report->filename)
       prefix = JS_smprintf("%s:", report->filename);
   if (report->lineno) {
       tmp = prefix;
       prefix = JS_smprintf("%s%u: ", tmp ? tmp : "", report->lineno);
       JS_free(cx, tmp);
   }
   if (JSREPORT_IS_WARNING(report->flags)) {
       tmp = prefix;
       prefix = JS_smprintf("%s%swarning: ",
                            tmp ? tmp : "",
                            JSREPORT_IS_STRICT(report->flags) ? "strict " : "");
       JS_free(cx, tmp);
   }
   
   /* embedded newlines -- argh! */
   while ((ctmp = strchr(message, '\n')) != 0) {
       ctmp++;
       if (prefix) fputs(prefix, gErrFile);
       fwrite(message, 1, ctmp - message, gErrFile);
       message = ctmp;
   }
   /* If there were no filename or lineno, the prefix might be empty */
   if (prefix)
       fputs(prefix, gErrFile);
   fputs(message, gErrFile);
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 90: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.607 | CED: 1 | FED: 12 (13.3%) | SZ: 90 | XF: T | XP: F | D: inf
   -------------------------------------------------------------------------
   c:\comm-central\directory\c-sdk\ldap\libraries\libldap\geteffectiverightsctrl.c 80:1 -> 98:37
   -------------------------------------------------------------------------
   if (  ctrlp == NULL ) {
       LDAP_SET_LDERRNO( ld, LDAP_PARAM_ERROR, NULL, NULL );
       return ( LDAP_PARAM_ERROR );
   }
   if (NULL == authzid)
   {
       authzid = "";
   }
   
   /* create a ber package to hold the controlValue */
   if ( ( nsldapi_alloc_ber_with_options( ld, &ber ) ) != LDAP_SUCCESS ) {
       LDAP_SET_LDERRNO( ld, LDAP_NO_MEMORY, NULL, NULL );
       return( LDAP_NO_MEMORY );
   }
   
   if ( LBER_ERROR == ber_printf( ber, "{s{v}}", authzid, attrlist ) ) {
       LDAP_SET_LDERRNO( ld, LDAP_ENCODING_ERROR, NULL, NULL );
       ber_free( ber, 1 );
       return( LDAP_ENCODING_ERROR );
   -------------------------------------------------------------------------
   Potentially buggy differences:
1| }
>  ^
1| if (NULL == authzid)
>  ^^ ^^^^^ ^^ ^^^^^^^^
1| {
>  ^
1|     authzid = "";
>      ^^^^^^^ ^ ^^
   -------------------------------------------------------------------------
   c:\comm-central\directory\c-sdk\ldap\libraries\libldap\proxyauthctrl.c 137:1 -> 156:41
   -------------------------------------------------------------------------
   if (  ctrlp == NULL || authzid == NULL ) {
       LDAP_SET_LDERRNO( ld, LDAP_PARAM_ERROR, NULL, NULL );
       return ( LDAP_PARAM_ERROR );
   }
   
   /* create a ber package to hold the controlValue */
   if ( ( nsldapi_alloc_ber_with_options( ld, &ber ) ) != LDAP_SUCCESS ) {
       LDAP_SET_LDERRNO( ld, LDAP_NO_MEMORY, NULL, NULL );
       return( LDAP_NO_MEMORY );
   }
   
   
   
       if ( LBER_ERROR == ber_printf( ber,
                                      "s",
                                      authzid ) )
       {
           LDAP_SET_LDERRNO( ld, LDAP_ENCODING_ERROR, NULL, NULL );
           ber_free( ber, 1 );
           return( LDAP_ENCODING_ERROR );
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 91: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.671 | CED: 2 | FED: 4 (3.4%) | SZ: 117 | XF: F | XP: F | D: 6
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\docshell\base\nsdocshellenumerator.cpp 154:11 -> 181:14
   -------------------------------------------------------------------------
   nsresult rv;
   nsCOMPtr<nsIDocShellTreeNode> itemAsNode = do_QueryInterface(inItem, &rv);
   if (NS_FAILED(rv)) return rv;
   
   PRInt32   itemType;
   // add this item to the array
   if ((mDocShellType == nsIDocShellTreeItem::typeAll) ||
       (NS_SUCCEEDED(inItem->GetItemType(&itemType)) && (itemType == mDocShellType)))
   {
     if (!inItemArray.AppendElement(inItem))
       return NS_ERROR_OUT_OF_MEMORY;
   }
   
   PRInt32   numChildren;
   rv = itemAsNode->GetChildCount(&numChildren);
   if (NS_FAILED(rv)) return rv;
   
   for (PRInt32 i = 0; i < numChildren; ++i)
   {
     nsCOMPtr<nsIDocShellTreeItem> curChild;
     rv = itemAsNode->GetChildAt(i, getter_AddRefs(curChild));
     if (NS_FAILED(rv)) return rv;
   
     rv = BuildArrayRecursive(curChild, inItemArray);
     if (NS_FAILED(rv)) return rv;
   }
   
   return NS_OK;
   -------------------------------------------------------------------------
   Potentially buggy differences:
1| for (PRInt32 i = 0; i < numChildren; ++i)
>                        - -----------
2| for (PRInt32 i = numChildren - 1; i >= 0; --i)
>                   ^^^^^^^^^^^ ^      -- -
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\docshell\base\nsdocshellenumerator.cpp 187:11 -> 215:14
   -------------------------------------------------------------------------
   nsresult rv;
   nsCOMPtr<nsIDocShellTreeNode> itemAsNode = do_QueryInterface(inItem, &rv);
   if (NS_FAILED(rv)) return rv;
   
   PRInt32   numChildren;
   rv = itemAsNode->GetChildCount(&numChildren);
   if (NS_FAILED(rv)) return rv;
   
   for (PRInt32 i = numChildren - 1; i >= 0; --i)
   {
     nsCOMPtr<nsIDocShellTreeItem> curChild;
     rv = itemAsNode->GetChildAt(i, getter_AddRefs(curChild));
     if (NS_FAILED(rv)) return rv;
   
     rv = BuildArrayRecursive(curChild, inItemArray);
     if (NS_FAILED(rv)) return rv;
   }
   
   PRInt32   itemType;
   // add this item to the array
   if ((mDocShellType == nsIDocShellTreeItem::typeAll) ||
       (NS_SUCCEEDED(inItem->GetItemType(&itemType)) && (itemType == mDocShellType)))
   {
     if (!inItemArray.AppendElement(inItem))
       return NS_ERROR_OUT_OF_MEMORY;
   }
   
   
   return NS_OK;
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 92: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.514 | CED: 2 | FED: 9 (10.0%) | SZ: 90 | XF: F | XP: F | D: 46
   -------------------------------------------------------------------------
   c:\comm-central\mailnews\base\src\nsmessenger.cpp 948:30 -> 966:2
   -------------------------------------------------------------------------
   filePicker->SetDefaultString(defaultDisplayString);
   filePicker->AppendFilters(nsIFilePicker::filterAll);
   
   rv = GetLastSaveDirectory(getter_AddRefs(lastSaveDir));
   if (NS_SUCCEEDED(rv) && lastSaveDir)
     filePicker->SetDisplayDirectory(lastSaveDir);
   
   rv = filePicker->Show(&dialogResult);
   if (NS_FAILED(rv) || dialogResult == nsIFilePicker::returnCancel)
     return rv;
   
   rv = filePicker->GetFile(getter_AddRefs(localFile));
   NS_ENSURE_SUCCESS(rv, rv);
   
   SetLastSaveDirectory(localFile);
   
   nsCString dirName;
   rv = localFile->GetNativePath(dirName);
   NS_ENSURE_SUCCESS(rv, rv);
   -------------------------------------------------------------------------
   Potentially buggy differences:
2| rv = SetLastSaveDirectory(localFile);
>  ^^ ^

2| NS_ENSURE_SUCCESS(rv, rv);
>  ^^^^^^^^^^^^^^^^^^^^^ ^^^
   -------------------------------------------------------------------------
   c:\comm-central\mailnews\base\src\nsmessenger.cpp 1012:18 -> 1032:40
   -------------------------------------------------------------------------
   filePicker->Init(mWindow,
                    saveAttachmentStr,
                    nsIFilePicker::modeGetFolder);
   
   rv = GetLastSaveDirectory(getter_AddRefs(lastSaveDir));
   if (NS_SUCCEEDED(rv) && lastSaveDir)
     filePicker->SetDisplayDirectory(lastSaveDir);
   
   rv = filePicker->Show(&dialogResult);
   if (NS_FAILED(rv) || dialogResult == nsIFilePicker::returnCancel)
     return rv;
   
   rv = filePicker->GetFile(getter_AddRefs(localFile));
   NS_ENSURE_SUCCESS(rv, rv);
   
   rv = SetLastSaveDirectory(localFile);
   NS_ENSURE_SUCCESS(rv, rv);
   
   nsCString dirName;
   nsSaveAllAttachmentsState *saveState = nsnull;
   rv = localFile->GetNativePath(dirName);
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 93: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.642 | CED: 2 | FED: 4 (4.6%) | SZ: 87 | XF: F | XP: F | D: 11
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\layout\xul\base\src\nstextboxframe.cpp 709:20 -> 729:22
   -------------------------------------------------------------------------
   nscoord cwidth;
   nscoord twidth = 0;
   int length = mTitle.Length();
   int i;
   for (i = 0; i < length; ++i) {
       PRUnichar ch = mTitle.CharAt(i);
       // still in LTR mode
       aRenderingContext.GetWidth(ch,cwidth);
       if (twidth + cwidth > aWidth)
           break;
   
       twidth += cwidth;
   DI
       if (UCS2_CHAR_IS_BIDI(ch) ) {
         mState |= NS_FRAME_IS_BIDI;
       }
   MBIDI
   }
   
   if (i == 0)
       return;
   -------------------------------------------------------------------------
   Potentially buggy differences:
1| for (i = 0; i < length; ++i) {
>                - ------
2| for (i=length-1; i >= 0; --i) {
>         ^^^^^^^     -- -
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\layout\xul\base\src\nstextboxframe.cpp 740:20 -> 759:22
   -------------------------------------------------------------------------
   nscoord cwidth;
   nscoord twidth = 0;
   int length = mTitle.Length();
   int i;
   for (i=length-1; i >= 0; --i) {
       PRUnichar ch = mTitle.CharAt(i);
       aRenderingContext.GetWidth(ch,cwidth);
       if (twidth + cwidth > aWidth)
           break;
   
       twidth += cwidth;
   DI
       if (UCS2_CHAR_IS_BIDI(ch) ) {
         mState |= NS_FRAME_IS_BIDI;
       }
   MBIDI
   }
   
   if (i == length-1)
       return;
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 94: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.721 | CED: 5 | FED: 20 (13.2%) | SZ: 152 | XF: F | XP: F | D: 32
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\uriloader\exthandler\win\nsmimeinfowin.cpp 750:24 -> 789:59
   -------------------------------------------------------------------------
   workingRegistryPath = fileExtToUse;
   workingRegistryPath.AppendLiteral("\\OpenWithProgids");
   
   rv = regKey->Open(nsIWindowsRegKey::ROOT_KEY_CLASSES_ROOT,
                     workingRegistryPath,
                     nsIWindowsRegKey::ACCESS_QUERY_VALUE);
   if (NS_SUCCEEDED(rv)) {
     PRUint32 count = 0;
     if (NS_SUCCEEDED(regKey->GetValueCount(&count)) && count > 0) {
       for (PRUint32 index = 0; index < count; index++) {
         // HKEY_CLASSES_ROOT\.ext\OpenWithProgids\Windows.XPSReachViewer
         nsAutoString appProgId;
         if (NS_FAILED(regKey->GetValueName(index, appProgId)))
           continue;
   
         nsAutoString appFilesystemCommand;
         if (!GetProgIDVerbCommandHandler(appProgId,
                                          appFilesystemCommand,
                                          PR_FALSE) ||
             IsPathInList(appFilesystemCommand, trackList))
           continue;
         ProcessPath(appList, trackList, appFilesystemCommand);
       }
     }
     regKey->Close();
   }
   
   
   // 4) Add any non configured applications located in the MRU list
   
   // HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\
   // Explorer\FileExts\.ext\OpenWithList
   workingRegistryPath =
     NS_LITERAL_STRING("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FileExts\\");
   workingRegistryPath += fileExtToUse;
   workingRegistryPath.AppendLiteral("\\OpenWithList");
   
   rv = regKey->Open(nsIWindowsRegKey::ROOT_KEY_CURRENT_USER,
                     workingRegistryPath,
                     nsIWindowsRegKey::ACCESS_QUERY_VALUE);
   -------------------------------------------------------------------------
   Potentially buggy differences:
1| rv = regKey->Open(nsIWindowsRegKey::ROOT_KEY_CLASSES_ROOT,
>  ^^ ^                                ---------------------
2| regKey->Open(nsIWindowsRegKey::ROOT_KEY_CURRENT_USER,
>                                 ---------------------

1|   NS_LITERAL_STRING("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FileExts\\");
>    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
1| workingRegistryPath += fileExtToUse;
>  ^^^^^^^^^^^^^^^^^^^ ^^

1| workingRegistryPath.AppendLiteral("\\OpenWithList");
>  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
1| rv = regKey->Open(nsIWindowsRegKey::ROOT_KEY_CURRENT_USER,
>  ^^ ^                                ---------------------
2| regKey->Open(nsIWindowsRegKey::ROOT_KEY_CLASSES_ROOT,
>                                 ---------------------
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\uriloader\exthandler\win\nsmimeinfowin.cpp 821:6 -> 857:54
   -------------------------------------------------------------------------
   NS_LITERAL_STRING("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FileExts\\");
   workingRegistryPath += fileExtToUse;
   workingRegistryPath.AppendLiteral("\\OpenWithProgids");
   
   regKey->Open(nsIWindowsRegKey::ROOT_KEY_CURRENT_USER,
                workingRegistryPath,
                nsIWindowsRegKey::ACCESS_QUERY_VALUE);
   if (NS_SUCCEEDED(rv)) {
     PRUint32 count = 0;
     if (NS_SUCCEEDED(regKey->GetValueCount(&count)) && count > 0) {
       for (PRUint32 index = 0; index < count; index++) {
         nsAutoString appIndex, appProgId;
         if (NS_FAILED(regKey->GetValueName(index, appProgId)))
           continue;
   
         nsAutoString appFilesystemCommand;
         if (!GetProgIDVerbCommandHandler(appProgId,
                                          appFilesystemCommand,
                                          PR_FALSE) ||
             IsPathInList(appFilesystemCommand, trackList))
           continue;
         ProcessPath(appList, trackList, appFilesystemCommand);
       }
     }
     regKey->Close();
   }
   
   
   // 6) Check the perceived type value, and use this to lookup the perceivedtype
   // open with list.
   // http://msdn2.microsoft.com/en-us/library/aa969373.aspx
   
   workingRegistryPath = fileExtToUse;
   
   regKey->Open(nsIWindowsRegKey::ROOT_KEY_CLASSES_ROOT,
                workingRegistryPath,
                nsIWindowsRegKey::ACCESS_QUERY_VALUE);
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 95: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.522 | CED: 1 | FED: 1 (0.9%) | SZ: 114 | XF: F | XP: F | D: 874
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\layout\xul\base\src\nsboxframe.cpp 264:10 -> 296:40
   -------------------------------------------------------------------------
   mValign = vAlign_Top;
   mHalign = hAlign_Left;
   
   PRBool orient = PR_FALSE;
   GetInitialOrientation(orient);
   if (orient)
     mState |= NS_STATE_IS_HORIZONTAL;
   else
     mState &= ~NS_STATE_IS_HORIZONTAL;
   
   PRBool normal = PR_TRUE;
   GetInitialDirection(normal);
   if (normal)
     mState |= NS_STATE_IS_DIRECTION_NORMAL;
   else
     mState &= ~NS_STATE_IS_DIRECTION_NORMAL;
   
   GetInitialVAlignment(mValign);
   GetInitialHAlignment(mHalign);
   
   PRBool equalSize = PR_FALSE;
   GetInitialEqualSize(equalSize);
   if (equalSize)
         mState |= NS_STATE_EQUAL_SIZE;
     else
         mState &= ~NS_STATE_EQUAL_SIZE;
   
   PRBool autostretch = !!(mState & NS_STATE_AUTO_STRETCH);
   GetInitialAutoStretch(autostretch);
   if (autostretch)
         mState |= NS_STATE_AUTO_STRETCH;
      else
         mState &= ~NS_STATE_AUTO_STRETCH;
   -------------------------------------------------------------------------
   Potentially buggy differences:
1| PRBool orient = PR_FALSE;
>                  --------
2| PRBool orient = PR_TRUE;
>                  -------
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\layout\xul\base\src\nsboxframe.cpp 1170:14 -> 1217:40
   -------------------------------------------------------------------------
   mValign = nsBoxFrame::vAlign_Top;
   mHalign = nsBoxFrame::hAlign_Left;
   
   PRBool orient = PR_TRUE;
   GetInitialOrientation(orient);
   if (orient)
     mState |= NS_STATE_IS_HORIZONTAL;
   else
     mState &= ~NS_STATE_IS_HORIZONTAL;
   
   PRBool normal = PR_TRUE;
   GetInitialDirection(normal);
   if (normal)
     mState |= NS_STATE_IS_DIRECTION_NORMAL;
   else
     mState &= ~NS_STATE_IS_DIRECTION_NORMAL;
   
   GetInitialVAlignment(mValign);
   GetInitialHAlignment(mHalign);
   
   PRBool equalSize = PR_FALSE;
   GetInitialEqualSize(equalSize);
   if (equalSize)
     mState |= NS_STATE_EQUAL_SIZE;
   else
     mState &= ~NS_STATE_EQUAL_SIZE;
   
    DEBUG_LAYOUT
   PRBool debug = mState & NS_STATE_SET_TO_DEBUG;
   PRBool debugSet = GetInitialDebug(debug);
   if (debugSet) {
     mState |= NS_STATE_DEBUG_WAS_SET;
   
     if (debug)
       mState |= NS_STATE_SET_TO_DEBUG;
     else
       mState &= ~NS_STATE_SET_TO_DEBUG;
   } else {
     mState &= ~NS_STATE_DEBUG_WAS_SET;
   }
   
   
   PRBool autostretch = !!(mState & NS_STATE_AUTO_STRETCH);
   GetInitialAutoStretch(autostretch);
   if (autostretch)
     mState |= NS_STATE_AUTO_STRETCH;
   else
     mState &= ~NS_STATE_AUTO_STRETCH;
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 96: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.810 | CED: 1 | FED: 4 (1.8%) | SZ: 224 | XF: T | XP: F | D: inf
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\content\base\src\nshtmlcontentserializer.cpp 129:21 -> 180:4
   -------------------------------------------------------------------------
   aContent->GetAttr(namespaceID, attrName, valueStr);
   
   //
   // Filter out special case of <br type="_moz"> or <br _moz*>,
   // used by the editor.  Bug 16988.  Yuck.
   //
   if (aTagName == nsGkAtoms::br && attrName == nsGkAtoms::type &&
       StringBeginsWith(valueStr, _mozStr)) {
     continue;
   }
   
   if (mIsCopying && mIsFirstChildOfOL && (aTagName == nsGkAtoms::li) &&
       (attrName == nsGkAtoms::value)){
     // This is handled separately in SerializeLIValueAttribute()
     continue;
   }
   PRBool isJS = IsJavaScript(aContent, attrName, namespaceID, valueStr);
   
   if (((attrName == nsGkAtoms::href) ||
        (attrName == nsGkAtoms::src))) {
     // Make all links absolute when converting only the selection:
     if (mFlags & nsIDocumentEncoder::OutputAbsoluteLinks) {
       // Would be nice to handle OBJECT and APPLET tags,
       // but that gets more complicated since we have to
       // search the tag list for CODEBASE as well.
       // For now, just leave them relative.
       nsCOMPtr<nsIURI> uri = aContent->GetBaseURI();
       if (uri) {
         nsAutoString absURI;
         rv = NS_MakeAbsoluteURI(absURI, valueStr, uri);
         if (NS_SUCCEEDED(rv)) {
           valueStr = absURI;
         }
       }
     }
     // Need to escape URI.
     nsAutoString tempURI(valueStr);
     if (!isJS && NS_FAILED(EscapeURI(aContent, tempURI, valueStr)))
       valueStr = tempURI;
   }
   
   if (mRewriteEncodingDeclaration && aTagName == nsGkAtoms::meta &&
       attrName == nsGkAtoms::content) {
     // If we're serializing a <meta http-equiv="content-type">,
     // use the proper value, rather than what's in the document.
     nsAutoString header;
     aContent->GetAttr(kNameSpaceID_None, nsGkAtoms::httpEquiv, header);
     if (header.LowerCaseEqualsLiteral("content-type")) {
       valueStr = NS_LITERAL_STRING("text/html; charset=") +
         NS_ConvertASCIItoUTF16(mCharset);
     }
   }
   -------------------------------------------------------------------------
   Potentially buggy differences:
2| if (namespaceID == kNameSpaceID_None &&
>      ^^^^^^^^^^^ ^^ ^^^^^^^^^^^^^^^^^ ^^
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\content\base\src\nsxhtmlcontentserializer.cpp 378:6 -> 425:6
   -------------------------------------------------------------------------
   if (namespaceID == kNameSpaceID_None && aTagName == nsGkAtoms::br && attrName == nsGkAtoms::type
       && StringBeginsWith(valueStr, _mozStr)) {
     continue;
   }
   
   if (mIsCopying && mIsFirstChildOfOL && (aTagName == nsGkAtoms::li)
       && (attrName == nsGkAtoms::value)) {
     // This is handled separately in SerializeLIValueAttribute()
     continue;
   }
   
   isJS = IsJavaScript(aContent, attrName, namespaceID, valueStr);
   
   if (namespaceID == kNameSpaceID_None &&
       ((attrName == nsGkAtoms::href) ||
       (attrName == nsGkAtoms::src))) {
     // Make all links absolute when converting only the selection:
     if (mFlags & nsIDocumentEncoder::OutputAbsoluteLinks) {
       // Would be nice to handle OBJECT and APPLET tags,
       // but that gets more complicated since we have to
       // search the tag list for CODEBASE as well.
       // For now, just leave them relative.
       nsCOMPtr<nsIURI> uri = aContent->GetBaseURI();
       if (uri) {
         nsAutoString absURI;
         rv = NS_MakeAbsoluteURI(absURI, valueStr, uri);
         if (NS_SUCCEEDED(rv)) {
           valueStr = absURI;
         }
       }
     }
     // Need to escape URI.
     nsAutoString tempURI(valueStr);
     if (!isJS && NS_FAILED(EscapeURI(aContent, tempURI, valueStr)))
       valueStr = tempURI;
   }
   
   if (mRewriteEncodingDeclaration && aTagName == nsGkAtoms::meta &&
       attrName == nsGkAtoms::content) {
     // If we're serializing a <meta http-equiv="content-type">,
     // use the proper value, rather than what's in the document.
     nsAutoString header;
     aContent->GetAttr(kNameSpaceID_None, nsGkAtoms::httpEquiv, header);
     if (header.LowerCaseEqualsLiteral("content-type")) {
       valueStr = NS_LITERAL_STRING("text/html; charset=") +
         NS_ConvertASCIItoUTF16(mCharset);
     }
   }
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 97: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.533 | CED: 1 | FED: 7 (5.4%) | SZ: 130 | XF: F | XP: F | D: 11
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\editor\libeditor\html\nshtmleditor.cpp 2594:25 -> 2616:54
   -------------------------------------------------------------------------
   nsCOMPtr<nsIEditRules> kungFuDeathGrip(mRules);
   
   nsCOMPtr<nsISelection> selection;
   PRBool cancel, handled;
   
   nsAutoEditBatch beginBatching(this);
   nsAutoRules beginRulesSniffing(this, kOpRemoveList, nsIEditor::eNext);
   
   // pre-process
   res = GetSelection(getter_AddRefs(selection));
   NS_ENSURE_SUCCESS(res, res);
   NS_ENSURE_TRUE(selection, NS_ERROR_NULL_POINTER);
   
   nsTextRulesInfo ruleInfo(nsTextEditRules::kRemoveList);
   if (aListType.LowerCaseEqualsLiteral("ol"))
     ruleInfo.bOrdered = PR_TRUE;
   else  ruleInfo.bOrdered = PR_FALSE;
   res = mRules->WillDoAction(selection, &ruleInfo, &cancel, &handled);
   if (cancel || (NS_FAILED(res))) return res;
   
   // no default behavior for this yet.  what would it mean?
   
   res = mRules->DidDoAction(selection, &ruleInfo, res);
   -------------------------------------------------------------------------
   Potentially buggy differences:
2| if (!handled)
>  ^^ ^^^^^^^^^^
2| {
>  ^
2| }
>  ^
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\editor\libeditor\html\nshtmleditor.cpp 2627:25 -> 2649:54
   -------------------------------------------------------------------------
   nsCOMPtr<nsIEditRules> kungFuDeathGrip(mRules);
   
   nsCOMPtr<nsISelection> selection;
   PRBool cancel, handled;
   
   nsAutoEditBatch beginBatching(this);
   nsAutoRules beginRulesSniffing(this, kOpMakeDefListItem, nsIEditor::eNext);
   
   // pre-process
   res = GetSelection(getter_AddRefs(selection));
   NS_ENSURE_SUCCESS(res, res);
   NS_ENSURE_TRUE(selection, NS_ERROR_NULL_POINTER);
   nsTextRulesInfo ruleInfo(nsTextEditRules::kMakeDefListItem);
   ruleInfo.blockType = &aItemType;
   res = mRules->WillDoAction(selection, &ruleInfo, &cancel, &handled);
   if (cancel || (NS_FAILED(res))) return res;
   
   if (!handled)
   {
     // todo: no default for now.  we count on rules to handle it.
   }
   
   res = mRules->DidDoAction(selection, &ruleInfo, res);
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 98: 4 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.771 | CED: 1 | FED: 11 (4.9%) | SZ: 223 | XF: F | XP: F | D: 67
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\netwerk\protocol\http\nshttphandler.cpp 1263:14 -> 1297:25
   -------------------------------------------------------------------------
   available = size + ++n * 11 + 1;
   q_Accept = new char[available];
   if (!q_Accept) {
       nsCRT::free(o_Accept);
       return NS_ERROR_OUT_OF_MEMORY;
   }
   *q_Accept = '\0';
   q = 1.0;
   dec = q / (double) n;
   n = 0;
   p2 = q_Accept;
   for (token = nsCRT::strtok(o_Accept, ",", &p);
        token != (char *) 0;
        token = nsCRT::strtok(p, ",", &p))
   {
       token = net_FindCharNotInSet(token, HTTP_LWS);
       char* trim;
       trim = net_FindCharInSet(token, ";" HTTP_LWS);
       if (trim != (char*)0)  // remove "; q=..." if present
           *trim = '\0';
   
       if (*token != '\0') {
           comma = n++ != 0 ? "," : ""; // delimiter if not first item
           PRUint32 u = QVAL_TO_UINT(q);
           if (u < 10)
               wrote = PR_snprintf(p2, available, "%s%s;q=0.%u", comma, token, u);
           else
               wrote = PR_snprintf(p2, available, "%s%s", comma, token);
           q -= dec;
           p2 += wrote;
           available -= wrote;
           NS_ASSERTION(available > 0, "allocated string not long enough");
       }
   }
   nsCRT::free(o_Accept);
   -------------------------------------------------------------------------
   Potentially buggy differences:
1| if (!q_Accept) {
>      ---------- -
1|     nsCRT::free(o_Accept);
>      ---------------------
2| if ((char *) 0 == q_Accept)
>      ----- -- - -- ---------
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\netwerk\protocol\http\nshttphandler.cpp 1364:14 -> 1394:4
   -------------------------------------------------------------------------
   available = size + ++n * 11 + 1;
   q_Accept = new char[available];
   if ((char *) 0 == q_Accept)
       return NS_ERROR_OUT_OF_MEMORY;
   *q_Accept = '\0';
   q = 1.0;
   dec = q / (double) n;
   n = 0;
   p2 = q_Accept;
   for (token = nsCRT::strtok(o_Accept, ",", &p);
        token != (char *) 0;
        token = nsCRT::strtok(p, ",", &p)) {
       token = net_FindCharNotInSet(token, HTTP_LWS);
       char* trim;
       trim = net_FindCharInSet(token, ";" HTTP_LWS);
       if (trim != (char*)0)  // remove "; q=..." if present
           *trim = '\0';
   
       if (*token != '\0') {
           comma = n++ != 0 ? "," : ""; // delimiter if not first item
           u = QVAL_TO_UINT(q);
           if (u < 10)
               wrote = PR_snprintf(p2, available, "%s%s;q=0.%u", comma, token, u);
           else
               wrote = PR_snprintf(p2, available, "%s%s", comma, token);
           q -= dec;
           p2 += wrote;
           available -= wrote;
           NS_ASSERTION(available > 0, "allocated string not long enough");
       }
   }
   -------------------------------------------------------------------------

 Pair b.) TxtSim: 0.771 | CED: 1 | FED: 11 (4.9%) | SZ: 223 | XF: T | XP: T | D: inf
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\netwerk\protocol\http\nshttphandler.cpp 1263:14 -> 1297:25
   -------------------------------------------------------------------------
   available = size + ++n * 11 + 1;
   q_Accept = new char[available];
   if (!q_Accept) {
       nsCRT::free(o_Accept);
       return NS_ERROR_OUT_OF_MEMORY;
   }
   *q_Accept = '\0';
   q = 1.0;
   dec = q / (double) n;
   n = 0;
   p2 = q_Accept;
   for (token = nsCRT::strtok(o_Accept, ",", &p);
        token != (char *) 0;
        token = nsCRT::strtok(p, ",", &p))
   {
       token = net_FindCharNotInSet(token, HTTP_LWS);
       char* trim;
       trim = net_FindCharInSet(token, ";" HTTP_LWS);
       if (trim != (char*)0)  // remove "; q=..." if present
           *trim = '\0';
   
       if (*token != '\0') {
           comma = n++ != 0 ? "," : ""; // delimiter if not first item
           PRUint32 u = QVAL_TO_UINT(q);
           if (u < 10)
               wrote = PR_snprintf(p2, available, "%s%s;q=0.%u", comma, token, u);
           else
               wrote = PR_snprintf(p2, available, "%s%s", comma, token);
           q -= dec;
           p2 += wrote;
           available -= wrote;
           NS_ASSERTION(available > 0, "allocated string not long enough");
       }
   }
   nsCRT::free(o_Accept);
   -------------------------------------------------------------------------
   Potentially buggy differences:
1| if (!q_Accept) {
>      ---------- -
1|     nsCRT::free(o_Accept);
>      ---------------------
2| if ((char *) 0 == q_Accept)
>      ----- -- - -- ---------
   -------------------------------------------------------------------------
   c:\mozilla-central\netwerk\protocol\http\nshttphandler.cpp 1364:14 -> 1394:4
   -------------------------------------------------------------------------
   available = size + ++n * 11 + 1;
   q_Accept = new char[available];
   if ((char *) 0 == q_Accept)
       return NS_ERROR_OUT_OF_MEMORY;
   *q_Accept = '\0';
   q = 1.0;
   dec = q / (double) n;
   n = 0;
   p2 = q_Accept;
   for (token = nsCRT::strtok(o_Accept, ",", &p);
        token != (char *) 0;
        token = nsCRT::strtok(p, ",", &p)) {
       token = net_FindCharNotInSet(token, HTTP_LWS);
       char* trim;
       trim = net_FindCharInSet(token, ";" HTTP_LWS);
       if (trim != (char*)0)  // remove "; q=..." if present
           *trim = '\0';
   
       if (*token != '\0') {
           comma = n++ != 0 ? "," : ""; // delimiter if not first item
           u = QVAL_TO_UINT(q);
           if (u < 10)
               wrote = PR_snprintf(p2, available, "%s%s;q=0.%u", comma, token, u);
           else
               wrote = PR_snprintf(p2, available, "%s%s", comma, token);
           q -= dec;
           p2 += wrote;
           available -= wrote;
           NS_ASSERTION(available > 0, "allocated string not long enough");
       }
   }
   -------------------------------------------------------------------------

 Pair c.) TxtSim: 0.771 | CED: 1 | FED: 11 (4.9%) | SZ: 223 | XF: T | XP: T | D: inf
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\netwerk\protocol\http\nshttphandler.cpp 1364:14 -> 1394:4
   -------------------------------------------------------------------------
   available = size + ++n * 11 + 1;
   q_Accept = new char[available];
   if ((char *) 0 == q_Accept)
       return NS_ERROR_OUT_OF_MEMORY;
   *q_Accept = '\0';
   q = 1.0;
   dec = q / (double) n;
   n = 0;
   p2 = q_Accept;
   for (token = nsCRT::strtok(o_Accept, ",", &p);
        token != (char *) 0;
        token = nsCRT::strtok(p, ",", &p)) {
       token = net_FindCharNotInSet(token, HTTP_LWS);
       char* trim;
       trim = net_FindCharInSet(token, ";" HTTP_LWS);
       if (trim != (char*)0)  // remove "; q=..." if present
           *trim = '\0';
   
       if (*token != '\0') {
           comma = n++ != 0 ? "," : ""; // delimiter if not first item
           u = QVAL_TO_UINT(q);
           if (u < 10)
               wrote = PR_snprintf(p2, available, "%s%s;q=0.%u", comma, token, u);
           else
               wrote = PR_snprintf(p2, available, "%s%s", comma, token);
           q -= dec;
           p2 += wrote;
           available -= wrote;
           NS_ASSERTION(available > 0, "allocated string not long enough");
       }
   }
   -------------------------------------------------------------------------
   Potentially buggy differences:
1| if ((char *) 0 == q_Accept)
>      ----- -- - -- ---------
2| if (!q_Accept) {
>      ---------- -
2|     nsCRT::free(o_Accept);
>      ---------------------
   -------------------------------------------------------------------------
   c:\mozilla-central\netwerk\protocol\http\nshttphandler.cpp 1263:14 -> 1297:25
   -------------------------------------------------------------------------
   available = size + ++n * 11 + 1;
   q_Accept = new char[available];
   if (!q_Accept) {
       nsCRT::free(o_Accept);
       return NS_ERROR_OUT_OF_MEMORY;
   }
   *q_Accept = '\0';
   q = 1.0;
   dec = q / (double) n;
   n = 0;
   p2 = q_Accept;
   for (token = nsCRT::strtok(o_Accept, ",", &p);
        token != (char *) 0;
        token = nsCRT::strtok(p, ",", &p))
   {
       token = net_FindCharNotInSet(token, HTTP_LWS);
       char* trim;
       trim = net_FindCharInSet(token, ";" HTTP_LWS);
       if (trim != (char*)0)  // remove "; q=..." if present
           *trim = '\0';
   
       if (*token != '\0') {
           comma = n++ != 0 ? "," : ""; // delimiter if not first item
           PRUint32 u = QVAL_TO_UINT(q);
           if (u < 10)
               wrote = PR_snprintf(p2, available, "%s%s;q=0.%u", comma, token, u);
           else
               wrote = PR_snprintf(p2, available, "%s%s", comma, token);
           q -= dec;
           p2 += wrote;
           available -= wrote;
           NS_ASSERTION(available > 0, "allocated string not long enough");
       }
   }
   nsCRT::free(o_Accept);
   -------------------------------------------------------------------------

 Pair d.) TxtSim: 0.771 | CED: 1 | FED: 11 (4.9%) | SZ: 223 | XF: F | XP: F | D: 67
   -------------------------------------------------------------------------
   c:\mozilla-central\netwerk\protocol\http\nshttphandler.cpp 1263:14 -> 1297:25
   -------------------------------------------------------------------------
   available = size + ++n * 11 + 1;
   q_Accept = new char[available];
   if (!q_Accept) {
       nsCRT::free(o_Accept);
       return NS_ERROR_OUT_OF_MEMORY;
   }
   *q_Accept = '\0';
   q = 1.0;
   dec = q / (double) n;
   n = 0;
   p2 = q_Accept;
   for (token = nsCRT::strtok(o_Accept, ",", &p);
        token != (char *) 0;
        token = nsCRT::strtok(p, ",", &p))
   {
       token = net_FindCharNotInSet(token, HTTP_LWS);
       char* trim;
       trim = net_FindCharInSet(token, ";" HTTP_LWS);
       if (trim != (char*)0)  // remove "; q=..." if present
           *trim = '\0';
   
       if (*token != '\0') {
           comma = n++ != 0 ? "," : ""; // delimiter if not first item
           PRUint32 u = QVAL_TO_UINT(q);
           if (u < 10)
               wrote = PR_snprintf(p2, available, "%s%s;q=0.%u", comma, token, u);
           else
               wrote = PR_snprintf(p2, available, "%s%s", comma, token);
           q -= dec;
           p2 += wrote;
           available -= wrote;
           NS_ASSERTION(available > 0, "allocated string not long enough");
       }
   }
   nsCRT::free(o_Accept);
   -------------------------------------------------------------------------
   Potentially buggy differences:
1| if (!q_Accept) {
>      ---------- -
1|     nsCRT::free(o_Accept);
>      ---------------------
2| if ((char *) 0 == q_Accept)
>      ----- -- - -- ---------
   -------------------------------------------------------------------------
   c:\mozilla-central\netwerk\protocol\http\nshttphandler.cpp 1364:14 -> 1394:4
   -------------------------------------------------------------------------
   available = size + ++n * 11 + 1;
   q_Accept = new char[available];
   if ((char *) 0 == q_Accept)
       return NS_ERROR_OUT_OF_MEMORY;
   *q_Accept = '\0';
   q = 1.0;
   dec = q / (double) n;
   n = 0;
   p2 = q_Accept;
   for (token = nsCRT::strtok(o_Accept, ",", &p);
        token != (char *) 0;
        token = nsCRT::strtok(p, ",", &p)) {
       token = net_FindCharNotInSet(token, HTTP_LWS);
       char* trim;
       trim = net_FindCharInSet(token, ";" HTTP_LWS);
       if (trim != (char*)0)  // remove "; q=..." if present
           *trim = '\0';
   
       if (*token != '\0') {
           comma = n++ != 0 ? "," : ""; // delimiter if not first item
           u = QVAL_TO_UINT(q);
           if (u < 10)
               wrote = PR_snprintf(p2, available, "%s%s;q=0.%u", comma, token, u);
           else
               wrote = PR_snprintf(p2, available, "%s%s", comma, token);
           q -= dec;
           p2 += wrote;
           available -= wrote;
           NS_ASSERTION(available > 0, "allocated string not long enough");
       }
   }
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 99: 2 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.608 | CED: 1 | FED: 4 (3.4%) | SZ: 117 | XF: F | XP: F | D: 181
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\uriloader\exthandler\win\nsmimeinfowin.cpp 720:37 -> 744:4
   -------------------------------------------------------------------------
   workingRegistryPath.AppendLiteral("\\OpenWithList");
   
   rv = regKey->Open(nsIWindowsRegKey::ROOT_KEY_CLASSES_ROOT,
                     workingRegistryPath,
                     nsIWindowsRegKey::ACCESS_QUERY_VALUE);
   if (NS_SUCCEEDED(rv)) {
     PRUint32 count = 0;
     if (NS_SUCCEEDED(regKey->GetValueCount(&count)) && count > 0) {
       for (PRUint32 index = 0; index < count; index++) {
         nsAutoString appName;
         if (NS_FAILED(regKey->GetValueName(index, appName)))
           continue;
   
         // HKEY_CLASSES_ROOT\Applications\firefox.exe = "path params"
         nsAutoString appFilesystemCommand;
         if (!GetAppsVerbCommandHandler(appName,
                                        appFilesystemCommand,
                                        PR_FALSE) ||
             IsPathInList(appFilesystemCommand, trackList))
           continue;
         ProcessPath(appList, trackList, appFilesystemCommand);
       }
     }
     regKey->Close();
   }
   -------------------------------------------------------------------------
   Potentially buggy differences:
2|                   nsIWindowsRegKey::ACCESS_ENUMERATE_SUB_KEYS|
>                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\uriloader\exthandler\win\nsmimeinfowin.cpp 925:5 -> 949:20
   -------------------------------------------------------------------------
   rv = regKey->Open(nsIWindowsRegKey::ROOT_KEY_CLASSES_ROOT,
                     workingRegistryPath,
                     nsIWindowsRegKey::ACCESS_ENUMERATE_SUB_KEYS|
                     nsIWindowsRegKey::ACCESS_QUERY_VALUE);
   if (NS_SUCCEEDED(rv)) {
     PRUint32 count = 0;
     if (NS_SUCCEEDED(regKey->GetChildCount(&count)) && count > 0) {
       for (PRUint32 index = 0; index < count; index++) {
         nsAutoString appName;
         if (NS_FAILED(regKey->GetChildName(index, appName)))
           continue;
   
         // HKEY_CLASSES_ROOT\Applications\firefox.exe = "path params"
         nsAutoString appFilesystemCommand;
         if (!GetAppsVerbCommandHandler(appName, appFilesystemCommand,
                                        PR_FALSE) ||
             IsPathInList(appFilesystemCommand, trackList))
           continue;
         ProcessPath(appList, trackList, appFilesystemCommand);
       }
     }
   }
   
   // Return to the caller
   *_retval = appList;
   -------------------------------------------------------------------------

 Pair b.) TxtSim: 0.637 | CED: 1 | FED: 4 (3.4%) | SZ: 117 | XF: F | XP: F | D: 6
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\uriloader\exthandler\win\nsmimeinfowin.cpp 898:5 -> 919:2
   -------------------------------------------------------------------------
   rv = regKey->Open(nsIWindowsRegKey::ROOT_KEY_CLASSES_ROOT,
                     workingRegistryPath,
                     nsIWindowsRegKey::ACCESS_QUERY_VALUE);
   if (NS_SUCCEEDED(rv)) {
     PRUint32 count = 0;
     if (NS_SUCCEEDED(regKey->GetValueCount(&count)) && count > 0) {
       for (PRUint32 index = 0; index < count; index++) {
         nsAutoString appName;
         if (NS_FAILED(regKey->GetValueName(index, appName)))
           continue;
   
         // HKEY_CLASSES_ROOT\Applications\firefox.exe = "path params"
         nsAutoString appFilesystemCommand;
         if (!GetAppsVerbCommandHandler(appName, appFilesystemCommand,
                                        PR_FALSE) ||
             IsPathInList(appFilesystemCommand, trackList))
           continue;
         ProcessPath(appList, trackList, appFilesystemCommand);
       }
     }
     regKey->Close();
   }
   -------------------------------------------------------------------------
   Potentially buggy differences:
2|                   nsIWindowsRegKey::ACCESS_ENUMERATE_SUB_KEYS|
>                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\uriloader\exthandler\win\nsmimeinfowin.cpp 925:5 -> 949:20
   -------------------------------------------------------------------------
   rv = regKey->Open(nsIWindowsRegKey::ROOT_KEY_CLASSES_ROOT,
                     workingRegistryPath,
                     nsIWindowsRegKey::ACCESS_ENUMERATE_SUB_KEYS|
                     nsIWindowsRegKey::ACCESS_QUERY_VALUE);
   if (NS_SUCCEEDED(rv)) {
     PRUint32 count = 0;
     if (NS_SUCCEEDED(regKey->GetChildCount(&count)) && count > 0) {
       for (PRUint32 index = 0; index < count; index++) {
         nsAutoString appName;
         if (NS_FAILED(regKey->GetChildName(index, appName)))
           continue;
   
         // HKEY_CLASSES_ROOT\Applications\firefox.exe = "path params"
         nsAutoString appFilesystemCommand;
         if (!GetAppsVerbCommandHandler(appName, appFilesystemCommand,
                                        PR_FALSE) ||
             IsPathInList(appFilesystemCommand, trackList))
           continue;
         ProcessPath(appList, trackList, appFilesystemCommand);
       }
     }
   }
   
   // Return to the caller
   *_retval = appList;
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 100: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.613 | CED: 1 | FED: 3 (3.8%) | SZ: 80 | XF: F | XP: F | D: 7
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\content\xslt\src\xpath\txcorefunctioncall.cpp 441:25 -> 458:12
   -------------------------------------------------------------------------
   nsAutoString arg1;
   rv = mParams[0]->evaluateToString(aContext, arg1);
   NS_ENSURE_SUCCESS(rv, rv);
   
   nsAutoString arg2;
   rv = mParams[1]->evaluateToString(aContext, arg2);
   NS_ENSURE_SUCCESS(rv, rv);
   
   if (arg2.IsEmpty()) {
       return aContext->recycler()->getStringResult(arg1, aResult);
   }
   
   PRInt32 idx = arg1.Find(arg2);
   if (idx == kNotFound) {
       aContext->recycler()->getEmptyStringResult(aResult);
   
       return NS_OK;
   }
   -------------------------------------------------------------------------
   Potentially buggy differences:
2|     return NS_OK;
>      ^^^^^^ ^^^^^
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\content\xslt\src\xpath\txcorefunctioncall.cpp 465:25 -> 484:12
   -------------------------------------------------------------------------
   nsAutoString arg2;
   rv = mParams[1]->evaluateToString(aContext, arg2);
   NS_ENSURE_SUCCESS(rv, rv);
   
   if (arg2.IsEmpty()) {
       aContext->recycler()->getEmptyStringResult(aResult);
   
       return NS_OK;
   }
   
   nsAutoString arg1;
   rv = mParams[0]->evaluateToString(aContext, arg1);
   NS_ENSURE_SUCCESS(rv, rv);
   
   PRInt32 idx = arg1.Find(arg2);
   if (idx == kNotFound) {
       aContext->recycler()->getEmptyStringResult(aResult);
   
       return NS_OK;
   }
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 101: 2 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.520 | CED: 1 | FED: 11 (14.9%) | SZ: 74 | XF: T | XP: F | D: inf
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\content\events\src\nsdomdragevent.cpp 48:19 -> 59:2
   -------------------------------------------------------------------------
   : nsDOMMouseEvent(aPresContext, aEvent ? aEvent :
                     new nsDragEvent(PR_FALSE, 0, nsnull))
   {
     if (aEvent) {
       mEventIsInternal = PR_FALSE;
     }
     else {
       mEventIsInternal = PR_TRUE;
       mEvent->time = PR_Now();
       mEvent->refPoint.x = mEvent->refPoint.y = 0;
       static_cast<nsMouseEvent*>(mEvent)->inputSource = nsIDOMNSMouseEvent::MOZ_SOURCE_UNKNOWN;
     }
   -------------------------------------------------------------------------
   Potentially buggy differences:
2|   NS_ASSERTION(mEvent->eventStructType == NS_SIMPLE_GESTURE_EVENT, "event type mismatch");
>    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ^^ ^^^^^^^^^^^^^^^^^^^^^^^^ ^^^^^^^^^^^^^^^^^^^^^^
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\content\events\src\nsdomsimplegestureevent.cpp 44:19 -> 56:0
   -------------------------------------------------------------------------
   : nsDOMMouseEvent(aPresContext, aEvent ? aEvent : new nsSimpleGestureEvent(PR_FALSE, 0, nsnull, 0, 0.0))
   {
     NS_ASSERTION(mEvent->eventStructType == NS_SIMPLE_GESTURE_EVENT, "event type mismatch");
   
     if (aEvent) {
       mEventIsInternal = PR_FALSE;
     } else {
       mEventIsInternal = PR_TRUE;
       mEvent->time = PR_Now();
       mEvent->refPoint.x = mEvent->refPoint.y = 0;
       static_cast<nsMouseEvent*>(mEvent)->inputSource = nsIDOMNSMouseEvent::MOZ_SOURCE_UNKNOWN;
     }
   }
   -------------------------------------------------------------------------

 Pair b.) TxtSim: 0.520 | CED: 1 | FED: 11 (14.9%) | SZ: 74 | XF: T | XP: F | D: inf
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\content\events\src\nsdommousescrollevent.cpp 46:19 -> 56:2
   -------------------------------------------------------------------------
   : nsDOMMouseEvent(aPresContext, aEvent ? aEvent :
                                   new nsMouseScrollEvent(PR_FALSE, 0, nsnull))
   {
     if (aEvent) {
       mEventIsInternal = PR_FALSE;
     } else {
       mEventIsInternal = PR_TRUE;
       mEvent->time = PR_Now();
       mEvent->refPoint.x = mEvent->refPoint.y = 0;
       static_cast<nsMouseEvent*>(mEvent)->inputSource = nsIDOMNSMouseEvent::MOZ_SOURCE_UNKNOWN;
     }
   -------------------------------------------------------------------------
   Potentially buggy differences:
2|   NS_ASSERTION(mEvent->eventStructType == NS_SIMPLE_GESTURE_EVENT, "event type mismatch");
>    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ^^ ^^^^^^^^^^^^^^^^^^^^^^^^ ^^^^^^^^^^^^^^^^^^^^^^
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\content\events\src\nsdomsimplegestureevent.cpp 44:19 -> 56:0
   -------------------------------------------------------------------------
   : nsDOMMouseEvent(aPresContext, aEvent ? aEvent : new nsSimpleGestureEvent(PR_FALSE, 0, nsnull, 0, 0.0))
   {
     NS_ASSERTION(mEvent->eventStructType == NS_SIMPLE_GESTURE_EVENT, "event type mismatch");
   
     if (aEvent) {
       mEventIsInternal = PR_FALSE;
     } else {
       mEventIsInternal = PR_TRUE;
       mEvent->time = PR_Now();
       mEvent->refPoint.x = mEvent->refPoint.y = 0;
       static_cast<nsMouseEvent*>(mEvent)->inputSource = nsIDOMNSMouseEvent::MOZ_SOURCE_UNKNOWN;
     }
   }
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 102: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.600 | CED: 1 | FED: 1 (1.5%) | SZ: 65 | XF: F | XP: F | D: 3
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\js\src\jsmath.cpp 622:0 -> 634:0
   -------------------------------------------------------------------------
   math_max_tn(jsdouble d, jsdouble p)
   {
       if (JSDOUBLE_IS_NaN(d) || JSDOUBLE_IS_NaN(p))
           return js_NaN;
   
       if (p == 0 && p == d) {
           // Max prefers 0.0 to -0.0.
           if (js_copysign(1.0, d) == -1)
               return p;
           return d;
       }
       return (p > d) ? p : d;
   }
   -------------------------------------------------------------------------
   Potentially buggy differences:
1|         if (js_copysign(1.0, d) == -1)
>                               -
2|         if (js_copysign (1.0, p) == -1)
>                                -
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\js\src\jsmath.cpp 637:0 -> 649:0
   -------------------------------------------------------------------------
   math_min_tn(jsdouble d, jsdouble p)
   {
       if (JSDOUBLE_IS_NaN(d) || JSDOUBLE_IS_NaN(p))
           return js_NaN;
   
       if (p == 0 && p == d) {
           // Min prefers -0.0 to 0.0.
           if (js_copysign (1.0, p) == -1)
               return p;
           return d;
       }
       return (p < d) ? p : d;
   }
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 103: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.596 | CED: 1 | FED: 3 (2.4%) | SZ: 125 | XF: F | XP: F | D: 427
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\js\src\jsdbgapi.cpp 516:0 -> 539:0
   -------------------------------------------------------------------------
   js_SweepWatchPoints(JSContext *cx)
   {
       JSRuntime *rt;
       JSWatchPoint *wp, *next;
       uint32 sample;
   
       rt = cx->runtime;
       DBG_LOCK(rt);
       for (wp = (JSWatchPoint *)rt->watchPointList.next;
            &wp->links != &rt->watchPointList;
            wp = next) {
           next = (JSWatchPoint *)wp->links.next;
           if (js_IsAboutToBeFinalized(wp->object)) {
               sample = rt->debuggerMutations;
   
               /* Ignore failures. */
               DropWatchPointAndUnlock(cx, wp, JSWP_LIVE);
               DBG_LOCK(rt);
               if (rt->debuggerMutations != sample + 1)
                   next = (JSWatchPoint *)rt->watchPointList.next;
           }
       }
       DBG_UNLOCK(rt);
   }
   -------------------------------------------------------------------------
   Potentially buggy differences:
2|         if (!DropWatchPointAndUnlock(cx, wp, JSWP_LIVE))
>          ^^ ^^
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\js\src\jsdbgapi.cpp 966:14 -> 985:18
   -------------------------------------------------------------------------
   JSRuntime *rt;
   JSWatchPoint *wp, *next;
   uint32 sample;
   
   rt = cx->runtime;
   DBG_LOCK(rt);
   for (wp = (JSWatchPoint *)rt->watchPointList.next;
        &wp->links != &rt->watchPointList;
        wp = next) {
       next = (JSWatchPoint *)wp->links.next;
       if (wp->object == obj) {
           sample = rt->debuggerMutations;
           if (!DropWatchPointAndUnlock(cx, wp, JSWP_LIVE))
               return JS_FALSE;
           DBG_LOCK(rt);
           if (rt->debuggerMutations != sample + 1)
               next = (JSWatchPoint *)rt->watchPointList.next;
       }
   }
   DBG_UNLOCK(rt);
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 104: 2 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.797 | CED: 1 | FED: 6 (3.0%) | SZ: 201 | XF: F | XP: F | D: 3
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\dom\indexeddb\idbobjectstore.cpp 907:19 -> 951:0
   -------------------------------------------------------------------------
   IDBObjectStore::Add(jsval aValue,
                       jsval aKey,
                       JSContext* aCx,
                       PRUint8 aOptionalArgCount,
                       nsIIDBRequest** _retval)
   {
     NS_ASSERTION(NS_IsMainThread(), "Wrong thread!");
   
     if (!mTransaction->TransactionIsOpen()) {
       return NS_ERROR_UNEXPECTED;
     }
   
     if (mMode != nsIIDBTransaction::READ_WRITE) {
       return NS_ERROR_OBJECT_IS_IMMUTABLE;
     }
   
     if (aOptionalArgCount < 1) {
       aKey = JSVAL_VOID;
     }
   
     nsString jsonValue;
     Key key;
     nsTArray<IndexUpdateInfo> updateInfo;
   
     nsresult rv = GetAddInfo(aCx, aValue, aKey, jsonValue, key, updateInfo);
     if (NS_FAILED(rv)) {
       return rv;
     }
   
     if (key.IsUnset() && !mAutoIncrement) {
       return NS_ERROR_ILLEGAL_VALUE;
     }
   
     nsRefPtr<IDBRequest> request = GenerateWriteRequest();
     NS_ENSURE_TRUE(request, NS_ERROR_FAILURE);
   
     nsRefPtr<AddHelper> helper =
       new AddHelper(mTransaction, request, mId, mKeyPath, jsonValue, key,
                     !!mAutoIncrement, true, false, updateInfo);
     rv = helper->DispatchToTransactionPool();
     NS_ENSURE_SUCCESS(rv, rv);
   
     request.forget(_retval);
     return NS_OK;
   }
   -------------------------------------------------------------------------
   Potentially buggy differences:
1|   if (key.IsUnset() && !mAutoIncrement) {
>                      -- ---------------
2|   if (key.IsUnset() || key.IsNull()) {
>                      -- ------------
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\dom\indexeddb\idbobjectstore.cpp 954:22 -> 998:0
   -------------------------------------------------------------------------
   IDBObjectStore::Modify(jsval aValue,
                          jsval aKey,
                          JSContext* aCx,
                          PRUint8 aOptionalArgCount,
                          nsIIDBRequest** _retval)
   {
     NS_ASSERTION(NS_IsMainThread(), "Wrong thread!");
   
     if (!mTransaction->TransactionIsOpen()) {
       return NS_ERROR_UNEXPECTED;
     }
   
     if (mMode != nsIIDBTransaction::READ_WRITE) {
       return NS_ERROR_OBJECT_IS_IMMUTABLE;
     }
   
     if (aOptionalArgCount < 1) {
       aKey = JSVAL_VOID;
     }
   
     nsString jsonValue;
     Key key;
     nsTArray<IndexUpdateInfo> updateInfo;
   
     nsresult rv = GetAddInfo(aCx, aValue, aKey, jsonValue, key, updateInfo);
     if (NS_FAILED(rv)) {
       return rv;
     }
   
     if (key.IsUnset() || key.IsNull()) {
       return NS_ERROR_ILLEGAL_VALUE;
     }
   
     nsRefPtr<IDBRequest> request = GenerateWriteRequest();
     NS_ENSURE_TRUE(request, NS_ERROR_FAILURE);
   
     nsRefPtr<AddHelper> helper =
       new AddHelper(mTransaction, request, mId, mKeyPath, jsonValue, key,
                     !!mAutoIncrement, false, true, updateInfo);
     rv = helper->DispatchToTransactionPool();
     NS_ENSURE_SUCCESS(rv, rv);
   
     request.forget(_retval);
     return NS_OK;
   }
   -------------------------------------------------------------------------

 Pair b.) TxtSim: 0.814 | CED: 1 | FED: 6 (3.0%) | SZ: 201 | XF: F | XP: F | D: 50
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\dom\indexeddb\idbobjectstore.cpp 907:19 -> 951:0
   -------------------------------------------------------------------------
   IDBObjectStore::Add(jsval aValue,
                       jsval aKey,
                       JSContext* aCx,
                       PRUint8 aOptionalArgCount,
                       nsIIDBRequest** _retval)
   {
     NS_ASSERTION(NS_IsMainThread(), "Wrong thread!");
   
     if (!mTransaction->TransactionIsOpen()) {
       return NS_ERROR_UNEXPECTED;
     }
   
     if (mMode != nsIIDBTransaction::READ_WRITE) {
       return NS_ERROR_OBJECT_IS_IMMUTABLE;
     }
   
     if (aOptionalArgCount < 1) {
       aKey = JSVAL_VOID;
     }
   
     nsString jsonValue;
     Key key;
     nsTArray<IndexUpdateInfo> updateInfo;
   
     nsresult rv = GetAddInfo(aCx, aValue, aKey, jsonValue, key, updateInfo);
     if (NS_FAILED(rv)) {
       return rv;
     }
   
     if (key.IsUnset() && !mAutoIncrement) {
       return NS_ERROR_ILLEGAL_VALUE;
     }
   
     nsRefPtr<IDBRequest> request = GenerateWriteRequest();
     NS_ENSURE_TRUE(request, NS_ERROR_FAILURE);
   
     nsRefPtr<AddHelper> helper =
       new AddHelper(mTransaction, request, mId, mKeyPath, jsonValue, key,
                     !!mAutoIncrement, true, false, updateInfo);
     rv = helper->DispatchToTransactionPool();
     NS_ENSURE_SUCCESS(rv, rv);
   
     request.forget(_retval);
     return NS_OK;
   }
   -------------------------------------------------------------------------
   Potentially buggy differences:
1|   if (key.IsUnset() && !mAutoIncrement) {
>                      -- ---------------
2|   if (key.IsUnset() || key.IsNull()) {
>                      -- ------------
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\dom\indexeddb\idbobjectstore.cpp 1001:27 -> 1045:0
   -------------------------------------------------------------------------
   IDBObjectStore::AddOrModify(jsval aValue,
                               jsval aKey,
                               JSContext* aCx,
                               PRUint8 aOptionalArgCount,
                               nsIIDBRequest** _retval)
   {
     NS_ASSERTION(NS_IsMainThread(), "Wrong thread!");
   
     if (!mTransaction->TransactionIsOpen()) {
       return NS_ERROR_UNEXPECTED;
     }
   
     if (mMode != nsIIDBTransaction::READ_WRITE) {
       return NS_ERROR_OBJECT_IS_IMMUTABLE;
     }
   
     if (aOptionalArgCount < 1) {
       aKey = JSVAL_VOID;
     }
   
     nsString jsonValue;
     Key key;
     nsTArray<IndexUpdateInfo> updateInfo;
   
     nsresult rv = GetAddInfo(aCx, aValue, aKey, jsonValue, key, updateInfo);
     if (NS_FAILED(rv)) {
       return rv;
     }
   
     if (key.IsUnset() || key.IsNull()) {
       return NS_ERROR_ILLEGAL_VALUE;
     }
   
     nsRefPtr<IDBRequest> request = GenerateWriteRequest();
     NS_ENSURE_TRUE(request, NS_ERROR_FAILURE);
   
     nsRefPtr<AddHelper> helper =
       new AddHelper(mTransaction, request, mId, mKeyPath, jsonValue, key,
                     !!mAutoIncrement, true, true, updateInfo);
     rv = helper->DispatchToTransactionPool();
     NS_ENSURE_SUCCESS(rv, rv);
   
     request.forget(_retval);
     return NS_OK;
   }
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 105: 4 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.514 | CED: 1 | FED: 1 (1.0%) | SZ: 101 | XF: F | XP: F | D: 21
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\dom\base\nsglobalwindow.cpp 3514:26 -> 3544:0
   -------------------------------------------------------------------------
   nsGlobalWindow::SetScreenX(PRInt32 aScreenX)
   {
     FORWARD_TO_OUTER(SetScreenX, (aScreenX), NS_ERROR_NOT_INITIALIZED);
   
     /*
      * If caller is not chrome and the user has not explicitly exempted the site,
      * prevent setting window.screenX by exiting early
      */
   
     if (!CanMoveResizeWindows() || IsFrame()) {
       return NS_OK;
     }
   
     nsCOMPtr<nsIBaseWindow> treeOwnerAsWin;
     GetTreeOwner(getter_AddRefs(treeOwnerAsWin));
     NS_ENSURE_TRUE(treeOwnerAsWin, NS_ERROR_FAILURE);
   
     NS_ENSURE_SUCCESS(CheckSecurityLeftAndTop(&aScreenX, nsnull),
                       NS_ERROR_FAILURE);
   
     PRInt32 x, y;
     NS_ENSURE_SUCCESS(treeOwnerAsWin->GetPosition(&x, &y),
                       NS_ERROR_FAILURE);
   
     x = CSSToDevIntPixels(aScreenX);
   
     NS_ENSURE_SUCCESS(treeOwnerAsWin->SetPosition(x, y),
                       NS_ERROR_FAILURE);
   
     return NS_OK;
   }
   -------------------------------------------------------------------------
   Potentially buggy differences:
1|   x = CSSToDevIntPixels(aScreenX);
>    -
2|   y = CSSToDevIntPixels(aScreenY);
>    -
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\dom\base\nsglobalwindow.cpp 3565:26 -> 3595:0
   -------------------------------------------------------------------------
   nsGlobalWindow::SetScreenY(PRInt32 aScreenY)
   {
     FORWARD_TO_OUTER(SetScreenY, (aScreenY), NS_ERROR_NOT_INITIALIZED);
   
     /*
      * If caller is not chrome and the user has not explicitly exempted the site,
      * prevent setting window.screenY by exiting early
      */
   
     if (!CanMoveResizeWindows() || IsFrame()) {
       return NS_OK;
     }
   
     nsCOMPtr<nsIBaseWindow> treeOwnerAsWin;
     GetTreeOwner(getter_AddRefs(treeOwnerAsWin));
     NS_ENSURE_TRUE(treeOwnerAsWin, NS_ERROR_FAILURE);
   
     NS_ENSURE_SUCCESS(CheckSecurityLeftAndTop(nsnull, &aScreenY),
                       NS_ERROR_FAILURE);
   
     PRInt32 x, y;
     NS_ENSURE_SUCCESS(treeOwnerAsWin->GetPosition(&x, &y),
                       NS_ERROR_FAILURE);
   
     y = CSSToDevIntPixels(aScreenY);
   
     NS_ENSURE_SUCCESS(treeOwnerAsWin->SetPosition(x, y),
                       NS_ERROR_FAILURE);
   
     return NS_OK;
   }
   -------------------------------------------------------------------------

 Pair b.) TxtSim: 0.514 | CED: 1 | FED: 1 (1.0%) | SZ: 101 | XF: T | XP: T | D: inf
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\dom\base\nsglobalwindow.cpp 3514:26 -> 3544:0
   -------------------------------------------------------------------------
   nsGlobalWindow::SetScreenX(PRInt32 aScreenX)
   {
     FORWARD_TO_OUTER(SetScreenX, (aScreenX), NS_ERROR_NOT_INITIALIZED);
   
     /*
      * If caller is not chrome and the user has not explicitly exempted the site,
      * prevent setting window.screenX by exiting early
      */
   
     if (!CanMoveResizeWindows() || IsFrame()) {
       return NS_OK;
     }
   
     nsCOMPtr<nsIBaseWindow> treeOwnerAsWin;
     GetTreeOwner(getter_AddRefs(treeOwnerAsWin));
     NS_ENSURE_TRUE(treeOwnerAsWin, NS_ERROR_FAILURE);
   
     NS_ENSURE_SUCCESS(CheckSecurityLeftAndTop(&aScreenX, nsnull),
                       NS_ERROR_FAILURE);
   
     PRInt32 x, y;
     NS_ENSURE_SUCCESS(treeOwnerAsWin->GetPosition(&x, &y),
                       NS_ERROR_FAILURE);
   
     x = CSSToDevIntPixels(aScreenX);
   
     NS_ENSURE_SUCCESS(treeOwnerAsWin->SetPosition(x, y),
                       NS_ERROR_FAILURE);
   
     return NS_OK;
   }
   -------------------------------------------------------------------------
   Potentially buggy differences:
1|   x = CSSToDevIntPixels(aScreenX);
>    -
2|   y = CSSToDevIntPixels(aScreenY);
>    -
   -------------------------------------------------------------------------
   c:\mozilla-central\dom\base\nsglobalwindow.cpp 3565:26 -> 3595:0
   -------------------------------------------------------------------------
   nsGlobalWindow::SetScreenY(PRInt32 aScreenY)
   {
     FORWARD_TO_OUTER(SetScreenY, (aScreenY), NS_ERROR_NOT_INITIALIZED);
   
     /*
      * If caller is not chrome and the user has not explicitly exempted the site,
      * prevent setting window.screenY by exiting early
      */
   
     if (!CanMoveResizeWindows() || IsFrame()) {
       return NS_OK;
     }
   
     nsCOMPtr<nsIBaseWindow> treeOwnerAsWin;
     GetTreeOwner(getter_AddRefs(treeOwnerAsWin));
     NS_ENSURE_TRUE(treeOwnerAsWin, NS_ERROR_FAILURE);
   
     NS_ENSURE_SUCCESS(CheckSecurityLeftAndTop(nsnull, &aScreenY),
                       NS_ERROR_FAILURE);
   
     PRInt32 x, y;
     NS_ENSURE_SUCCESS(treeOwnerAsWin->GetPosition(&x, &y),
                       NS_ERROR_FAILURE);
   
     y = CSSToDevIntPixels(aScreenY);
   
     NS_ENSURE_SUCCESS(treeOwnerAsWin->SetPosition(x, y),
                       NS_ERROR_FAILURE);
   
     return NS_OK;
   }
   -------------------------------------------------------------------------

 Pair c.) TxtSim: 0.514 | CED: 1 | FED: 1 (1.0%) | SZ: 101 | XF: T | XP: T | D: inf
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\dom\base\nsglobalwindow.cpp 3565:26 -> 3595:0
   -------------------------------------------------------------------------
   nsGlobalWindow::SetScreenY(PRInt32 aScreenY)
   {
     FORWARD_TO_OUTER(SetScreenY, (aScreenY), NS_ERROR_NOT_INITIALIZED);
   
     /*
      * If caller is not chrome and the user has not explicitly exempted the site,
      * prevent setting window.screenY by exiting early
      */
   
     if (!CanMoveResizeWindows() || IsFrame()) {
       return NS_OK;
     }
   
     nsCOMPtr<nsIBaseWindow> treeOwnerAsWin;
     GetTreeOwner(getter_AddRefs(treeOwnerAsWin));
     NS_ENSURE_TRUE(treeOwnerAsWin, NS_ERROR_FAILURE);
   
     NS_ENSURE_SUCCESS(CheckSecurityLeftAndTop(nsnull, &aScreenY),
                       NS_ERROR_FAILURE);
   
     PRInt32 x, y;
     NS_ENSURE_SUCCESS(treeOwnerAsWin->GetPosition(&x, &y),
                       NS_ERROR_FAILURE);
   
     y = CSSToDevIntPixels(aScreenY);
   
     NS_ENSURE_SUCCESS(treeOwnerAsWin->SetPosition(x, y),
                       NS_ERROR_FAILURE);
   
     return NS_OK;
   }
   -------------------------------------------------------------------------
   Potentially buggy differences:
1|   y = CSSToDevIntPixels(aScreenY);
>    -
2|   x = CSSToDevIntPixels(aScreenX);
>    -
   -------------------------------------------------------------------------
   c:\mozilla-central\dom\base\nsglobalwindow.cpp 3514:26 -> 3544:0
   -------------------------------------------------------------------------
   nsGlobalWindow::SetScreenX(PRInt32 aScreenX)
   {
     FORWARD_TO_OUTER(SetScreenX, (aScreenX), NS_ERROR_NOT_INITIALIZED);
   
     /*
      * If caller is not chrome and the user has not explicitly exempted the site,
      * prevent setting window.screenX by exiting early
      */
   
     if (!CanMoveResizeWindows() || IsFrame()) {
       return NS_OK;
     }
   
     nsCOMPtr<nsIBaseWindow> treeOwnerAsWin;
     GetTreeOwner(getter_AddRefs(treeOwnerAsWin));
     NS_ENSURE_TRUE(treeOwnerAsWin, NS_ERROR_FAILURE);
   
     NS_ENSURE_SUCCESS(CheckSecurityLeftAndTop(&aScreenX, nsnull),
                       NS_ERROR_FAILURE);
   
     PRInt32 x, y;
     NS_ENSURE_SUCCESS(treeOwnerAsWin->GetPosition(&x, &y),
                       NS_ERROR_FAILURE);
   
     x = CSSToDevIntPixels(aScreenX);
   
     NS_ENSURE_SUCCESS(treeOwnerAsWin->SetPosition(x, y),
                       NS_ERROR_FAILURE);
   
     return NS_OK;
   }
   -------------------------------------------------------------------------

 Pair d.) TxtSim: 0.514 | CED: 1 | FED: 1 (1.0%) | SZ: 101 | XF: F | XP: F | D: 21
   -------------------------------------------------------------------------
   c:\mozilla-central\dom\base\nsglobalwindow.cpp 3514:26 -> 3544:0
   -------------------------------------------------------------------------
   nsGlobalWindow::SetScreenX(PRInt32 aScreenX)
   {
     FORWARD_TO_OUTER(SetScreenX, (aScreenX), NS_ERROR_NOT_INITIALIZED);
   
     /*
      * If caller is not chrome and the user has not explicitly exempted the site,
      * prevent setting window.screenX by exiting early
      */
   
     if (!CanMoveResizeWindows() || IsFrame()) {
       return NS_OK;
     }
   
     nsCOMPtr<nsIBaseWindow> treeOwnerAsWin;
     GetTreeOwner(getter_AddRefs(treeOwnerAsWin));
     NS_ENSURE_TRUE(treeOwnerAsWin, NS_ERROR_FAILURE);
   
     NS_ENSURE_SUCCESS(CheckSecurityLeftAndTop(&aScreenX, nsnull),
                       NS_ERROR_FAILURE);
   
     PRInt32 x, y;
     NS_ENSURE_SUCCESS(treeOwnerAsWin->GetPosition(&x, &y),
                       NS_ERROR_FAILURE);
   
     x = CSSToDevIntPixels(aScreenX);
   
     NS_ENSURE_SUCCESS(treeOwnerAsWin->SetPosition(x, y),
                       NS_ERROR_FAILURE);
   
     return NS_OK;
   }
   -------------------------------------------------------------------------
   Potentially buggy differences:
1|   x = CSSToDevIntPixels(aScreenX);
>    -
2|   y = CSSToDevIntPixels(aScreenY);
>    -
   -------------------------------------------------------------------------
   c:\mozilla-central\dom\base\nsglobalwindow.cpp 3565:26 -> 3595:0
   -------------------------------------------------------------------------
   nsGlobalWindow::SetScreenY(PRInt32 aScreenY)
   {
     FORWARD_TO_OUTER(SetScreenY, (aScreenY), NS_ERROR_NOT_INITIALIZED);
   
     /*
      * If caller is not chrome and the user has not explicitly exempted the site,
      * prevent setting window.screenY by exiting early
      */
   
     if (!CanMoveResizeWindows() || IsFrame()) {
       return NS_OK;
     }
   
     nsCOMPtr<nsIBaseWindow> treeOwnerAsWin;
     GetTreeOwner(getter_AddRefs(treeOwnerAsWin));
     NS_ENSURE_TRUE(treeOwnerAsWin, NS_ERROR_FAILURE);
   
     NS_ENSURE_SUCCESS(CheckSecurityLeftAndTop(nsnull, &aScreenY),
                       NS_ERROR_FAILURE);
   
     PRInt32 x, y;
     NS_ENSURE_SUCCESS(treeOwnerAsWin->GetPosition(&x, &y),
                       NS_ERROR_FAILURE);
   
     y = CSSToDevIntPixels(aScreenY);
   
     NS_ENSURE_SUCCESS(treeOwnerAsWin->SetPosition(x, y),
                       NS_ERROR_FAILURE);
   
     return NS_OK;
   }
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 106: 2 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.627 | CED: 2 | FED: 2 (3.5%) | SZ: 57 | XF: T | XP: T | D: inf
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\caps\src\nsnullprincipal.cpp 101:11 -> 111:28
   -------------------------------------------------------------------------
   nsresult rv;
   nsCOMPtr<nsIUUIDGenerator> uuidgen =
     do_GetService("@mozilla.org/uuid-generator;1", &rv);
   NS_ENSURE_SUCCESS(rv, rv);
   
   nsID id;
   rv = uuidgen->GenerateUUIDInPlace(&id);
   NS_ENSURE_SUCCESS(rv, rv);
   
   char chars[NSID_LENGTH];
   id.ToProvidedString(chars);
   -------------------------------------------------------------------------
   Potentially buggy differences:
1| NS_ENSURE_SUCCESS(rv, rv);
>                        --
2| NS_ENSURE_SUCCESS(rv, false);
>                        -----

1| NS_ENSURE_SUCCESS(rv, rv);
>                        --
2| NS_ENSURE_SUCCESS(rv, false);
>                        -----
   -------------------------------------------------------------------------
   c:\mozilla-central\toolkit\crashreporter\nsexceptionhandler.cpp 1723:11 -> 1733:28
   -------------------------------------------------------------------------
   nsresult rv;
   nsCOMPtr<nsIUUIDGenerator> uuidgen =
     do_GetService("@mozilla.org/uuid-generator;1", &rv);
   NS_ENSURE_SUCCESS(rv, false);
   
   nsID id;
   rv = uuidgen->GenerateUUIDInPlace(&id);
   NS_ENSURE_SUCCESS(rv, false);
   
   char chars[NSID_LENGTH];
   id.ToProvidedString(chars);
   -------------------------------------------------------------------------

 Pair b.) TxtSim: 0.627 | CED: 2 | FED: 2 (3.5%) | SZ: 57 | XF: T | XP: T | D: inf
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\content\base\src\nsdomfile.cpp 169:13 -> 179:30
   -------------------------------------------------------------------------
   nsresult rv;
   nsCOMPtr<nsIUUIDGenerator> uuidgen =
     do_GetService("@mozilla.org/uuid-generator;1", &rv);
   NS_ENSURE_SUCCESS(rv, rv);
   
   nsID id;
   rv = uuidgen->GenerateUUIDInPlace(&id);
   NS_ENSURE_SUCCESS(rv, rv);
   
   char chars[NSID_LENGTH];
   id.ToProvidedString(chars);
   -------------------------------------------------------------------------
   Potentially buggy differences:
1| NS_ENSURE_SUCCESS(rv, rv);
>                        --
2| NS_ENSURE_SUCCESS(rv, false);
>                        -----

1| NS_ENSURE_SUCCESS(rv, rv);
>                        --
2| NS_ENSURE_SUCCESS(rv, false);
>                        -----
   -------------------------------------------------------------------------
   c:\mozilla-central\toolkit\crashreporter\nsexceptionhandler.cpp 1723:11 -> 1733:28
   -------------------------------------------------------------------------
   nsresult rv;
   nsCOMPtr<nsIUUIDGenerator> uuidgen =
     do_GetService("@mozilla.org/uuid-generator;1", &rv);
   NS_ENSURE_SUCCESS(rv, false);
   
   nsID id;
   rv = uuidgen->GenerateUUIDInPlace(&id);
   NS_ENSURE_SUCCESS(rv, false);
   
   char chars[NSID_LENGTH];
   id.ToProvidedString(chars);
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 107: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.670 | CED: 1 | FED: 2 (2.2%) | SZ: 90 | XF: F | XP: F | D: 11
   -------------------------------------------------------------------------
   c:\comm-central\mailnews\addrbook\src\nsaddrdatabase.cpp 1753:11 -> 1770:56
   -------------------------------------------------------------------------
   nsresult rv = NS_OK;
   
   nsCOMPtr <nsIMdbRow> cardRow;
   mdbOid rowOid;
   rowOid.mOid_Scope = m_CardRowScopeToken;
   
   // it might be that the caller always has a nsAbMDBCard
   rv = card->GetPropertyAsUint32(kRowIDProperty, &rowOid.mOid_Id);
   NS_ENSURE_SUCCESS(rv, rv);
   
   rv = m_mdbStore->GetRow(m_mdbEnv, &rowOid, getter_AddRefs(cardRow));
   NS_ENSURE_SUCCESS(rv, rv);
   
   if (!cardRow)
     return NS_OK;
   
   mdb_token token;
   rv = m_mdbStore->StringToToken(m_mdbEnv, name, &token);
   -------------------------------------------------------------------------
   Potentially buggy differences:
1| rv = m_mdbStore->StringToToken(m_mdbEnv, name, &token);
>  ^^ ^
   -------------------------------------------------------------------------
   c:\comm-central\mailnews\addrbook\src\nsaddrdatabase.cpp 1781:11 -> 1801:51
   -------------------------------------------------------------------------
   nsresult rv = NS_OK;
   
   nsCOMPtr <nsIMdbRow> cardRow;
   mdbOid rowOid;
   rowOid.mOid_Scope = m_CardRowScopeToken;
   
   // it might be that the caller always has a nsAbMDBCard
   rv = card->GetPropertyAsUint32(kRowIDProperty, &rowOid.mOid_Id);
   NS_ENSURE_SUCCESS(rv, rv);
   
   rv = m_mdbStore->GetRow(m_mdbEnv, &rowOid, getter_AddRefs(cardRow));
   NS_ENSURE_SUCCESS(rv, rv);
   
   if (!cardRow) {
     *value = nsnull;
     // this can happen when adding cards when editing a mailing list
     return NS_OK;
   }
   
   mdb_token token;
   m_mdbStore->StringToToken(m_mdbEnv, name, &token);
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 108: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.590 | CED: 2 | FED: 9 (14.1%) | SZ: 64 | XF: F | XP: F | D: 335
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\layout\forms\nstextcontrolframe.cpp 797:2 -> 807:2
   -------------------------------------------------------------------------
   NS_ENSURE_SUCCESS(rv, rv);
   
   // Get the selection, clear it and add the new range to it!
   nsCOMPtr<nsITextControlElement> txtCtrl = do_QueryInterface(GetContent());
   NS_ASSERTION(txtCtrl, "Content not a text control element");
   nsISelectionController* selCon = txtCtrl->GetSelectionController();
   NS_ENSURE_TRUE(selCon, NS_ERROR_FAILURE);
   
   nsCOMPtr<nsISelection> selection;
   selCon->GetSelection(nsISelectionController::SELECTION_NORMAL, getter_AddRefs(selection));
   NS_ENSURE_TRUE(selection, NS_ERROR_FAILURE);
   -------------------------------------------------------------------------
   Potentially buggy differences:
2| rv = selCon->GetSelection(nsISelectionController::SELECTION_NORMAL, getter_AddRefs(selection));
>  ^^ ^

2| NS_ENSURE_SUCCESS(rv, rv);
>  ^^^^^^^^^^^^^^^^^^^^^ ^^^
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\layout\forms\nstextcontrolframe.cpp 1142:34 -> 1149:2
   -------------------------------------------------------------------------
   nsCOMPtr<nsITextControlElement> txtCtrl = do_QueryInterface(GetContent());
   NS_ASSERTION(txtCtrl, "Content not a text control element");
   nsISelectionController* selCon = txtCtrl->GetSelectionController();
   NS_ENSURE_TRUE(selCon, NS_ERROR_FAILURE);
   nsCOMPtr<nsISelection> selection;
   rv = selCon->GetSelection(nsISelectionController::SELECTION_NORMAL, getter_AddRefs(selection));
   NS_ENSURE_SUCCESS(rv, rv);
   NS_ENSURE_TRUE(selection, NS_ERROR_FAILURE);
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 109: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.527 | CED: 1 | FED: 2 (2.7%) | SZ: 75 | XF: T | XP: F | D: inf
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\layout\tables\nstablecolframe.cpp 87:35 -> 100:0
   -------------------------------------------------------------------------
   nsTableColFrame::DidSetStyleContext(nsStyleContext* aOldStyleContext)
   {
     if (!aOldStyleContext) //avoid this on init
       return;
   
     nsTableFrame* tableFrame = nsTableFrame::GetTableFrame(this);
   
     if (tableFrame->IsBorderCollapse() &&
         tableFrame->BCRecalcNeeded(aOldStyleContext, GetStyleContext())) {
       nsRect damageArea = nsRect(GetColIndex(), 0, 1, tableFrame->GetRowCount());
       tableFrame->SetBCDamageArea(damageArea);
     }
     return;
   }
   -------------------------------------------------------------------------
   Potentially buggy differences:
1|     nsRect damageArea = nsRect(GetColIndex(), 0, 1, tableFrame->GetRowCount());
>                        ^ ^^^^^^
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\layout\tables\nstablerowframe.cpp 189:35 -> 202:0
   -------------------------------------------------------------------------
   nsTableRowFrame::DidSetStyleContext(nsStyleContext* aOldStyleContext)
   {
     if (!aOldStyleContext) //avoid this on init
       return;
   
     nsTableFrame* tableFrame = nsTableFrame::GetTableFrame(this);
   
     if (tableFrame->IsBorderCollapse() &&
         tableFrame->BCRecalcNeeded(aOldStyleContext, GetStyleContext())) {
       nsRect damageArea(0, GetRowIndex(), tableFrame->GetColCount(), 1);
       tableFrame->SetBCDamageArea(damageArea);
     }
     return;
   }
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 110: 2 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.757 | CED: 2 | FED: 10 (9.5%) | SZ: 105 | XF: T | XP: F | D: inf
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\netwerk\base\src\nsstandardurl.cpp 117:4 -> 139:13
   -------------------------------------------------------------------------
   if (NS_FAILED(rv))
       goto end;
   if (rv == NS_ERROR_UENC_NOMAPPING) {
       NS_WARNING("unicode conversion failed");
       rv = NS_ERROR_UNEXPECTED;
       goto end;
   }
   p[maxlen] = 0;
   result.Assign(p);
   
   len = sizeof(buf) - 1;
   rv = encoder->Finish(buf, &len);
   if (NS_FAILED(rv))
       goto end;
   buf[len] = 0;
   result.Append(buf);
   
   end:
       encoder->Reset();
   
       if (p != buf)
           free(p);
       return rv;
   -------------------------------------------------------------------------
   Potentially buggy differences:
2| mPath = result;
>  ^^^^^ ^ ^^^^^^

1|     encoder->Reset();
>      ^^^^^^^^^^^^^^^^
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\netwerk\protocol\ftp\nsftpconnectionthread.cpp 2291:4 -> 2311:15
   -------------------------------------------------------------------------
   if (NS_FAILED(rv))
       goto end;
   if (rv == NS_ERROR_UENC_NOMAPPING) {
       NS_WARNING("unicode conversion failed");
       rv = NS_ERROR_UNEXPECTED;
       goto end;
   }
   p[maxlen] = 0;
   result.Assign(p);
   
   len = sizeof(buf) - 1;
   rv = encoder->Finish(buf, &len);
   if (NS_FAILED(rv))
       goto end;
   buf[len] = 0;
   result.Append(buf);
   mPath = result;
   
   end:
       if (p != buf)
           free(p);
   -------------------------------------------------------------------------

 Pair b.) TxtSim: 0.757 | CED: 3 | FED: 6 (5.7%) | SZ: 105 | XF: T | XP: T | D: inf
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\netwerk\protocol\ftp\nsftpconnectionthread.cpp 2291:4 -> 2311:15
   -------------------------------------------------------------------------
   if (NS_FAILED(rv))
       goto end;
   if (rv == NS_ERROR_UENC_NOMAPPING) {
       NS_WARNING("unicode conversion failed");
       rv = NS_ERROR_UNEXPECTED;
       goto end;
   }
   p[maxlen] = 0;
   result.Assign(p);
   
   len = sizeof(buf) - 1;
   rv = encoder->Finish(buf, &len);
   if (NS_FAILED(rv))
       goto end;
   buf[len] = 0;
   result.Append(buf);
   mPath = result;
   
   end:
       if (p != buf)
           free(p);
   -------------------------------------------------------------------------
   Potentially buggy differences:
1| mPath = result;
>        - ------
2| end:
>  ^^^^
2|     encoder->Reset();
>      ^^^^^^^^^     --

1| end:
>  ^^^^
   -------------------------------------------------------------------------
   c:\mozilla-central\netwerk\base\src\nsstandardurl.cpp 117:4 -> 139:13
   -------------------------------------------------------------------------
   if (NS_FAILED(rv))
       goto end;
   if (rv == NS_ERROR_UENC_NOMAPPING) {
       NS_WARNING("unicode conversion failed");
       rv = NS_ERROR_UNEXPECTED;
       goto end;
   }
   p[maxlen] = 0;
   result.Assign(p);
   
   len = sizeof(buf) - 1;
   rv = encoder->Finish(buf, &len);
   if (NS_FAILED(rv))
       goto end;
   buf[len] = 0;
   result.Append(buf);
   
   end:
       encoder->Reset();
   
       if (p != buf)
           free(p);
       return rv;
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 111: 2 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.531 | CED: 4 | FED: 12 (13.5%) | SZ: 89 | XF: F | XP: F | D: 4
   -------------------------------------------------------------------------
   c:\mozilla-central\ipc\chromium\src\base\pickle.cc 234:2 -> 248:13
   -------------------------------------------------------------------------
   DCHECK(iter);
   if (!*iter)
     *iter = const_cast<char*>(payload());
   
   int len;
   if (!ReadLength(iter, &len))
     return false;
   if (!IteratorHasRoomFor(*iter, len))
     return false;
   
   char* chars = reinterpret_cast<char*>(*iter);
   result->assign(chars, len);
   
   UpdateIter(iter, len);
   return true;
   -------------------------------------------------------------------------
   Potentially buggy differences:
2| if (!IteratorHasRoomFor(*iter, len * sizeof(wchar_t)))
>                                     ^ ^^^^^^^^^^^^^^^

1| char* chars = reinterpret_cast<char*>(*iter);
>  ----                           ----
2| wchar_t* chars = reinterpret_cast<wchar_t*>(*iter);
>  -------                           -------

2| UpdateIter(iter, len * sizeof(wchar_t));
>                       ^ ^^^^^^^^^^^^^^^
   -------------------------------------------------------------------------
   c:\mozilla-central\ipc\chromium\src\base\pickle.cc 252:2 -> 266:13
   -------------------------------------------------------------------------
   DCHECK(iter);
   if (!*iter)
     *iter = const_cast<char*>(payload());
   
   int len;
   if (!ReadLength(iter, &len))
     return false;
   if (!IteratorHasRoomFor(*iter, len * sizeof(wchar_t)))
     return false;
   
   wchar_t* chars = reinterpret_cast<wchar_t*>(*iter);
   result->assign(chars, len);
   
   UpdateIter(iter, len * sizeof(wchar_t));
   return true;
   -------------------------------------------------------------------------

 Pair b.) TxtSim: 0.548 | CED: 1 | FED: 5 (5.3%) | SZ: 94 | XF: F | XP: F | D: 4
   -------------------------------------------------------------------------
   c:\mozilla-central\ipc\chromium\src\base\pickle.cc 252:2 -> 266:13
   -------------------------------------------------------------------------
   DCHECK(iter);
   if (!*iter)
     *iter = const_cast<char*>(payload());
   
   int len;
   if (!ReadLength(iter, &len))
     return false;
   if (!IteratorHasRoomFor(*iter, len * sizeof(wchar_t)))
     return false;
   
   wchar_t* chars = reinterpret_cast<wchar_t*>(*iter);
   result->assign(chars, len);
   
   UpdateIter(iter, len * sizeof(wchar_t));
   return true;
   -------------------------------------------------------------------------
   Potentially buggy differences:
1| if (!IteratorHasRoomFor(*iter, len * sizeof(wchar_t)))
>                                     ^ ^^^^^^^^^^^^^^^
   -------------------------------------------------------------------------
   c:\mozilla-central\ipc\chromium\src\base\pickle.cc 270:2 -> 284:13
   -------------------------------------------------------------------------
   DCHECK(iter);
   if (!*iter)
     *iter = const_cast<char*>(payload());
   
   int len;
   if (!ReadLength(iter, &len))
     return false;
   if (!IteratorHasRoomFor(*iter, len))
     return false;
   
   char16* chars = reinterpret_cast<char16*>(*iter);
   result->assign(chars, len);
   
   UpdateIter(iter, len * sizeof(char16));
   return true;
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 112: 4 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.543 | CED: 1 | FED: 2 (1.1%) | SZ: 176 | XF: F | XP: F | D: 141
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\xpcom\components\nscomponentmanager.cpp 1416:4 -> 1465:46
   -------------------------------------------------------------------------
   if (entry->mServiceObject) {
       nsCOMPtr<nsISupports> supports = entry->mServiceObject;
       mon.Exit();
       return supports->QueryInterface(aIID, result);
   }
   
   // We only care about time when we create the service.
   COMPMGR_TIME_FUNCTION_CID(aClass);
   
   PRThread* currentPRThread = PR_GetCurrentThread();
   NS_ASSERTION(currentPRThread, "This should never be null!");
   
   // Needed to optimize the event loop below.
   nsIThread* currentThread = nsnull;
   
   PRThread* pendingPRThread;
   while ((pendingPRThread = GetPendingServiceThread(aClass))) {
       if (pendingPRThread == currentPRThread) {
           NS_ERROR("Recursive GetService!");
           return NS_ERROR_NOT_AVAILABLE;
       }
   
       mon.Exit();
   
       if (!currentThread) {
           currentThread = NS_GetCurrentThread();
           NS_ASSERTION(currentThread, "This should never be null!");
       }
   
       // This will process a single event or yield the thread if no event is
       // pending.
       if (!NS_ProcessNextEvent(currentThread, PR_FALSE)) {
           PR_Sleep(PR_INTERVAL_NO_WAIT);
       }
   
       mon.Enter();
   }
   
   // It's still possible that the other thread failed to create the
   // service so we're not guaranteed to have an entry or service yet.
   if (entry->mServiceObject) {
       nsCOMPtr<nsISupports> supports = entry->mServiceObject;
       mon.Exit();
       return supports->QueryInterface(aIID, result);
   }
   
   ef DEBUG
   PendingServiceInfo* newInfo =
   if
   AddPendingService(aClass, currentPRThread);
   -------------------------------------------------------------------------
   Potentially buggy differences:
2| if (currentThread && entry->mServiceObject) {
>      ^^^^^^^^^^^^^ ^^
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\xpcom\components\nscomponentmanager.cpp 1606:4 -> 1655:4
   -------------------------------------------------------------------------
   if (entry->mServiceObject) {
       nsCOMPtr<nsISupports> serviceObject = entry->mServiceObject;
   
       // We need to not be holding the service manager's monitor while calling
       // QueryInterface, because it invokes user code which could try to re-enter
       // the service manager, or try to grab some other lock/monitor/condvar
       // and deadlock, e.g. bug 282743.
       mon.Exit();
       return serviceObject->QueryInterface(aIID, result);
   }
   
   // We only care about time when we create the service.
   COMPMGR_TIME_FUNCTION_CONTRACTID(aContractID);
   
   PRThread* currentPRThread = PR_GetCurrentThread();
   NS_ASSERTION(currentPRThread, "This should never be null!");
   
   // Needed to optimize the event loop below.
   nsIThread* currentThread = nsnull;
   
   PRThread* pendingPRThread;
   while ((pendingPRThread = GetPendingServiceThread(*entry->mCIDEntry->cid))) {
       if (pendingPRThread == currentPRThread) {
           NS_ERROR("Recursive GetService!");
           return NS_ERROR_NOT_AVAILABLE;
       }
   
       mon.Exit();
   
       if (!currentThread) {
           currentThread = NS_GetCurrentThread();
           NS_ASSERTION(currentThread, "This should never be null!");
       }
   
       // This will process a single event or yield the thread if no event is
       // pending.
       if (!NS_ProcessNextEvent(currentThread, PR_FALSE)) {
           PR_Sleep(PR_INTERVAL_NO_WAIT);
       }
   
       mon.Enter();
   }
   
   if (currentThread && entry->mServiceObject) {
       // If we have a currentThread then we must have waited on another thread
       // to create the service. Grab it now if that succeeded.
       nsCOMPtr<nsISupports> serviceObject = entry->mServiceObject;
       mon.Exit();
       return serviceObject->QueryInterface(aIID, result);
   }
   -------------------------------------------------------------------------

 Pair b.) TxtSim: 0.543 | CED: 1 | FED: 2 (1.1%) | SZ: 176 | XF: T | XP: T | D: inf
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\xpcom\components\nscomponentmanager.cpp 1416:4 -> 1465:46
   -------------------------------------------------------------------------
   if (entry->mServiceObject) {
       nsCOMPtr<nsISupports> supports = entry->mServiceObject;
       mon.Exit();
       return supports->QueryInterface(aIID, result);
   }
   
   // We only care about time when we create the service.
   COMPMGR_TIME_FUNCTION_CID(aClass);
   
   PRThread* currentPRThread = PR_GetCurrentThread();
   NS_ASSERTION(currentPRThread, "This should never be null!");
   
   // Needed to optimize the event loop below.
   nsIThread* currentThread = nsnull;
   
   PRThread* pendingPRThread;
   while ((pendingPRThread = GetPendingServiceThread(aClass))) {
       if (pendingPRThread == currentPRThread) {
           NS_ERROR("Recursive GetService!");
           return NS_ERROR_NOT_AVAILABLE;
       }
   
       mon.Exit();
   
       if (!currentThread) {
           currentThread = NS_GetCurrentThread();
           NS_ASSERTION(currentThread, "This should never be null!");
       }
   
       // This will process a single event or yield the thread if no event is
       // pending.
       if (!NS_ProcessNextEvent(currentThread, PR_FALSE)) {
           PR_Sleep(PR_INTERVAL_NO_WAIT);
       }
   
       mon.Enter();
   }
   
   // It's still possible that the other thread failed to create the
   // service so we're not guaranteed to have an entry or service yet.
   if (entry->mServiceObject) {
       nsCOMPtr<nsISupports> supports = entry->mServiceObject;
       mon.Exit();
       return supports->QueryInterface(aIID, result);
   }
   
   ef DEBUG
   PendingServiceInfo* newInfo =
   if
   AddPendingService(aClass, currentPRThread);
   -------------------------------------------------------------------------
   Potentially buggy differences:
2| if (currentThread && entry->mServiceObject) {
>      ^^^^^^^^^^^^^ ^^
   -------------------------------------------------------------------------
   c:\mozilla-central\xpcom\components\nscomponentmanager.cpp 1606:4 -> 1655:4
   -------------------------------------------------------------------------
   if (entry->mServiceObject) {
       nsCOMPtr<nsISupports> serviceObject = entry->mServiceObject;
   
       // We need to not be holding the service manager's monitor while calling
       // QueryInterface, because it invokes user code which could try to re-enter
       // the service manager, or try to grab some other lock/monitor/condvar
       // and deadlock, e.g. bug 282743.
       mon.Exit();
       return serviceObject->QueryInterface(aIID, result);
   }
   
   // We only care about time when we create the service.
   COMPMGR_TIME_FUNCTION_CONTRACTID(aContractID);
   
   PRThread* currentPRThread = PR_GetCurrentThread();
   NS_ASSERTION(currentPRThread, "This should never be null!");
   
   // Needed to optimize the event loop below.
   nsIThread* currentThread = nsnull;
   
   PRThread* pendingPRThread;
   while ((pendingPRThread = GetPendingServiceThread(*entry->mCIDEntry->cid))) {
       if (pendingPRThread == currentPRThread) {
           NS_ERROR("Recursive GetService!");
           return NS_ERROR_NOT_AVAILABLE;
       }
   
       mon.Exit();
   
       if (!currentThread) {
           currentThread = NS_GetCurrentThread();
           NS_ASSERTION(currentThread, "This should never be null!");
       }
   
       // This will process a single event or yield the thread if no event is
       // pending.
       if (!NS_ProcessNextEvent(currentThread, PR_FALSE)) {
           PR_Sleep(PR_INTERVAL_NO_WAIT);
       }
   
       mon.Enter();
   }
   
   if (currentThread && entry->mServiceObject) {
       // If we have a currentThread then we must have waited on another thread
       // to create the service. Grab it now if that succeeded.
       nsCOMPtr<nsISupports> serviceObject = entry->mServiceObject;
       mon.Exit();
       return serviceObject->QueryInterface(aIID, result);
   }
   -------------------------------------------------------------------------

 Pair c.) TxtSim: 0.543 | CED: 1 | FED: 2 (1.1%) | SZ: 176 | XF: T | XP: T | D: inf
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\xpcom\components\nscomponentmanager.cpp 1606:4 -> 1655:4
   -------------------------------------------------------------------------
   if (entry->mServiceObject) {
       nsCOMPtr<nsISupports> serviceObject = entry->mServiceObject;
   
       // We need to not be holding the service manager's monitor while calling
       // QueryInterface, because it invokes user code which could try to re-enter
       // the service manager, or try to grab some other lock/monitor/condvar
       // and deadlock, e.g. bug 282743.
       mon.Exit();
       return serviceObject->QueryInterface(aIID, result);
   }
   
   // We only care about time when we create the service.
   COMPMGR_TIME_FUNCTION_CONTRACTID(aContractID);
   
   PRThread* currentPRThread = PR_GetCurrentThread();
   NS_ASSERTION(currentPRThread, "This should never be null!");
   
   // Needed to optimize the event loop below.
   nsIThread* currentThread = nsnull;
   
   PRThread* pendingPRThread;
   while ((pendingPRThread = GetPendingServiceThread(*entry->mCIDEntry->cid))) {
       if (pendingPRThread == currentPRThread) {
           NS_ERROR("Recursive GetService!");
           return NS_ERROR_NOT_AVAILABLE;
       }
   
       mon.Exit();
   
       if (!currentThread) {
           currentThread = NS_GetCurrentThread();
           NS_ASSERTION(currentThread, "This should never be null!");
       }
   
       // This will process a single event or yield the thread if no event is
       // pending.
       if (!NS_ProcessNextEvent(currentThread, PR_FALSE)) {
           PR_Sleep(PR_INTERVAL_NO_WAIT);
       }
   
       mon.Enter();
   }
   
   if (currentThread && entry->mServiceObject) {
       // If we have a currentThread then we must have waited on another thread
       // to create the service. Grab it now if that succeeded.
       nsCOMPtr<nsISupports> serviceObject = entry->mServiceObject;
       mon.Exit();
       return serviceObject->QueryInterface(aIID, result);
   }
   -------------------------------------------------------------------------
   Potentially buggy differences:
1| if (currentThread && entry->mServiceObject) {
>      ^^^^^^^^^^^^^ ^^
   -------------------------------------------------------------------------
   c:\mozilla-central\xpcom\components\nscomponentmanager.cpp 1416:4 -> 1465:46
   -------------------------------------------------------------------------
   if (entry->mServiceObject) {
       nsCOMPtr<nsISupports> supports = entry->mServiceObject;
       mon.Exit();
       return supports->QueryInterface(aIID, result);
   }
   
   // We only care about time when we create the service.
   COMPMGR_TIME_FUNCTION_CID(aClass);
   
   PRThread* currentPRThread = PR_GetCurrentThread();
   NS_ASSERTION(currentPRThread, "This should never be null!");
   
   // Needed to optimize the event loop below.
   nsIThread* currentThread = nsnull;
   
   PRThread* pendingPRThread;
   while ((pendingPRThread = GetPendingServiceThread(aClass))) {
       if (pendingPRThread == currentPRThread) {
           NS_ERROR("Recursive GetService!");
           return NS_ERROR_NOT_AVAILABLE;
       }
   
       mon.Exit();
   
       if (!currentThread) {
           currentThread = NS_GetCurrentThread();
           NS_ASSERTION(currentThread, "This should never be null!");
       }
   
       // This will process a single event or yield the thread if no event is
       // pending.
       if (!NS_ProcessNextEvent(currentThread, PR_FALSE)) {
           PR_Sleep(PR_INTERVAL_NO_WAIT);
       }
   
       mon.Enter();
   }
   
   // It's still possible that the other thread failed to create the
   // service so we're not guaranteed to have an entry or service yet.
   if (entry->mServiceObject) {
       nsCOMPtr<nsISupports> supports = entry->mServiceObject;
       mon.Exit();
       return supports->QueryInterface(aIID, result);
   }
   
   ef DEBUG
   PendingServiceInfo* newInfo =
   if
   AddPendingService(aClass, currentPRThread);
   -------------------------------------------------------------------------

 Pair d.) TxtSim: 0.543 | CED: 1 | FED: 2 (1.1%) | SZ: 176 | XF: F | XP: F | D: 141
   -------------------------------------------------------------------------
   c:\mozilla-central\xpcom\components\nscomponentmanager.cpp 1416:4 -> 1465:46
   -------------------------------------------------------------------------
   if (entry->mServiceObject) {
       nsCOMPtr<nsISupports> supports = entry->mServiceObject;
       mon.Exit();
       return supports->QueryInterface(aIID, result);
   }
   
   // We only care about time when we create the service.
   COMPMGR_TIME_FUNCTION_CID(aClass);
   
   PRThread* currentPRThread = PR_GetCurrentThread();
   NS_ASSERTION(currentPRThread, "This should never be null!");
   
   // Needed to optimize the event loop below.
   nsIThread* currentThread = nsnull;
   
   PRThread* pendingPRThread;
   while ((pendingPRThread = GetPendingServiceThread(aClass))) {
       if (pendingPRThread == currentPRThread) {
           NS_ERROR("Recursive GetService!");
           return NS_ERROR_NOT_AVAILABLE;
       }
   
       mon.Exit();
   
       if (!currentThread) {
           currentThread = NS_GetCurrentThread();
           NS_ASSERTION(currentThread, "This should never be null!");
       }
   
       // This will process a single event or yield the thread if no event is
       // pending.
       if (!NS_ProcessNextEvent(currentThread, PR_FALSE)) {
           PR_Sleep(PR_INTERVAL_NO_WAIT);
       }
   
       mon.Enter();
   }
   
   // It's still possible that the other thread failed to create the
   // service so we're not guaranteed to have an entry or service yet.
   if (entry->mServiceObject) {
       nsCOMPtr<nsISupports> supports = entry->mServiceObject;
       mon.Exit();
       return supports->QueryInterface(aIID, result);
   }
   
   ef DEBUG
   PendingServiceInfo* newInfo =
   if
   AddPendingService(aClass, currentPRThread);
   -------------------------------------------------------------------------
   Potentially buggy differences:
2| if (currentThread && entry->mServiceObject) {
>      ^^^^^^^^^^^^^ ^^
   -------------------------------------------------------------------------
   c:\mozilla-central\xpcom\components\nscomponentmanager.cpp 1606:4 -> 1655:4
   -------------------------------------------------------------------------
   if (entry->mServiceObject) {
       nsCOMPtr<nsISupports> serviceObject = entry->mServiceObject;
   
       // We need to not be holding the service manager's monitor while calling
       // QueryInterface, because it invokes user code which could try to re-enter
       // the service manager, or try to grab some other lock/monitor/condvar
       // and deadlock, e.g. bug 282743.
       mon.Exit();
       return serviceObject->QueryInterface(aIID, result);
   }
   
   // We only care about time when we create the service.
   COMPMGR_TIME_FUNCTION_CONTRACTID(aContractID);
   
   PRThread* currentPRThread = PR_GetCurrentThread();
   NS_ASSERTION(currentPRThread, "This should never be null!");
   
   // Needed to optimize the event loop below.
   nsIThread* currentThread = nsnull;
   
   PRThread* pendingPRThread;
   while ((pendingPRThread = GetPendingServiceThread(*entry->mCIDEntry->cid))) {
       if (pendingPRThread == currentPRThread) {
           NS_ERROR("Recursive GetService!");
           return NS_ERROR_NOT_AVAILABLE;
       }
   
       mon.Exit();
   
       if (!currentThread) {
           currentThread = NS_GetCurrentThread();
           NS_ASSERTION(currentThread, "This should never be null!");
       }
   
       // This will process a single event or yield the thread if no event is
       // pending.
       if (!NS_ProcessNextEvent(currentThread, PR_FALSE)) {
           PR_Sleep(PR_INTERVAL_NO_WAIT);
       }
   
       mon.Enter();
   }
   
   if (currentThread && entry->mServiceObject) {
       // If we have a currentThread then we must have waited on another thread
       // to create the service. Grab it now if that succeeded.
       nsCOMPtr<nsISupports> serviceObject = entry->mServiceObject;
       mon.Exit();
       return serviceObject->QueryInterface(aIID, result);
   }
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 113: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.723 | CED: 1 | FED: 4 (4.6%) | SZ: 87 | XF: F | XP: F | D: 4
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\js\src\jsemit.cpp 3414:20 -> 3428:41
   -------------------------------------------------------------------------
   if (pn3 &&
       (pn4 = pn3->pn_left) != NULL &&
       pn4->pn_type == TOK_NAME) {
       /* Note a propagated constant with the const's name. */
       JS_ASSERT(!pn4->maybeExpr());
       ale = cg->atomList.add(cg->parser, pn4->pn_atom);
       if (!ale)
           goto bad;
       CG_NEXT(cg) = pc;
       if (js_NewSrcNote2(cx, cg, SRC_LABEL, (ptrdiff_t)
                          ALE_INDEX(ale)) < 0) {
           goto bad;
       }
   }
   pc += JUMP_OFFSET_LEN;
   -------------------------------------------------------------------------
   Potentially buggy differences:
1|     (pn4 = pn3->pn_left) != NULL &&
>                         - -- ----
2| if (pn4 && pn4->pn_type == TOK_NAME) {
>  -- ----
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\js\src\jsemit.cpp 3432:24 -> 3445:53
   -------------------------------------------------------------------------
   pn4 = pn3->pn_left;
   if (pn4 && pn4->pn_type == TOK_NAME) {
       /* Note a propagated constant with the const's name. */
       JS_ASSERT(!pn4->maybeExpr());
       ale = cg->atomList.add(cg->parser, pn4->pn_atom);
       if (!ale)
           goto bad;
       CG_NEXT(cg) = pc;
       if (js_NewSrcNote2(cx, cg, SRC_LABEL, (ptrdiff_t)
                          ALE_INDEX(ale)) < 0) {
           goto bad;
       }
   }
   pc += INDEX_LEN + JUMP_OFFSET_LEN;
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 114: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.608 | CED: 1 | FED: 1 (1.2%) | SZ: 86 | XF: T | XP: F | D: inf
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\jpeg\jccoefct.c 72:0 -> 92:0
   -------------------------------------------------------------------------
   start_iMCU_row (j_compress_ptr cinfo)
   /* Reset within-iMCU-row counters for a new row */
   {
     my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
   
     /* In an interleaved scan, an MCU row is the same as an iMCU row.
      * In a noninterleaved scan, an iMCU row has v_samp_factor MCU rows.
      * But at the bottom of the image, process only what's left.
      */
     if (cinfo->comps_in_scan > 1) {
       coef->MCU_rows_per_iMCU_row = 1;
     } else {
       if (coef->iMCU_row_num < (cinfo->total_iMCU_rows-1))
         coef->MCU_rows_per_iMCU_row = cinfo->cur_comp_info[0]->v_samp_factor;
       else
         coef->MCU_rows_per_iMCU_row = cinfo->cur_comp_info[0]->last_row_height;
     }
   
     coef->mcu_ctr = 0;
     coef->MCU_vert_offset = 0;
   }
   -------------------------------------------------------------------------
   Potentially buggy differences:
1|     if (coef->iMCU_row_num < (cinfo->total_iMCU_rows-1))
>          ----
2|     if (cinfo->input_iMCU_row < (cinfo->total_iMCU_rows-1))
>          -----
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\jpeg\jdcoefct.c 79:0 -> 99:0
   -------------------------------------------------------------------------
   start_iMCU_row (j_decompress_ptr cinfo)
   /* Reset within-iMCU-row counters for a new row (input side) */
   {
     my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
   
     /* In an interleaved scan, an MCU row is the same as an iMCU row.
      * In a noninterleaved scan, an iMCU row has v_samp_factor MCU rows.
      * But at the bottom of the image, process only what's left.
      */
     if (cinfo->comps_in_scan > 1) {
       coef->MCU_rows_per_iMCU_row = 1;
     } else {
       if (cinfo->input_iMCU_row < (cinfo->total_iMCU_rows-1))
         coef->MCU_rows_per_iMCU_row = cinfo->cur_comp_info[0]->v_samp_factor;
       else
         coef->MCU_rows_per_iMCU_row = cinfo->cur_comp_info[0]->last_row_height;
     }
   
     coef->MCU_ctr = 0;
     coef->MCU_vert_offset = 0;
   }
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 115: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.530 | CED: 1 | FED: 4 (2.7%) | SZ: 149 | XF: F | XP: F | D: 26
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\content\canvas\src\webglcontextgl.cpp 1095:14 -> 1120:4
   -------------------------------------------------------------------------
   WebGLuint progname;
   if (!GetGLName<WebGLProgram>("getActiveAttrib: program", pobj, &progname))
       return NS_OK;
   
   NativeJSContext js;
   if (NS_FAILED(js.error))
       return js.error;
   
   MakeContextCurrent();
   
   GLint len = 0;
   gl->fGetProgramiv(progname, LOCAL_GL_ACTIVE_ATTRIBUTE_MAX_LENGTH, &len);
   if (len == 0) {
       *retval = nsnull;
       return NS_OK;
   }
   
   nsAutoArrayPtr<char> name(new char[len]);
   PRInt32 attrsize = 0;
   PRUint32 attrtype = 0;
   
   gl->fGetActiveAttrib(progname, index, len, &len, (GLint*) &attrsize, (WebGLuint*) &attrtype, name);
   if (attrsize == 0 || attrtype == 0) {
       *retval = nsnull;
       return NS_OK;
   }
   -------------------------------------------------------------------------
   Potentially buggy differences:
2| if (len == 0 || attrsize == 0 || attrtype == 0) {
>      ^^^ ^^ ^ ^^
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\content\canvas\src\webglcontextgl.cpp 1146:14 -> 1172:4
   -------------------------------------------------------------------------
   WebGLuint progname;
   if (!GetGLName<WebGLProgram>("getActiveUniform: program", pobj, &progname))
       return NS_OK;
   
   NativeJSContext js;
   if (NS_FAILED(js.error))
       return js.error;
   
   MakeContextCurrent();
   
   GLint len = 0;
   gl->fGetProgramiv(progname, LOCAL_GL_ACTIVE_UNIFORM_MAX_LENGTH, &len);
   if (len == 0) {
       *retval = nsnull;
       return NS_OK;
   }
   
   nsAutoArrayPtr<char> name(new char[len + 3]); // +3 because we might have to append "[0]", see below
   
   PRInt32 attrsize = 0;
   PRUint32 attrtype = 0;
   
   gl->fGetActiveUniform(progname, index, len, &len, (GLint*) &attrsize, (WebGLenum*) &attrtype, name);
   if (len == 0 || attrsize == 0 || attrtype == 0) {
       *retval = nsnull;
       return NS_OK;
   }
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 116: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.730 | CED: 1 | FED: 2 (2.0%) | SZ: 100 | XF: T | XP: T | D: inf
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\content\base\src\nsdocumentencoder.cpp 707:2 -> 727:15
   -------------------------------------------------------------------------
   if (!aNode) { return NS_ERROR_NULL_POINTER; }
   nsresult result=NS_OK;
   nsCOMPtr<nsIDOMCharacterData>nodeAsChar;
   nodeAsChar = do_QueryInterface(aNode);
   if (nodeAsChar) {
     nodeAsChar->GetLength(&aCount);
   }
   else
   {
     PRBool hasChildNodes;
     aNode->HasChildNodes(&hasChildNodes);
     if (PR_TRUE==hasChildNodes)
     {
       nsCOMPtr<nsIDOMNodeList>nodeList;
       result = aNode->GetChildNodes(getter_AddRefs(nodeList));
       if (NS_SUCCEEDED(result) && nodeList) {
         nodeList->GetLength(&aCount);
       }
     }
   }
   return result;
   -------------------------------------------------------------------------
   Potentially buggy differences:
1| nsCOMPtr<nsIDOMCharacterData>nodeAsChar;
>                               ^^^^^^^^^^
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\editor\libeditor\base\nseditor.cpp 3008:9 -> 3028:15
   -------------------------------------------------------------------------
   aCount = 0;
   if (!aNode) { return NS_ERROR_NULL_POINTER; }
   nsresult result=NS_OK;
   nsCOMPtr<nsIDOMCharacterData>nodeAsChar = do_QueryInterface(aNode);
   if (nodeAsChar) {
     nodeAsChar->GetLength(&aCount);
   }
   else
   {
     PRBool hasChildNodes;
     aNode->HasChildNodes(&hasChildNodes);
     if (hasChildNodes)
     {
       nsCOMPtr<nsIDOMNodeList>nodeList;
       result = aNode->GetChildNodes(getter_AddRefs(nodeList));
       if (NS_SUCCEEDED(result) && nodeList) {
         nodeList->GetLength(&aCount);
       }
     }
   }
   return result;
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 117: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.559 | CED: 2 | FED: 12 (12.0%) | SZ: 100 | XF: F | XP: F | D: 51
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\xpcom\io\nsunicharinputstream.cpp 222:2 -> 241:14
   -------------------------------------------------------------------------
   NS_ASSERTION(mUnicharDataLength >= mUnicharDataOffset, "unsigned madness");
   PRUint32 readCount = mUnicharDataLength - mUnicharDataOffset;
   nsresult errorCode;
   if (0 == readCount) {
     // Fill the unichar buffer
     PRInt32 bytesRead = Fill(&errorCode);
     if (bytesRead <= 0) {
       *aReadCount = 0;
       return errorCode;
     }
     readCount = bytesRead;
   }
   if (readCount > aCount) {
     readCount = aCount;
   }
   memcpy(aBuf, mUnicharData->GetBuffer() + mUnicharDataOffset,
          readCount * sizeof(PRUnichar));
   mUnicharDataOffset += readCount;
   *aReadCount = readCount;
   return NS_OK;
   -------------------------------------------------------------------------
   Potentially buggy differences:
2| const PRUnichar* buf = reinterpret_cast<const PRUnichar*>(mUnicharData->GetBuffer() +
>                       ^ ^^^^^^^^^^^^^^^^^^^^^^ ^^^^^^^^^^^

1|        readCount * sizeof(PRUnichar));
>                   ^ ^^^^^^^^^^^^^^^^^
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\xpcom\io\nsunicharinputstream.cpp 292:2 -> 313:14
   -------------------------------------------------------------------------
   NS_ASSERTION(mUnicharDataLength >= mUnicharDataOffset, "unsigned madness");
   PRUint32 readCount = mUnicharDataLength - mUnicharDataOffset;
   nsresult errorCode;
   if (0 == readCount) {
     // Fill the unichar buffer
     PRInt32 bytesRead = Fill(&errorCode);
     if (bytesRead <= 0) {
       *aReadCount = 0;
       return errorCode;
     }
     readCount = bytesRead;
   }
   if (readCount > aCount) {
     readCount = aCount;
   }
   const PRUnichar* buf = reinterpret_cast<const PRUnichar*>(mUnicharData->GetBuffer() +
                                              mUnicharDataOffset);
   aString.Assign(buf, readCount);
   
   mUnicharDataOffset += readCount;
   *aReadCount = readCount;
   return NS_OK;
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 118: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.765 | CED: 1 | FED: 3 (3.0%) | SZ: 101 | XF: F | XP: F | D: 368
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\extensions\spellcheck\hunspell\src\affentry.cpp 69:9 -> 86:15
   -------------------------------------------------------------------------
   pmyMgr = pmgr;
   
   // set up its initial values
   
   aflag = dp->aflag;         // flag
   strip = dp->strip;         // string to strip
   appnd = dp->appnd;         // string to append
   stripl = dp->stripl;       // length of strip string
   appndl = dp->appndl;       // length of append string
   numconds = dp->numconds;   // length of the condition
   opts = dp->opts;           // cross product flag
   // then copy over all of the conditions
   if (opts & aeLONGCOND) {
     memcpy(c.conds, dp->c.l.conds1, MAXCONDLEN_1);
     c.l.conds2 = dp->c.l.conds2;
   } else memcpy(c.conds, dp->c.conds, MAXCONDLEN);
   next = NULL;
   nextne = NULL;
   -------------------------------------------------------------------------
   Potentially buggy differences:
1|   memcpy(c.conds, dp->c.l.conds1, MAXCONDLEN_1);
>             -----
2|   memcpy(c.l.conds1, dp->c.l.conds1, MAXCONDLEN_1);
>             --------
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\extensions\spellcheck\hunspell\src\affentry.cpp 454:9 -> 471:29
   -------------------------------------------------------------------------
   pmyMgr = pmgr;
   
   // set up its initial values
   aflag = dp->aflag;         // char flag
   strip = dp->strip;         // string to strip
   appnd = dp->appnd;         // string to append
   stripl = dp->stripl;       // length of strip string
   appndl = dp->appndl;       // length of append string
   numconds = dp->numconds;   // length of the condition
   opts = dp->opts;           // cross product flag
   
   // then copy over all of the conditions
   if (opts & aeLONGCOND) {
     memcpy(c.l.conds1, dp->c.l.conds1, MAXCONDLEN_1);
     c.l.conds2 = dp->c.l.conds2;
   } else memcpy(c.conds, dp->c.conds, MAXCONDLEN);
   
   rappnd = myrevstrdup(appnd);
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 119: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.645 | CED: 3 | FED: 10 (8.4%) | SZ: 119 | XF: F | XP: F | D: 13
   -------------------------------------------------------------------------
   c:\comm-central\directory\c-sdk\ldap\libraries\libprldap\ldappr-public.c 325:0 -> 350:0
   -------------------------------------------------------------------------
   prldap_get_default_socket_info( LDAP *ld, PRLDAPSocketInfo *soip )
   {
       int rc;
       PRLDAPIOSocketArg *prsockp;
   
   
       if ( NULL == soip || PRLDAP_SOCKETINFO_SIZE != soip->soinfo_size ) {
           ldap_set_lderrno( ld, LDAP_PARAM_ERROR, NULL, NULL );
           return( LDAP_PARAM_ERROR );
       }
   
       if ( NULL != ld ) {
           if ( LDAP_SUCCESS !=
                   ( rc = prldap_socket_arg_from_ld( ld, &prsockp ))) {
               return( rc );
           }
       } else {
           ldap_set_lderrno( ld, LDAP_PARAM_ERROR, NULL, NULL );
           return( LDAP_PARAM_ERROR );
       }
   
       soip->soinfo_prfd = prsockp->prsock_prfd;
       soip->soinfo_appdata = prsockp->prsock_appdata;
   
       return( LDAP_SUCCESS );
   }
   -------------------------------------------------------------------------
   Potentially buggy differences:
2|     prsockp->prsock_prfd = soip->soinfo_prfd;
>      ^^^^^^^^^^^^^^^^^^^^ ^

1|     soip->soinfo_prfd = prsockp->prsock_prfd;
>                                   -----------
1|     soip->soinfo_appdata = prsockp->prsock_appdata;
>                           ^ ^^^^^^^^^^^^^^^^^^^^^^^
2|     prsockp->prsock_appdata = soip->soinfo_appdata;
>               -------------- -
   -------------------------------------------------------------------------
   c:\comm-central\directory\c-sdk\ldap\libraries\libprldap\ldappr-public.c 363:0 -> 388:0
   -------------------------------------------------------------------------
   prldap_set_default_socket_info( LDAP *ld, PRLDAPSocketInfo *soip )
   {
       int rc;
       PRLDAPIOSocketArg *prsockp;
   
   
       if ( NULL == soip || PRLDAP_SOCKETINFO_SIZE != soip->soinfo_size ) {
           ldap_set_lderrno( ld, LDAP_PARAM_ERROR, NULL, NULL );
           return( LDAP_PARAM_ERROR );
       }
   
       if ( NULL != ld ) {
           if ( LDAP_SUCCESS !=
                   ( rc = prldap_socket_arg_from_ld( ld, &prsockp ))) {
               return( rc );
           }
       } else {
           ldap_set_lderrno( ld, LDAP_PARAM_ERROR, NULL, NULL );
           return( LDAP_PARAM_ERROR );
       }
   
       prsockp->prsock_prfd = soip->soinfo_prfd;
       prsockp->prsock_appdata = soip->soinfo_appdata;
   
       return( LDAP_SUCCESS );
   }
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 120: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.759 | CED: 1 | FED: 2 (1.5%) | SZ: 132 | XF: T | XP: T | D: inf
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\dom\base\nsjsutils.cpp 124:13 -> 151:12
   -------------------------------------------------------------------------
   nsISupports* supports;
   JSClass* clazz;
   JSObject* parent;
   JSObject* glob = aObj; // starting point for search
   
   if (!glob)
     return nsnull;
   
   while ((parent = ::JS_GetParent(aContext, glob)))
     glob = parent;
   
   clazz = JS_GET_CLASS(aContext, glob);
   
   if (!clazz ||
       !(clazz->flags & JSCLASS_HAS_PRIVATE) ||
       !(clazz->flags & JSCLASS_PRIVATE_IS_NSISUPPORTS) ||
       !(supports = (nsISupports*)::JS_GetPrivate(aContext, glob))) {
     return nsnull;
   }
   
   nsCOMPtr<nsIXPConnectWrappedNative> wrapper(do_QueryInterface(supports));
   NS_ENSURE_TRUE(wrapper, nsnull);
   
   nsCOMPtr<nsIScriptGlobalObject> sgo(do_QueryWrappedNative(wrapper));
   
   // We're returning a pointer to something that's about to be
   // released, but that's ok here.
   return sgo;
   -------------------------------------------------------------------------
   Potentially buggy differences:
2| while (nsnull != (parent = JS_GetParent(aContext, glob)))
>         ^^^^^^ ^^
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\embedding\components\windowwatcher\src\nswwjsutils.cpp 52:13 -> 79:12
   -------------------------------------------------------------------------
   nsISupports* supports;
   JSClass* clazz;
   JSObject* parent;
   JSObject* glob = aObj; // starting point for search
   
   if (!glob)
     return nsnull;
   
   while (nsnull != (parent = JS_GetParent(aContext, glob)))
     glob = parent;
   
   clazz = JS_GET_CLASS(aContext, glob);
   
   if (!clazz ||
       !(clazz->flags & JSCLASS_HAS_PRIVATE) ||
       !(clazz->flags & JSCLASS_PRIVATE_IS_NSISUPPORTS) ||
       !(supports = (nsISupports*) JS_GetPrivate(aContext, glob))) {
     return nsnull;
   }
   
   nsCOMPtr<nsIXPConnectWrappedNative> wrapper(do_QueryInterface(supports));
   NS_ENSURE_TRUE(wrapper, nsnull);
   
   nsCOMPtr<nsIScriptGlobalObject> sgo(do_QueryWrappedNative(wrapper));
   
   // This will return a pointer to something we're about to release,
   // but that's ok here.
   return sgo;
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 121: 2 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.731 | CED: 1 | FED: 2 (3.3%) | SZ: 61 | XF: T | XP: T | D: inf
   -------------------------------------------------------------------------
   c:\comm-central\mailnews\addrbook\src\nsaddrdatabase.cpp 336:34 -> 346:0
   -------------------------------------------------------------------------
   void nsAddrDatabase::GetMDBFactory(nsIMdbFactory ** aMdbFactory)
   {
     if (!mMdbFactory)
     {
       nsresult rv;
       nsCOMPtr <nsIMdbFactoryService> mdbFactoryService = do_GetService(NS_MORK_CONTRACTID, &rv);
       if (NS_SUCCEEDED(rv) && mdbFactoryService)
         rv = mdbFactoryService->GetMdbFactory(getter_AddRefs(mMdbFactory));
     }
     NS_IF_ADDREF(*aMdbFactory = mMdbFactory);
   }
   -------------------------------------------------------------------------
   Potentially buggy differences:
1|       rv = mdbFactoryService->GetMdbFactory(getter_AddRefs(mMdbFactory));
>        ^^ ^
   -------------------------------------------------------------------------
   c:\comm-central\mailnews\db\msgdb\src\nsmsgdatabase.cpp 1098:33 -> 1108:0
   -------------------------------------------------------------------------
   void nsMsgDatabase::GetMDBFactory(nsIMdbFactory ** aMdbFactory)
   {
     if (!mMdbFactory)
     {
       nsresult rv;
       nsCOMPtr <nsIMdbFactoryService> mdbFactoryService = do_GetService(NS_MORK_CONTRACTID, &rv);
       if (NS_SUCCEEDED(rv) && mdbFactoryService)
         mdbFactoryService->GetMdbFactory(getter_AddRefs(mMdbFactory));
     }
     NS_IF_ADDREF(*aMdbFactory = mMdbFactory);
   }
   -------------------------------------------------------------------------

 Pair b.) TxtSim: 0.731 | CED: 1 | FED: 2 (3.3%) | SZ: 61 | XF: T | XP: T | D: inf
   -------------------------------------------------------------------------
   c:\comm-central\mailnews\base\src\nsmsgfoldercache.cpp 76:36 -> 86:0
   -------------------------------------------------------------------------
   void nsMsgFolderCache::GetMDBFactory(nsIMdbFactory ** aMdbFactory)
   {
     if (!mMdbFactory)
     {
       nsresult rv;
       nsCOMPtr <nsIMdbFactoryService> mdbFactoryService = do_GetService(NS_MORK_CONTRACTID, &rv);
       if (NS_SUCCEEDED(rv) && mdbFactoryService)
         rv = mdbFactoryService->GetMdbFactory(getter_AddRefs(mMdbFactory));
     }
     NS_IF_ADDREF(*aMdbFactory = mMdbFactory);
   }
   -------------------------------------------------------------------------
   Potentially buggy differences:
1|       rv = mdbFactoryService->GetMdbFactory(getter_AddRefs(mMdbFactory));
>        ^^ ^
   -------------------------------------------------------------------------
   c:\comm-central\mailnews\db\msgdb\src\nsmsgdatabase.cpp 1098:33 -> 1108:0
   -------------------------------------------------------------------------
   void nsMsgDatabase::GetMDBFactory(nsIMdbFactory ** aMdbFactory)
   {
     if (!mMdbFactory)
     {
       nsresult rv;
       nsCOMPtr <nsIMdbFactoryService> mdbFactoryService = do_GetService(NS_MORK_CONTRACTID, &rv);
       if (NS_SUCCEEDED(rv) && mdbFactoryService)
         mdbFactoryService->GetMdbFactory(getter_AddRefs(mMdbFactory));
     }
     NS_IF_ADDREF(*aMdbFactory = mMdbFactory);
   }
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 122: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.720 | CED: 2 | FED: 9 (3.1%) | SZ: 288 | XF: T | XP: F | D: inf
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\jpeg\jchuff.c 182:13 -> 238:8
   -------------------------------------------------------------------------
   JHUFF_TBL *htbl;
   c_derived_tbl *dtbl;
   int p, i, l, lastp, si, maxsymbol;
   char huffsize[257];
   unsigned int huffcode[257];
   unsigned int code;
   
   /* Note that huffsize[] and huffcode[] are filled in code-length order,
    * paralleling the order of the symbols themselves in htbl->huffval[].
    */
   
   /* Find the input Huffman table */
   if (tblno < 0 || tblno >= NUM_HUFF_TBLS)
     ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, tblno);
   htbl =
     isDC ? cinfo->dc_huff_tbl_ptrs[tblno] : cinfo->ac_huff_tbl_ptrs[tblno];
   if (htbl == NULL)
     ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, tblno);
   
   /* Allocate a workspace if we haven't already done so. */
   if (*pdtbl == NULL)
     *pdtbl = (c_derived_tbl *)
       (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
                   SIZEOF(c_derived_tbl));
   dtbl = *pdtbl;
   
   /* Figure C.1: make table of Huffman code length for each symbol */
   
   p = 0;
   for (l = 1; l <= 16; l++) {
     i = (int) htbl->bits[l];
     if (i < 0 || p + i > 256)    /* protect against table overrun */
       ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);
     while (i--)
       huffsize[p++] = (char) l;
   }
   huffsize[p] = 0;
   lastp = p;
   
   /* Figure C.2: generate the codes themselves */
   /* We also validate that the counts represent a legal Huffman code tree. */
   
   code = 0;
   si = huffsize[0];
   p = 0;
   while (huffsize[p]) {
     while (((int) huffsize[p]) == si) {
       huffcode[p++] = code;
       code++;
     }
     /* code is now 1 more than the last code used for codelength si; but
      * it must still fit in si bits, since no code is allowed to be all ones.
      */
     if (((INT32) code) >= (((INT32) 1) << si))
       ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);
     code <<= 1;
     si++;
   -------------------------------------------------------------------------
   Potentially buggy differences:
1| int p, i, l, lastp, si, maxsymbol;
>                    - ---
2| int lookbits, ctr;
>  ---

2| dtbl->pub = htbl;        
>  ^^^^^^^^^ ^ ^^^^
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\jpeg\jdhuff.c 152:13 -> 210:8
   -------------------------------------------------------------------------
   JHUFF_TBL *htbl;
   d_derived_tbl *dtbl;
   int p, i, l, si, numsymbols;
   int lookbits, ctr;
   char huffsize[257];
   unsigned int huffcode[257];
   unsigned int code;
   
   /* Note that huffsize[] and huffcode[] are filled in code-length order,
    * paralleling the order of the symbols themselves in htbl->huffval[].
    */
   
   /* Find the input Huffman table */
   if (tblno < 0 || tblno >= NUM_HUFF_TBLS)
     ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, tblno);
   htbl =
     isDC ? cinfo->dc_huff_tbl_ptrs[tblno] : cinfo->ac_huff_tbl_ptrs[tblno];
   if (htbl == NULL)
     ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, tblno);
   
   /* Allocate a workspace if we haven't already done so. */
   if (*pdtbl == NULL)
     *pdtbl = (d_derived_tbl *)
       (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
                   SIZEOF(d_derived_tbl));
   dtbl = *pdtbl;
   dtbl->pub = htbl;        /* fill in back link */
   
   /* Figure C.1: make table of Huffman code length for each symbol */
   
   p = 0;
   for (l = 1; l <= 16; l++) {
     i = (int) htbl->bits[l];
     if (i < 0 || p + i > 256)    /* protect against table overrun */
       ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);
     while (i--)
       huffsize[p++] = (char) l;
   }
   huffsize[p] = 0;
   numsymbols = p;
   
   /* Figure C.2: generate the codes themselves */
   /* We also validate that the counts represent a legal Huffman code tree. */
   
   code = 0;
   si = huffsize[0];
   p = 0;
   while (huffsize[p]) {
     while (((int) huffsize[p]) == si) {
       huffcode[p++] = code;
       code++;
     }
     /* code is now 1 more than the last code used for codelength si; but
      * it must still fit in si bits, since no code is allowed to be all ones.
      */
     if (((INT32) code) >= (((INT32) 1) << si))
       ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);
     code <<= 1;
     si++;
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 123: 4 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.676 | CED: 1 | FED: 9 (7.0%) | SZ: 128 | XF: F | XP: F | D: 32
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\content\canvas\src\nscanvasrenderingcontext2d.cpp 1544:42 -> 1574:0
   -------------------------------------------------------------------------
   nsCanvasRenderingContext2D::SetStrokeStyle(nsIVariant *aValue)
   {
       if (!aValue)
           return NS_ERROR_FAILURE;
   
       nsString str;
   
       nsresult rv;
       PRUint16 vtype;
       rv = aValue->GetDataType(&vtype);
       NS_ENSURE_SUCCESS(rv, rv);
   
       if (vtype == nsIDataType::VTYPE_INTERFACE ||
           vtype == nsIDataType::VTYPE_INTERFACE_IS)
       {
           nsIID *iid;
           nsCOMPtr<nsISupports> sup;
           rv = aValue->GetAsInterface(&iid, getter_AddRefs(sup));
           NS_ENSURE_SUCCESS(rv, rv);
           if (iid)
               NS_Free(iid);
   
           str.SetIsVoid(PR_TRUE);
           return SetStrokeStyle_multi(str, sup);
       }
   
       rv = aValue->GetAsAString(str);
       NS_ENSURE_SUCCESS(rv, rv);
   
       return SetStrokeStyle_multi(str, nsnull);
   }
   -------------------------------------------------------------------------
   Potentially buggy differences:
1|         if (iid)
>          ^^ ^^^^^
1|             NS_Free(iid);
>              ^^^^^^^^^^^^
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\content\canvas\src\nscanvasrenderingcontext2d.cpp 1606:40 -> 1633:0
   -------------------------------------------------------------------------
   nsCanvasRenderingContext2D::SetFillStyle(nsIVariant *aValue)
   {
       if (!aValue)
           return NS_ERROR_FAILURE;
   
       nsString str;
       nsresult rv;
       PRUint16 vtype;
       rv = aValue->GetDataType(&vtype);
       NS_ENSURE_SUCCESS(rv, rv);
   
       if (vtype == nsIDataType::VTYPE_INTERFACE ||
           vtype == nsIDataType::VTYPE_INTERFACE_IS)
       {
           nsIID *iid;
           nsCOMPtr<nsISupports> sup;
           rv = aValue->GetAsInterface(&iid, getter_AddRefs(sup));
           NS_ENSURE_SUCCESS(rv, rv);
   
           str.SetIsVoid(PR_TRUE);
           return SetFillStyle_multi(str, sup);
       }
   
       rv = aValue->GetAsAString(str);
       NS_ENSURE_SUCCESS(rv, rv);
   
       return SetFillStyle_multi(str, nsnull);
   }
   -------------------------------------------------------------------------

 Pair b.) TxtSim: 0.676 | CED: 1 | FED: 9 (7.0%) | SZ: 128 | XF: T | XP: T | D: inf
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\content\canvas\src\nscanvasrenderingcontext2d.cpp 1544:42 -> 1574:0
   -------------------------------------------------------------------------
   nsCanvasRenderingContext2D::SetStrokeStyle(nsIVariant *aValue)
   {
       if (!aValue)
           return NS_ERROR_FAILURE;
   
       nsString str;
   
       nsresult rv;
       PRUint16 vtype;
       rv = aValue->GetDataType(&vtype);
       NS_ENSURE_SUCCESS(rv, rv);
   
       if (vtype == nsIDataType::VTYPE_INTERFACE ||
           vtype == nsIDataType::VTYPE_INTERFACE_IS)
       {
           nsIID *iid;
           nsCOMPtr<nsISupports> sup;
           rv = aValue->GetAsInterface(&iid, getter_AddRefs(sup));
           NS_ENSURE_SUCCESS(rv, rv);
           if (iid)
               NS_Free(iid);
   
           str.SetIsVoid(PR_TRUE);
           return SetStrokeStyle_multi(str, sup);
       }
   
       rv = aValue->GetAsAString(str);
       NS_ENSURE_SUCCESS(rv, rv);
   
       return SetStrokeStyle_multi(str, nsnull);
   }
   -------------------------------------------------------------------------
   Potentially buggy differences:
1|         if (iid)
>          ^^ ^^^^^
1|             NS_Free(iid);
>              ^^^^^^^^^^^^
   -------------------------------------------------------------------------
   c:\mozilla-central\content\canvas\src\nscanvasrenderingcontext2d.cpp 1606:40 -> 1633:0
   -------------------------------------------------------------------------
   nsCanvasRenderingContext2D::SetFillStyle(nsIVariant *aValue)
   {
       if (!aValue)
           return NS_ERROR_FAILURE;
   
       nsString str;
       nsresult rv;
       PRUint16 vtype;
       rv = aValue->GetDataType(&vtype);
       NS_ENSURE_SUCCESS(rv, rv);
   
       if (vtype == nsIDataType::VTYPE_INTERFACE ||
           vtype == nsIDataType::VTYPE_INTERFACE_IS)
       {
           nsIID *iid;
           nsCOMPtr<nsISupports> sup;
           rv = aValue->GetAsInterface(&iid, getter_AddRefs(sup));
           NS_ENSURE_SUCCESS(rv, rv);
   
           str.SetIsVoid(PR_TRUE);
           return SetFillStyle_multi(str, sup);
       }
   
       rv = aValue->GetAsAString(str);
       NS_ENSURE_SUCCESS(rv, rv);
   
       return SetFillStyle_multi(str, nsnull);
   }
   -------------------------------------------------------------------------

 Pair c.) TxtSim: 0.676 | CED: 1 | FED: 9 (7.0%) | SZ: 128 | XF: T | XP: T | D: inf
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\content\canvas\src\nscanvasrenderingcontext2d.cpp 1606:40 -> 1633:0
   -------------------------------------------------------------------------
   nsCanvasRenderingContext2D::SetFillStyle(nsIVariant *aValue)
   {
       if (!aValue)
           return NS_ERROR_FAILURE;
   
       nsString str;
       nsresult rv;
       PRUint16 vtype;
       rv = aValue->GetDataType(&vtype);
       NS_ENSURE_SUCCESS(rv, rv);
   
       if (vtype == nsIDataType::VTYPE_INTERFACE ||
           vtype == nsIDataType::VTYPE_INTERFACE_IS)
       {
           nsIID *iid;
           nsCOMPtr<nsISupports> sup;
           rv = aValue->GetAsInterface(&iid, getter_AddRefs(sup));
           NS_ENSURE_SUCCESS(rv, rv);
   
           str.SetIsVoid(PR_TRUE);
           return SetFillStyle_multi(str, sup);
       }
   
       rv = aValue->GetAsAString(str);
       NS_ENSURE_SUCCESS(rv, rv);
   
       return SetFillStyle_multi(str, nsnull);
   }
   -------------------------------------------------------------------------
   Potentially buggy differences:
2|         if (iid)
>          ^^ ^^^^^
2|             NS_Free(iid);
>              ^^^^^^^^^^^^
   -------------------------------------------------------------------------
   c:\mozilla-central\content\canvas\src\nscanvasrenderingcontext2d.cpp 1544:42 -> 1574:0
   -------------------------------------------------------------------------
   nsCanvasRenderingContext2D::SetStrokeStyle(nsIVariant *aValue)
   {
       if (!aValue)
           return NS_ERROR_FAILURE;
   
       nsString str;
   
       nsresult rv;
       PRUint16 vtype;
       rv = aValue->GetDataType(&vtype);
       NS_ENSURE_SUCCESS(rv, rv);
   
       if (vtype == nsIDataType::VTYPE_INTERFACE ||
           vtype == nsIDataType::VTYPE_INTERFACE_IS)
       {
           nsIID *iid;
           nsCOMPtr<nsISupports> sup;
           rv = aValue->GetAsInterface(&iid, getter_AddRefs(sup));
           NS_ENSURE_SUCCESS(rv, rv);
           if (iid)
               NS_Free(iid);
   
           str.SetIsVoid(PR_TRUE);
           return SetStrokeStyle_multi(str, sup);
       }
   
       rv = aValue->GetAsAString(str);
       NS_ENSURE_SUCCESS(rv, rv);
   
       return SetStrokeStyle_multi(str, nsnull);
   }
   -------------------------------------------------------------------------

 Pair d.) TxtSim: 0.676 | CED: 1 | FED: 9 (7.0%) | SZ: 128 | XF: F | XP: F | D: 32
   -------------------------------------------------------------------------
   c:\mozilla-central\content\canvas\src\nscanvasrenderingcontext2d.cpp 1544:42 -> 1574:0
   -------------------------------------------------------------------------
   nsCanvasRenderingContext2D::SetStrokeStyle(nsIVariant *aValue)
   {
       if (!aValue)
           return NS_ERROR_FAILURE;
   
       nsString str;
   
       nsresult rv;
       PRUint16 vtype;
       rv = aValue->GetDataType(&vtype);
       NS_ENSURE_SUCCESS(rv, rv);
   
       if (vtype == nsIDataType::VTYPE_INTERFACE ||
           vtype == nsIDataType::VTYPE_INTERFACE_IS)
       {
           nsIID *iid;
           nsCOMPtr<nsISupports> sup;
           rv = aValue->GetAsInterface(&iid, getter_AddRefs(sup));
           NS_ENSURE_SUCCESS(rv, rv);
           if (iid)
               NS_Free(iid);
   
           str.SetIsVoid(PR_TRUE);
           return SetStrokeStyle_multi(str, sup);
       }
   
       rv = aValue->GetAsAString(str);
       NS_ENSURE_SUCCESS(rv, rv);
   
       return SetStrokeStyle_multi(str, nsnull);
   }
   -------------------------------------------------------------------------
   Potentially buggy differences:
1|         if (iid)
>          ^^ ^^^^^
1|             NS_Free(iid);
>              ^^^^^^^^^^^^
   -------------------------------------------------------------------------
   c:\mozilla-central\content\canvas\src\nscanvasrenderingcontext2d.cpp 1606:40 -> 1633:0
   -------------------------------------------------------------------------
   nsCanvasRenderingContext2D::SetFillStyle(nsIVariant *aValue)
   {
       if (!aValue)
           return NS_ERROR_FAILURE;
   
       nsString str;
       nsresult rv;
       PRUint16 vtype;
       rv = aValue->GetDataType(&vtype);
       NS_ENSURE_SUCCESS(rv, rv);
   
       if (vtype == nsIDataType::VTYPE_INTERFACE ||
           vtype == nsIDataType::VTYPE_INTERFACE_IS)
       {
           nsIID *iid;
           nsCOMPtr<nsISupports> sup;
           rv = aValue->GetAsInterface(&iid, getter_AddRefs(sup));
           NS_ENSURE_SUCCESS(rv, rv);
   
           str.SetIsVoid(PR_TRUE);
           return SetFillStyle_multi(str, sup);
       }
   
       rv = aValue->GetAsAString(str);
       NS_ENSURE_SUCCESS(rv, rv);
   
       return SetFillStyle_multi(str, nsnull);
   }
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 124: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.529 | CED: 2 | FED: 12 (13.0%) | SZ: 92 | XF: F | XP: F | D: 50
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\intl\uconv\src\nsconverterinputstream.cpp 101:2 -> 118:14
   -------------------------------------------------------------------------
   NS_ASSERTION(mUnicharDataLength >= mUnicharDataOffset, "unsigned madness");
   PRUint32 readCount = mUnicharDataLength - mUnicharDataOffset;
   if (0 == readCount) {
     // Fill the unichar buffer
     readCount = Fill(&mLastErrorCode);
     if (readCount == 0) {
       *aReadCount = 0;
       return mLastErrorCode;
     }
   }
   if (readCount > aCount) {
     readCount = aCount;
   }
   memcpy(aBuf, mUnicharData->GetBuffer() + mUnicharDataOffset,
          readCount * sizeof(PRUnichar));
   mUnicharDataOffset += readCount;
   *aReadCount = readCount;
   return NS_OK;
   -------------------------------------------------------------------------
   Potentially buggy differences:
2| const PRUnichar* buf = reinterpret_cast<const PRUnichar*>(mUnicharData->GetBuffer() +
>                       ^ ^^^^^^^^^^^^^^^^^^^^^^ ^^^^^^^^^^^

1|        readCount * sizeof(PRUnichar));
>                   ^ ^^^^^^^^^^^^^^^^^
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\intl\uconv\src\nsconverterinputstream.cpp 168:2 -> 186:14
   -------------------------------------------------------------------------
   NS_ASSERTION(mUnicharDataLength >= mUnicharDataOffset, "unsigned madness");
   PRUint32 readCount = mUnicharDataLength - mUnicharDataOffset;
   if (0 == readCount) {
     // Fill the unichar buffer
     readCount = Fill(&mLastErrorCode);
     if (readCount == 0) {
       *aReadCount = 0;
       return mLastErrorCode;
     }
   }
   if (readCount > aCount) {
     readCount = aCount;
   }
   const PRUnichar* buf = reinterpret_cast<const PRUnichar*>(mUnicharData->GetBuffer() +
                                              mUnicharDataOffset);
   aString.Assign(buf, readCount);
   mUnicharDataOffset += readCount;
   *aReadCount = readCount;
   return NS_OK;
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 125: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.642 | CED: 1 | FED: 2 (2.1%) | SZ: 95 | XF: T | XP: T | D: inf
   -------------------------------------------------------------------------
   c:\comm-central\mailnews\base\util\nsmsgdbfolder.cpp 5578:27 -> 5590:79
   -------------------------------------------------------------------------
   nsCOMPtr<nsIContentSink> sink = do_CreateInstance(NS_PLAINTEXTSINK_CONTRACTID,&rv);
   NS_ENSURE_SUCCESS(rv, rv);
   
   nsCOMPtr<nsIHTMLToTextSink> textSink(do_QueryInterface(sink));
   NS_ENSURE_TRUE(textSink, NS_ERROR_FAILURE);
   PRUint32 flags = nsIDocumentEncoder::OutputLFLineBreak
                    | nsIDocumentEncoder::OutputNoScriptContent
                    | nsIDocumentEncoder::OutputNoFramesContent
                    | nsIDocumentEncoder::OutputBodyOnly;
   
   textSink->Initialize(&bodyText, flags, 80);
   parser->SetContentSink(sink);
   rv = parser->Parse(aMessageText, 0, NS_LITERAL_CSTRING("text/html"), PR_TRUE);
   -------------------------------------------------------------------------
   Potentially buggy differences:
1| rv = parser->Parse(aMessageText, 0, NS_LITERAL_CSTRING("text/html"), PR_TRUE);
>  -- -
2| return parser->Parse(inString, 0, NS_LITERAL_CSTRING("text/html"), PR_TRUE);
>  ------
   -------------------------------------------------------------------------
   c:\comm-central\mailnews\extensions\bayesian-spam-filter\src\nsbayesianfilter.cpp 815:27 -> 829:77
   -------------------------------------------------------------------------
   nsCOMPtr<nsIContentSink> sink = do_CreateInstance(NS_PLAINTEXTSINK_CONTRACTID,&rv);
   NS_ENSURE_SUCCESS(rv, rv);
   
   nsCOMPtr<nsIHTMLToTextSink> textSink(do_QueryInterface(sink));
   NS_ENSURE_TRUE(textSink, NS_ERROR_FAILURE);
   PRUint32 flags = nsIDocumentEncoder::OutputLFLineBreak
                  | nsIDocumentEncoder::OutputNoScriptContent
                  | nsIDocumentEncoder::OutputNoFramesContent
                  | nsIDocumentEncoder::OutputBodyOnly;
   
   textSink->Initialize(&outString, flags, 80);
   
   parser->SetContentSink(sink);
   
   return parser->Parse(inString, 0, NS_LITERAL_CSTRING("text/html"), PR_TRUE);
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 126: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.820 | CED: 1 | FED: 3 (0.7%) | SZ: 414 | XF: T | XP: T | D: inf
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\content\base\src\nsdomattributemap.cpp 270:23 -> 364:26
   -------------------------------------------------------------------------
   nsCOMPtr<nsIDOMNode> tmpReturn;
   
   if (mContent) {
     // XXX should check same-origin between mContent and aNode however
     // nsContentUtils::CheckSameOrigin can't deal with attributenodes yet
   
     nsCOMPtr<nsIAttribute> iAttribute(do_QueryInterface(aNode));
     if (!iAttribute) {
       return NS_ERROR_DOM_HIERARCHY_REQUEST_ERR;
     }
   
     nsDOMAttribute *attribute = static_cast<nsDOMAttribute*>(iAttribute.get());
   
     // Check that attribute is not owned by somebody else
     nsDOMAttributeMap* owner = iAttribute->GetMap();
     if (owner) {
       if (owner != this) {
         return NS_ERROR_DOM_INUSE_ATTRIBUTE_ERR;
       }
   
       // setting a preexisting attribute is a no-op, just return the same
       // node.
       NS_ADDREF(*aReturn = aNode);
   
       return NS_OK;
     }
   
     if (!mContent->HasSameOwnerDoc(iAttribute)) {
       nsCOMPtr<nsIDOM3Document> domDoc =
         do_QueryInterface(mContent->GetOwnerDoc(), &rv);
       NS_ENSURE_SUCCESS(rv, rv);
   
       nsCOMPtr<nsIDOMNode> adoptedNode;
       rv = domDoc->AdoptNode(aNode, getter_AddRefs(adoptedNode));
       NS_ENSURE_SUCCESS(rv, rv);
   
       NS_ASSERTION(adoptedNode == aNode, "Uh, adopt node changed nodes?");
     }
   
     // Get nodeinfo and preexisting attribute (if it exists)
     nsAutoString name;
     nsCOMPtr<nsINodeInfo> ni;
   
     // SetNamedItemNS()
     if (aWithNS) {
       // Return existing attribute, if present
       ni = iAttribute->NodeInfo();
   
       if (mContent->HasAttr(ni->NamespaceID(), ni->NameAtom())) {
         rv = RemoveAttribute(ni, getter_AddRefs(tmpReturn));
         NS_ENSURE_SUCCESS(rv, rv);
       }
     }
     else { // SetNamedItem()
       attribute->GetName(name);
   
       // get node-info of old attribute
       ni = mContent->GetExistingAttrNameFromQName(name);
       if (ni) {
         rv = RemoveAttribute(ni, getter_AddRefs(tmpReturn));
         NS_ENSURE_SUCCESS(rv, rv);
       }
       else {
         if (mContent->IsInHTMLDocument() &&
             mContent->IsHTML()) {
           nsAutoString lower;
           ToLowerCase(name, lower);
           name = lower;
         }
   
         rv = mContent->NodeInfo()->NodeInfoManager()->
           GetNodeInfo(name, nsnull, kNameSpaceID_None, getter_AddRefs(ni));
         NS_ENSURE_SUCCESS(rv, rv);
         // value is already empty
       }
     }
   
     nsAutoString value;
     attribute->GetValue(value);
   
     // Add the new attribute to the attribute map before updating
     // its value in the element. @see bug 364413.
     nsAttrKey attrkey(ni->NamespaceID(), ni->NameAtom());
     rv = mAttributeCache.Put(attrkey, attribute);
     NS_ENSURE_SUCCESS(rv, rv);
     iAttribute->SetMap(this);
   
     rv = mContent->SetAttr(ni->NamespaceID(), ni->NameAtom(),
                            ni->GetPrefixAtom(), value, PR_TRUE);
     if (NS_FAILED(rv)) {
       DropAttribute(ni->NamespaceID(), ni->NameAtom());
     }
   }
   
   tmpReturn.swap(*aReturn); // transfers ref.
   -------------------------------------------------------------------------
   Potentially buggy differences:
2|   if (!attribute || !iAttribute) {
>         ^^^^^^^^^ ^^ ^
   -------------------------------------------------------------------------
   c:\mozilla-central\content\base\src\nsdomattributemap.cpp 281:2 -> 370:2
   -------------------------------------------------------------------------
   if (mContent) {
     // XXX should check same-origin between mContent and aNode however
     // nsContentUtils::CheckSameOrigin can't deal with attributenodes yet
   
     nsCOMPtr<nsIDOMAttr> attribute(do_QueryInterface(aNode));
     nsCOMPtr<nsIAttribute> iAttribute(do_QueryInterface(aNode));
     if (!attribute || !iAttribute) {
       return NS_ERROR_DOM_HIERARCHY_REQUEST_ERR;
     }
   
     // Check that attribute is not owned by somebody else
     nsDOMAttributeMap* owner = iAttribute->GetMap();
     if (owner) {
       if (owner != this) {
         return NS_ERROR_DOM_INUSE_ATTRIBUTE_ERR;
       }
   
       // setting a preexisting attribute is a no-op, just return the same
       // node.
       NS_ADDREF(*aReturn = aNode);
   
       return NS_OK;
     }
   
     if (!mContent->HasSameOwnerDoc(iAttribute)) {
       nsCOMPtr<nsIDOM3Document> domDoc =
         do_QueryInterface(mContent->GetOwnerDoc(), &rv);
       NS_ENSURE_SUCCESS(rv, rv);
   
       nsCOMPtr<nsIDOMNode> adoptedNode;
       rv = domDoc->AdoptNode(aNode, getter_AddRefs(adoptedNode));
       NS_ENSURE_SUCCESS(rv, rv);
   
       NS_ASSERTION(adoptedNode == aNode, "Uh, adopt node changed nodes?");
     }
   
     // Get nodeinfo and preexisting attribute (if it exists)
     nsAutoString name;
     nsCOMPtr<nsINodeInfo> ni;
   
     // SetNamedItemNS()
     if (aWithNS) {
       // Return existing attribute, if present
       ni = iAttribute->NodeInfo();
   
       if (mContent->HasAttr(ni->NamespaceID(), ni->NameAtom())) {
         rv = RemoveAttribute(ni, getter_AddRefs(tmpReturn));
         NS_ENSURE_SUCCESS(rv, rv);
       }
     }
     else { // SetNamedItem()
       attribute->GetName(name);
   
       // get node-info of old attribute
       ni = mContent->GetExistingAttrNameFromQName(name);
       if (ni) {
         rv = RemoveAttribute(ni, getter_AddRefs(tmpReturn));
         NS_ENSURE_SUCCESS(rv, rv);
       }
       else {
         if (mContent->IsInHTMLDocument() &&
             mContent->IsHTML()) {
           nsAutoString lower;
           ToLowerCase(name, lower);
           name = lower;
         }
   
         rv = mContent->NodeInfo()->NodeInfoManager()->
           GetNodeInfo(name, nsnull, kNameSpaceID_None, getter_AddRefs(ni));
         NS_ENSURE_SUCCESS(rv, rv);
         // value is already empty
       }
     }
   
     nsAutoString value;
     attribute->GetValue(value);
   
     // Add the new attribute to the attribute map before updating
     // its value in the element. @see bug 364413.
     nsAttrKey attrkey(ni->NamespaceID(), ni->NameAtom());
     rv = mAttributeCache.Put(attrkey, attribute);
     NS_ENSURE_SUCCESS(rv, rv);
     iAttribute->SetMap(this);
   
     rv = mContent->SetAttr(ni->NamespaceID(), ni->NameAtom(),
                            ni->GetPrefixAtom(), value, PR_TRUE);
     if (NS_FAILED(rv)) {
       DropAttribute(ni->NamespaceID(), ni->NameAtom());
     }
   }
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 127: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.614 | CED: 4 | FED: 6 (3.7%) | SZ: 163 | XF: F | XP: F | D: 39
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\editor\libeditor\html\nshtmleditor.cpp 1208:23 -> 1240:14
   -------------------------------------------------------------------------
   nsCOMPtr<nsIDOMNode> node = NextNodeInBlock(aParentNode, kIterForward);
   nsCOMPtr<nsIDOMNode> tmp;
   while (node)
   {
     PRBool isBlock (PR_FALSE);
     NodeIsBlock(node, &isBlock);
     if (isBlock)  // skip over bold, italic, link, ect nodes
     {
       if (IsTextNode(node) && IsEditable(node))
       {
         textNode = do_QueryInterface(node);
         textNode->GetLength(&strLength);
         if (strLength)
         {
           textNode->SubstringData(0,1,tempString);
           *outIsSpace = nsCRT::IsAsciiSpace(tempString.First());
           *outIsNBSP = (tempString.First() == nbsp);
           if (outNode) *outNode = do_QueryInterface(node);
           if (outOffset) *outOffset = 1;  // yes, this is _past_ the character;
           return NS_OK;
         }
         // else it's an empty text node, or not editable; skip it.
       }
       else  // node is an image or some other thingy that doesn't count as whitespace
       {
         break;
       }
     }
     tmp = node;
     node = NextNodeInBlock(tmp, kIterForward);
   }
   
   return NS_OK;
   -------------------------------------------------------------------------
   Potentially buggy differences:
1|         textNode->SubstringData(0,1,tempString);
>                                    -
2|         textNode->SubstringData(strLength-1,strLength,tempString);
>                                  ^^^^^^^^^^  ---------

1|         if (outNode) *outNode = do_QueryInterface(node);
>                                                    ----
2|         if (outNode) *outNode = do_QueryInterface(aParentNode);
>                                                    -----------

2|         if (outOffset) *outOffset = strLength-1;
>                                      ^^^^^^^^^^
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\editor\libeditor\html\nshtmleditor.cpp 1279:23 -> 1313:14
   -------------------------------------------------------------------------
   nsCOMPtr<nsIDOMNode> node = NextNodeInBlock(aParentNode, kIterBackward);
   nsCOMPtr<nsIDOMNode> tmp;
   while (node)
   {
     PRBool isBlock (PR_FALSE);
     NodeIsBlock(node, &isBlock);
     if (isBlock)  // skip over bold, italic, link, ect nodes
     {
       if (IsTextNode(node) && IsEditable(node))
       {
         textNode = do_QueryInterface(node);
         textNode->GetLength(&strLength);
         if (strLength)
         {
           // you could use nsIContent::TextIsOnlyWhitespace here
           textNode->SubstringData(strLength-1,strLength,tempString);
           *outIsSpace = nsCRT::IsAsciiSpace(tempString.First());
           *outIsNBSP = (tempString.First() == nbsp);
           if (outNode) *outNode = do_QueryInterface(aParentNode);
           if (outOffset) *outOffset = strLength-1;
           return NS_OK;
         }
         // else it's an empty text node, or not editable; skip it.
       }
       else  // node is an image or some other thingy that doesn't count as whitespace
       {
         break;
       }
     }
     // otherwise we found a node we want to skip, keep going
     tmp = node;
     node = NextNodeInBlock(tmp, kIterBackward);
   }
   
   return NS_OK;
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 128: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.732 | CED: 3 | FED: 5 (1.7%) | SZ: 287 | XF: F | XP: F | D: 3
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\editor\libeditor\html\nstableeditor.cpp 1606:28 -> 1669:0
   -------------------------------------------------------------------------
   nsHTMLEditor::SelectTableRow()
   {
     nsCOMPtr<nsIDOMElement> cell;
     nsresult res = GetElementOrParentByTagName(NS_LITERAL_STRING("td"), nsnull, getter_AddRefs(cell));
     NS_ENSURE_SUCCESS(res, res);
   
     // Don't fail if we didn't find a cell
     NS_ENSURE_TRUE(cell, NS_EDITOR_ELEMENT_NOT_FOUND);
     nsCOMPtr<nsIDOMElement> startCell = cell;
   
     // Get table and location of cell:
     nsCOMPtr<nsISelection> selection;
     nsCOMPtr<nsIDOMElement> table;
     PRInt32 startRowIndex, startColIndex;
   
     res = GetCellContext(getter_AddRefs(selection),
                          getter_AddRefs(table),
                          getter_AddRefs(cell),
                          nsnull, nsnull,
                          &startRowIndex, &startColIndex);
     NS_ENSURE_SUCCESS(res, res);
     NS_ENSURE_TRUE(table, NS_ERROR_FAILURE);
   
     PRInt32 rowCount, colCount;
     res = GetTableSize(table, &rowCount, &colCount);
     NS_ENSURE_SUCCESS(res, res);
   
     //Note: At this point, we could get first and last cells in row,
     //  then call SelectBlockOfCells, but that would take just
     //  a little less code, so the following is more efficient
   
     // Suppress nsISelectionListener notification
     //  until all selection changes are finished
     nsSelectionBatcherForTable selectionBatcher(selection);
   
     // It is now safe to clear the selection
     // BE SURE TO RESET IT BEFORE LEAVING!
     res = ClearSelection();
   
     // Select all cells in the same row as current cell
     PRBool cellSelected = PR_FALSE;
     PRInt32 rowSpan, colSpan, actualRowSpan, actualColSpan, currentRowIndex, currentColIndex;
     PRBool  isSelected;
     for(PRInt32 col = 0; col < colCount; col += NS_MAX(actualColSpan, 1))
     {
       res = GetCellDataAt(table, startRowIndex, col, getter_AddRefs(cell),
                           &currentRowIndex, &currentColIndex, &rowSpan, &colSpan,
                           &actualRowSpan, &actualColSpan, &isSelected);
       if (NS_FAILED(res)) break;
       // Skip cells that are spanned from previous rows or columns
       if (cell && currentRowIndex == startRowIndex && currentColIndex == col)
       {
         res = AppendNodeToSelectionAsRange(cell);
         if (NS_FAILED(res)) break;
         cellSelected = PR_TRUE;
       }
     }
     // Safety code to select starting cell if nothing else was selected
     if (!cellSelected)
     {
       return AppendNodeToSelectionAsRange(startCell);
     }
     return res;
   }
   -------------------------------------------------------------------------
   Potentially buggy differences:
1|   for(PRInt32 col = 0; col < colCount; col += NS_MAX(actualColSpan, 1))
>                               --------                -------------
2|   for(PRInt32 row = 0; row < rowCount; row += NS_MAX(actualRowSpan, 1))
>                               --------                -------------

1|     res = GetCellDataAt(table, startRowIndex, col, getter_AddRefs(cell),
>                                 -------------- ---
2|     res = GetCellDataAt(table, row, startColIndex, getter_AddRefs(cell),
>                                 ---- -------------
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\editor\libeditor\html\nstableeditor.cpp 1672:31 -> 1732:0
   -------------------------------------------------------------------------
   nsHTMLEditor::SelectTableColumn()
   {
     nsCOMPtr<nsIDOMElement> cell;
     nsresult res = GetElementOrParentByTagName(NS_LITERAL_STRING("td"), nsnull, getter_AddRefs(cell));
     NS_ENSURE_SUCCESS(res, res);
   
     // Don't fail if we didn't find a cell
     NS_ENSURE_TRUE(cell, NS_EDITOR_ELEMENT_NOT_FOUND);
   
     nsCOMPtr<nsIDOMElement> startCell = cell;
   
     // Get location of cell:
     nsCOMPtr<nsISelection> selection;
     nsCOMPtr<nsIDOMElement> table;
     PRInt32 startRowIndex, startColIndex;
   
     res = GetCellContext(getter_AddRefs(selection),
                          getter_AddRefs(table),
                          getter_AddRefs(cell),
                          nsnull, nsnull,
                          &startRowIndex, &startColIndex);
     NS_ENSURE_SUCCESS(res, res);
     NS_ENSURE_TRUE(table, NS_ERROR_FAILURE);
   
     PRInt32 rowCount, colCount;
     res = GetTableSize(table, &rowCount, &colCount);
     NS_ENSURE_SUCCESS(res, res);
   
     // Suppress nsISelectionListener notification
     //  until all selection changes are finished
     nsSelectionBatcherForTable selectionBatcher(selection);
   
     // It is now safe to clear the selection
     // BE SURE TO RESET IT BEFORE LEAVING!
     res = ClearSelection();
   
     // Select all cells in the same column as current cell
     PRBool cellSelected = PR_FALSE;
     PRInt32 rowSpan, colSpan, actualRowSpan, actualColSpan, currentRowIndex, currentColIndex;
     PRBool  isSelected;
     for(PRInt32 row = 0; row < rowCount; row += NS_MAX(actualRowSpan, 1))
     {
       res = GetCellDataAt(table, row, startColIndex, getter_AddRefs(cell),
                           &currentRowIndex, &currentColIndex, &rowSpan, &colSpan,
                           &actualRowSpan, &actualColSpan, &isSelected);
       if (NS_FAILED(res)) break;
       // Skip cells that are spanned from previous rows or columns
       if (cell && currentRowIndex == row && currentColIndex == startColIndex)
       {
         res = AppendNodeToSelectionAsRange(cell);
         if (NS_FAILED(res)) break;
         cellSelected = PR_TRUE;
       }
     }
     // Safety code to select starting cell if nothing else was selected
     if (!cellSelected)
     {
       return AppendNodeToSelectionAsRange(startCell);
     }
     return res;
   }
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 129: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.656 | CED: 2 | FED: 4 (3.6%) | SZ: 112 | XF: T | XP: T | D: inf
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\modules\plugin\base\src\nspluginhost.cpp 3151:54 -> 3179:0
   -------------------------------------------------------------------------
   nsresult nsPluginHost::NewEmbeddedPluginStreamListener(nsIURI* aURL,
                                                          nsIPluginInstanceOwner *aOwner,
                                                          nsNPAPIPluginInstance* aInstance,
                                                          nsIStreamListener** aListener)
   {
     if (!aURL)
       return NS_OK;
   
     nsRefPtr<nsPluginStreamListenerPeer> listener = new nsPluginStreamListenerPeer();
     if (!listener)
       return NS_ERROR_OUT_OF_MEMORY;
   
     nsresult rv;
   
     // if we have an instance, everything has been set up
     // if we only have an owner, then we need to pass it in
     // so the listener can set up the instance later after
     // we've determined the mimetype of the stream
     if (aInstance)
       rv = listener->InitializeEmbedded(aURL, aInstance);
     else if (aOwner != nsnull)
       rv = listener->InitializeEmbedded(aURL, nsnull, aOwner);
     else
       rv = NS_ERROR_ILLEGAL_VALUE;
     if (NS_SUCCEEDED(rv))
       NS_ADDREF(*aListener = listener);
   
     return rv;
   }
   -------------------------------------------------------------------------
   Potentially buggy differences:
2|   if (listener == nsnull)
>                 ^^ ^^^^^^

2|   if (aInstance != nsnull)
>                  ^^ ^^^^^^
   -------------------------------------------------------------------------
   c:\mozilla-central\modules\plugin\base\src\nspluginhost.cpp 3159:54 -> 3188:0
   -------------------------------------------------------------------------
   nsresult nsPluginHost::NewEmbeddedPluginStreamListener(nsIURI* aURL,
                                                          nsIPluginInstanceOwner *aOwner,
                                                          nsIPluginInstance* aInstance,
                                                          nsIStreamListener** aListener)
   {
     if (!aURL)
       return NS_OK;
   
     nsRefPtr<nsPluginStreamListenerPeer> listener =
         new nsPluginStreamListenerPeer();
     if (listener == nsnull)
       return NS_ERROR_OUT_OF_MEMORY;
   
     nsresult rv;
   
     // if we have an instance, everything has been set up
     // if we only have an owner, then we need to pass it in
     // so the listener can set up the instance later after
     // we've determined the mimetype of the stream
     if (aInstance != nsnull)
       rv = listener->InitializeEmbedded(aURL, aInstance);
     else if (aOwner != nsnull)
       rv = listener->InitializeEmbedded(aURL, nsnull, aOwner);
     else
       rv = NS_ERROR_ILLEGAL_VALUE;
     if (NS_SUCCEEDED(rv))
       NS_ADDREF(*aListener = listener);
   
     return rv;
   }
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 130: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.714 | CED: 1 | FED: 3 (4.4%) | SZ: 68 | XF: F | XP: F | D: 375
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\extensions\spellcheck\hunspell\src\affentry.cpp 128:32 -> 139:0
   -------------------------------------------------------------------------
   inline char * PfxEntry::nextchar(char * p) {
       if (p) {
           p++;
           if (opts & aeLONGCOND) {
               // jump to the 2nd part of the condition
               if (p == c.conds + MAXCONDLEN_1) return c.l.conds2;
           // end of the MAXCONDLEN length condition
           } else if (p == c.conds + MAXCONDLEN) return NULL;
       return *p ? p : NULL;
       }
       return NULL;
   }
   -------------------------------------------------------------------------
   Potentially buggy differences:
1|             if (p == c.conds + MAXCONDLEN_1) return c.l.conds2;
>                         -----
2|             if (p == c.l.conds1 + MAXCONDLEN_1) return c.l.conds2;
>                         --------
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\extensions\spellcheck\hunspell\src\affentry.cpp 514:32 -> 525:0
   -------------------------------------------------------------------------
   inline char * SfxEntry::nextchar(char * p) {
       if (p) {
       p++;
       if (opts & aeLONGCOND) {
               // jump to the 2nd part of the condition
               if (p == c.l.conds1 + MAXCONDLEN_1) return c.l.conds2;
       // end of the MAXCONDLEN length condition
       } else if (p == c.conds + MAXCONDLEN) return NULL;
       return *p ? p : NULL;
       }
       return NULL;
   }
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 131: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.678 | CED: 3 | FED: 10 (6.2%) | SZ: 162 | XF: T | XP: T | D: inf
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\content\base\src\nsdomattributemap.cpp 463:10 -> 497:14
   -------------------------------------------------------------------------
   PRInt32 nameSpaceID = kNameSpaceID_None;
   
   if (!aNamespaceURI.IsEmpty()) {
     nameSpaceID =
       nsContentUtils::NameSpaceManager()->GetNameSpaceID(aNamespaceURI);
   
     if (nameSpaceID == kNameSpaceID_Unknown) {
       return NS_OK;
     }
   }
   
   PRUint32 i, count = mContent->GetAttrCount();
   for (i = 0; i < count; ++i) {
     const nsAttrName* name = mContent->GetAttrNameAt(i);
     PRInt32 attrNS = name->NamespaceID();
     nsIAtom* nameAtom = name->LocalName();
   
     if (nameSpaceID == attrNS &&
         nameAtom->Equals(aLocalName)) {
       nsCOMPtr<nsINodeInfo> ni;
       ni = mContent->NodeInfo()->NodeInfoManager()->
         GetNodeInfo(nameAtom, name->GetPrefix(), nameSpaceID);
       NS_ENSURE_TRUE(ni, NS_ERROR_OUT_OF_MEMORY);
   
       if (aRemove) {
         return RemoveAttribute(ni, aReturn);
       }
   
       NS_ADDREF(*aReturn = GetAttribute(ni));
   
       return NS_OK;
     }
   }
   
   return NS_OK;
   -------------------------------------------------------------------------
   Potentially buggy differences:
1|     if (aRemove) {
>      --  -------  -
1|       return RemoveAttribute(ni, aReturn);
>        ------ ---------------
2|     return aRemove ? RemoveAttribute(ni, aReturn) : GetAttribute(ni, aReturn);
>      ------ ------- - --------------- --- -------  - ------------
   -------------------------------------------------------------------------
   c:\mozilla-central\content\base\src\nsdomattributemap.cpp 466:11 -> 500:14
   -------------------------------------------------------------------------
   *aReturn = nsnull;
   
   if (!mContent) {
     return NS_OK;
   }
   
   PRInt32 nameSpaceID = kNameSpaceID_None;
   
   if (!aNamespaceURI.IsEmpty()) {
     nameSpaceID =
       nsContentUtils::NameSpaceManager()->GetNameSpaceID(aNamespaceURI);
   
     if (nameSpaceID == kNameSpaceID_Unknown) {
       return NS_OK;
     }
   }
   
   PRUint32 i, count = mContent->GetAttrCount();
   for (i = 0; i < count; ++i) {
     const nsAttrName* name = mContent->GetAttrNameAt(i);
     PRInt32 attrNS = name->NamespaceID();
     nsIAtom* nameAtom = name->LocalName();
   
     if (nameSpaceID == attrNS &&
         nameAtom->Equals(aLocalName)) {
       nsCOMPtr<nsINodeInfo> ni;
       ni = mContent->NodeInfo()->NodeInfoManager()->
         GetNodeInfo(nameAtom, name->GetPrefix(), nameSpaceID);
       NS_ENSURE_TRUE(ni, NS_ERROR_OUT_OF_MEMORY);
   
       return aRemove ? RemoveAttribute(ni, aReturn) : GetAttribute(ni, aReturn);
     }
   }
   
   return NS_OK;
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 132: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.696 | CED: 1 | FED: 2 (2.1%) | SZ: 97 | XF: F | XP: F | D: 33
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\editor\libeditor\html\nshtmleditor.cpp 4614:33 -> 4633:0
   -------------------------------------------------------------------------
   nsHTMLEditor::GetPriorHTMLSibling(nsIDOMNode *inNode, nsCOMPtr<nsIDOMNode> *outNode)
   {
     NS_ENSURE_TRUE(outNode && inNode, NS_ERROR_NULL_POINTER);
     nsresult res = NS_OK;
     *outNode = nsnull;
     nsCOMPtr<nsIDOMNode> temp, node = do_QueryInterface(inNode);
   
     while (1)
     {
       res = node->GetPreviousSibling(getter_AddRefs(temp));
       NS_ENSURE_SUCCESS(res, res);
       NS_ENSURE_TRUE(temp, NS_OK);  // return null sibling
       // if it's editable, we're done
       if (IsEditable(temp)) break;
       // otherwise try again
       node = temp;
     }
     *outNode = temp;
     return res;
   }
   -------------------------------------------------------------------------
   Potentially buggy differences:
1|   NS_ENSURE_TRUE(outNode && inNode, NS_ERROR_NULL_POINTER);
>                           ^^ ^^^^^^
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\editor\libeditor\html\nshtmleditor.cpp 4666:32 -> 4685:0
   -------------------------------------------------------------------------
   nsHTMLEditor::GetNextHTMLSibling(nsIDOMNode *inNode, nsCOMPtr<nsIDOMNode> *outNode)
   {
     NS_ENSURE_TRUE(outNode, NS_ERROR_NULL_POINTER);
     nsresult res = NS_OK;
     *outNode = nsnull;
     nsCOMPtr<nsIDOMNode> temp, node = do_QueryInterface(inNode);
   
     while (1)
     {
       res = node->GetNextSibling(getter_AddRefs(temp));
       NS_ENSURE_SUCCESS(res, res);
       NS_ENSURE_TRUE(temp, NS_OK);  // return null sibling
       // if it's editable, we're done
       if (IsEditable(temp)) break;
       // otherwise try again
       node = temp;
     }
     *outNode = temp;
     return res;
   }
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 133: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.555 | CED: 2 | FED: 11 (11.3%) | SZ: 97 | XF: F | XP: F | D: 67
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\netwerk\protocol\ftp\nsftpconnectionthread.cpp 685:12 -> 707:36
   -------------------------------------------------------------------------
   if (mChannel->HasLoadFlag(nsIRequest::LOAD_ANONYMOUS))
     return NS_ERROR_FAILURE;
   
   nsCOMPtr<nsIAuthPrompt2> prompter;
   NS_QueryAuthPrompt2(static_cast<nsIChannel*>(mChannel),
                       getter_AddRefs(prompter));
   if (!prompter)
       return NS_ERROR_NOT_INITIALIZED;
   
   nsRefPtr<nsAuthInformationHolder> info =
       new nsAuthInformationHolder(nsIAuthInformation::AUTH_HOST,
                                   EmptyString(),
                                   EmptyCString());
   
   PRBool retval;
   rv = prompter->PromptAuth(mChannel, nsIAuthPrompt2::LEVEL_NONE,
                             info, &retval);
   
   // if the user canceled or didn't supply a username we want to fail
   if (NS_FAILED(rv) || !retval || info->User().IsEmpty())
       return NS_ERROR_FAILURE;
   
   mUsername = info->User();
   -------------------------------------------------------------------------
   Potentially buggy differences:
2|     new nsAuthInformationHolder(nsIAuthInformation::AUTH_HOST |
>                                                                ^
2|                                 nsIAuthInformation::ONLY_PASSWORD,
>                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

2|                                 EmptyCString());
>                                                ^
2| info->SetUserInternal(mUsername);
>  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\netwerk\protocol\ftp\nsftpconnectionthread.cpp 774:12 -> 800:40
   -------------------------------------------------------------------------
   if (mChannel->HasLoadFlag(nsIRequest::LOAD_ANONYMOUS))
       return NS_ERROR_FAILURE;
   
   nsCOMPtr<nsIAuthPrompt2> prompter;
   NS_QueryAuthPrompt2(static_cast<nsIChannel*>(mChannel),
                       getter_AddRefs(prompter));
   if (!prompter)
       return NS_ERROR_NOT_INITIALIZED;
   
   nsRefPtr<nsAuthInformationHolder> info =
       new nsAuthInformationHolder(nsIAuthInformation::AUTH_HOST |
                                   nsIAuthInformation::ONLY_PASSWORD,
                                   EmptyString(),
                                   EmptyCString());
   
   info->SetUserInternal(mUsername);
   
   PRBool retval;
   rv = prompter->PromptAuth(mChannel, nsIAuthPrompt2::LEVEL_NONE,
                             info, &retval);
   
   // we want to fail if the user canceled. Note here that if they want
   // a blank password, we will pass it along.
   if (NS_FAILED(rv) || !retval)
       return NS_ERROR_FAILURE;
   
   mPassword = info->Password();
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 134: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.605 | CED: 2 | FED: 6 (4.7%) | SZ: 127 | XF: T | XP: T | D: inf
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\intl\uconv\src\nsconverterinputstream.cpp 126:2 -> 161:14
   -------------------------------------------------------------------------
   NS_ASSERTION(mUnicharDataLength >= mUnicharDataOffset, "unsigned madness");
   PRUint32 bytesToWrite = mUnicharDataLength - mUnicharDataOffset;
   nsresult rv;
   if (0 == bytesToWrite) {
     // Fill the unichar buffer
     bytesToWrite = Fill(&rv);
     if (bytesToWrite <= 0) {
       *aReadCount = 0;
       return rv;
     }
   }
   
   if (bytesToWrite > aCount)
     bytesToWrite = aCount;
   
   PRUint32 bytesWritten;
   PRUint32 totalBytesWritten = 0;
   
   while (bytesToWrite) {
     rv = aWriter(this, aClosure,
                  mUnicharData->GetBuffer() + mUnicharDataOffset,
                  totalBytesWritten, bytesToWrite, &bytesWritten);
     if (NS_FAILED(rv)) {
       // don't propagate errors to the caller
       break;
     }
   
     bytesToWrite -= bytesWritten;
     totalBytesWritten += bytesWritten;
     mUnicharDataOffset += bytesWritten;
   
   }
   
   *aReadCount = totalBytesWritten;
   
   return NS_OK;
   -------------------------------------------------------------------------
   Potentially buggy differences:
2| nsresult rv = NS_OK;
>              ^ ^^^^^

2|   bytesToWrite = bytesRead;
>    ^^^^^^^^^^^^ ^ ^^^^^^^^^
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\xpcom\io\nsunicharinputstream.cpp 249:2 -> 283:33
   -------------------------------------------------------------------------
   NS_ASSERTION(mUnicharDataLength >= mUnicharDataOffset, "unsigned madness");
   PRUint32 bytesToWrite = mUnicharDataLength - mUnicharDataOffset;
   nsresult rv = NS_OK;
   if (0 == bytesToWrite) {
     // Fill the unichar buffer
     PRInt32 bytesRead = Fill(&rv);
     if (bytesRead <= 0) {
       *aReadCount = 0;
       return rv;
     }
     bytesToWrite = bytesRead;
   }
   
   if (bytesToWrite > aCount)
     bytesToWrite = aCount;
   
   PRUint32 bytesWritten;
   PRUint32 totalBytesWritten = 0;
   
   while (bytesToWrite) {
     rv = aWriter(this, aClosure,
                  mUnicharData->GetBuffer() + mUnicharDataOffset,
                  totalBytesWritten, bytesToWrite, &bytesWritten);
   
     if (NS_FAILED(rv)) {
       // don't propagate errors to the caller
       break;
     }
   
     bytesToWrite -= bytesWritten;
     totalBytesWritten += bytesWritten;
     mUnicharDataOffset += bytesWritten;
   }
   
   *aReadCount = totalBytesWritten;
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 135: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.540 | CED: 1 | FED: 5 (3.5%) | SZ: 144 | XF: F | XP: F | D: 15
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\editor\libeditor\html\nswsrunobject.cpp 558:2 -> 598:30
   -------------------------------------------------------------------------
   NS_ENSURE_TRUE(aNode && outVisNode && outVisOffset && outType, NS_ERROR_NULL_POINTER);
   
   *outType = eNone;
   WSFragment *run;
   FindRun(aNode, aOffset, &run, PR_FALSE);
   
   // is there a visible run there or earlier?
   while (run)
   {
     if (run->mType == eNormalWS)
     {
       WSPoint point;
       GetCharBefore(aNode, aOffset, &point);
       if (point.mTextNode)
       {
         *outVisNode = do_QueryInterface(point.mTextNode);
         *outVisOffset = point.mOffset+1;
         if (nsCRT::IsAsciiSpace(point.mChar) || (point.mChar==nbsp))
         {
           *outType = eNormalWS;
         }
         else if (!point.mChar)
         {
           // MOOSE: not possible?
           *outType = eNone;
         }
         else
         {
           *outType = eText;
         }
         return NS_OK;
       }
       // else if no text node then keep looking.  We should eventually fall out of loop
     }
   
     run = run->mLeft;
   }
   
   // if we get here then nothing in ws data to find.  return start reason
   *outVisNode = mStartReasonNode;
   *outVisOffset = mStartOffset;  // this really isn't meaningful if mStartReasonNode!=mStartNode
   -------------------------------------------------------------------------
   Potentially buggy differences:
1| *outType = eNone;
>  ^^^^^^^^ ^ ^^^^^
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\editor\libeditor\html\nswsrunobject.cpp 613:2 -> 654:14
   -------------------------------------------------------------------------
   NS_ENSURE_TRUE(aNode && outVisNode && outVisOffset && outType, NS_ERROR_NULL_POINTER);
   
   WSFragment *run;
   FindRun(aNode, aOffset, &run, PR_TRUE);
   
   // is there a visible run there or later?
   while (run)
   {
     if (run->mType == eNormalWS)
     {
       WSPoint point;
       GetCharAfter(aNode, aOffset, &point);
       if (point.mTextNode)
       {
         *outVisNode = do_QueryInterface(point.mTextNode);
         *outVisOffset = point.mOffset;
         if (nsCRT::IsAsciiSpace(point.mChar) || (point.mChar==nbsp))
         {
           *outType = eNormalWS;
         }
         else if (!point.mChar)
         {
           // MOOSE: not possible?
           *outType = eNone;
         }
         else
         {
           *outType = eText;
         }
         return NS_OK;
       }
       // else if no text node then keep looking.  We should eventually fall out of loop
     }
   
     run = run->mRight;
   }
   
   // if we get here then nothing in ws data to find.  return end reason
   *outVisNode = mEndReasonNode;
   *outVisOffset = mEndOffset; // this really isn't meaningful if mEndReasonNode!=mEndNode
   *outType = mEndReason;
   return NS_OK;
   -------------------------------------------------------------------------
*******************************************************************************

*******************************************************************************
 Clone group 136: 1 potentially buggy pair(s)
*******************************************************************************
 Pair a.) TxtSim: 0.552 | CED: 1 | FED: 7 (4.0%) | SZ: 175 | XF: F | XP: F | D: 18
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\layout\xul\base\src\nsxulpopupmanager.cpp 1016:2 -> 1060:2
   -------------------------------------------------------------------------
   if (aPopupType == ePopupTypePanel &&
       !aPopup->AttrValueIs(kNameSpaceID_None, nsGkAtoms::noautofocus,
                            nsGkAtoms::_true, eCaseMatters)) {
     nsIFocusManager* fm = nsFocusManager::GetFocusManager();
     if (fm) {
       nsIDocument* doc = aPopup->GetCurrentDoc();
   
       // Only remove the focus if the currently focused item is ouside the
       // popup. It isn't a big deal if the current focus is in a child popup
       // inside the popup as that shouldn't be visible. This check ensures that
       // a node inside the popup that is focused during a popupshowing event
       // remains focused.
       nsCOMPtr<nsIDOMElement> currentFocusElement;
       fm->GetFocusedElement(getter_AddRefs(currentFocusElement));
       nsCOMPtr<nsIContent> currentFocus = do_QueryInterface(currentFocusElement);
       if (doc && currentFocus &&
           !nsContentUtils::ContentIsCrossDocDescendantOf(currentFocus, aPopup)) {
         fm->ClearFocus(doc->GetWindow());
       }
     }
   }
   
   // it is common to append content to the menu during the popupshowing event.
   // Flush the notifications so that the frames are up to date before showing
   // the popup, otherwise the new frames will reflow after the popup appears,
   // causing the popup to flicker. Frame code always calls this asynchronously,
   // so this should be safe.
   nsIDocument *document = aPopup->GetCurrentDoc();
   if (document)
     document->FlushPendingNotifications(Flush_Layout);
   
   // get the frame again in case it went away
   nsIFrame* frame = aPopup->GetPrimaryFrame();
   if (frame && frame->GetType() == nsGkAtoms::menuPopupFrame) {
     nsMenuPopupFrame* popupFrame = static_cast<nsMenuPopupFrame *>(frame);
   
     // if the event was cancelled, don't open the popup, and reset it's
     // state back to closed
     if (status == nsEventStatus_eConsumeNoDefault) {
       popupFrame->SetPopupState(ePopupClosed);
     }
     else {
       ShowPopupCallback(aPopup, popupFrame, aIsContextMenu, aSelectFirstItem);
     }
   }
   -------------------------------------------------------------------------
   Potentially buggy differences:
2|   if (status == nsEventStatus_eConsumeNoDefault &&
>                                                  ^^
2|       !popupFrame->IsInContentShell()) {
>        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   -------------------------------------------------------------------------
   c:\comm-central\mozilla\layout\xul\base\src\nsxulpopupmanager.cpp 1078:2 -> 1113:0
   -------------------------------------------------------------------------
   if (aPopupType == ePopupTypePanel &&
       !aPopup->AttrValueIs(kNameSpaceID_None, nsGkAtoms::noautofocus,
                            nsGkAtoms::_true, eCaseMatters)) {
     nsIFocusManager* fm = nsFocusManager::GetFocusManager();
     if (fm) {
       nsIDocument* doc = aPopup->GetCurrentDoc();
   
       // Remove the focus from the focused node only if it is inside the popup.
       nsCOMPtr<nsIDOMElement> currentFocusElement;
       fm->GetFocusedElement(getter_AddRefs(currentFocusElement));
       nsCOMPtr<nsIContent> currentFocus = do_QueryInterface(currentFocusElement);
       if (doc && currentFocus &&
           nsContentUtils::ContentIsCrossDocDescendantOf(currentFocus, aPopup)) {
         fm->ClearFocus(doc->GetWindow());
       }
     }
   }
   
   // get frame again in case it went away
   nsIFrame* frame = aPopup->GetPrimaryFrame();
   if (frame && frame->GetType() == nsGkAtoms::menuPopupFrame) {
     nsMenuPopupFrame* popupFrame = static_cast<nsMenuPopupFrame *>(frame);
   
     // if the event was cancelled, don't hide the popup, and reset it's
     // state back to open. Only popups in chrome shells can prevent a popup
     // from hiding.
     if (status == nsEventStatus_eConsumeNoDefault &&
         !popupFrame->IsInContentShell()) {
       popupFrame->SetPopupState(ePopupOpenAndVisible);
     }
     else {
       HidePopupCallback(aPopup, popupFrame, aNextPopup, aLastPopup,
                         aPopupType, aDeselectMenu);
     }
   }
   }
   -------------------------------------------------------------------------
*******************************************************************************

